/* soapC.cpp
   Generated by gSOAP 2.8.55 for E:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\source.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.55 2017-12-02 17:02:56 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns__RequestType:
		return soap_in_ns__RequestType(soap, NULL, NULL, "ns:RequestType");
	case SOAP_TYPE_ns__DeviceModel:
		return soap_in_ns__DeviceModel(soap, NULL, NULL, "ns:DeviceModel");
	case SOAP_TYPE_ns__SensorName:
		return soap_in_ns__SensorName(soap, NULL, NULL, "ns:SensorName");
	case SOAP_TYPE_ns__SensorType:
		return soap_in_ns__SensorType(soap, NULL, NULL, "ns:SensorType");
	case SOAP_TYPE_ns__UserType:
		return soap_in_ns__UserType(soap, NULL, NULL, "ns:UserType");
	case SOAP_TYPE_ns__SettingLevel:
		return soap_in_ns__SettingLevel(soap, NULL, NULL, "ns:SettingLevel");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns__AllCityLocatoins:
		return soap_in_ns__AllCityLocatoins(soap, NULL, NULL, "ns:AllCityLocatoins");
	case SOAP_TYPE_ns__CityLocation:
		return soap_in_ns__CityLocation(soap, NULL, NULL, "ns:CityLocation");
	case SOAP_TYPE_ns__ServerOptions:
		return soap_in_ns__ServerOptions(soap, NULL, NULL, "ns:ServerOptions");
	case SOAP_TYPE_ns__DataBase:
		return soap_in_ns__DataBase(soap, NULL, NULL, "ns:DataBase");
	case SOAP_TYPE_ns__UserDevice:
		return soap_in_ns__UserDevice(soap, NULL, NULL, "ns:UserDevice");
	case SOAP_TYPE_ns__ErrorLog:
		return soap_in_ns__ErrorLog(soap, NULL, NULL, "ns:ErrorLog");
	case SOAP_TYPE_ns__DeviceStatus:
		return soap_in_ns__DeviceStatus(soap, NULL, NULL, "ns:DeviceStatus");
	case SOAP_TYPE_ns__DeviceStatusLogList:
		return soap_in_ns__DeviceStatusLogList(soap, NULL, NULL, "ns:DeviceStatusLogList");
	case SOAP_TYPE_ns__DeviceStatusLog:
		return soap_in_ns__DeviceStatusLog(soap, NULL, NULL, "ns:DeviceStatusLog");
	case SOAP_TYPE_ns__UserLog:
		return soap_in_ns__UserLog(soap, NULL, NULL, "ns:UserLog");
	case SOAP_TYPE_ns__ActivityLog:
		return soap_in_ns__ActivityLog(soap, NULL, NULL, "ns:ActivityLog");
	case SOAP_TYPE_ns__ReportRange:
		return soap_in_ns__ReportRange(soap, NULL, NULL, "ns:ReportRange");
	case SOAP_TYPE_ns__Device:
		return soap_in_ns__Device(soap, NULL, NULL, "ns:Device");
	case SOAP_TYPE_ns__Picture:
		return soap_in_ns__Picture(soap, NULL, NULL, "ns:Picture");
	case SOAP_TYPE_ns__PicturePart:
		return soap_in_ns__PicturePart(soap, NULL, NULL, "ns:PicturePart");
	case SOAP_TYPE_ns__Camera:
		return soap_in_ns__Camera(soap, NULL, NULL, "ns:Camera");
	case SOAP_TYPE_ns__SensorExtension:
		return soap_in_ns__SensorExtension(soap, NULL, NULL, "ns:SensorExtension");
	case SOAP_TYPE_ns__Sensor:
		return soap_in_ns__Sensor(soap, NULL, NULL, "ns:Sensor");
	case SOAP_TYPE_ns__CalibrationList:
		return soap_in_ns__CalibrationList(soap, NULL, NULL, "ns:CalibrationList");
	case SOAP_TYPE_ns__Calibration:
		return soap_in_ns__Calibration(soap, NULL, NULL, "ns:Calibration");
	case SOAP_TYPE_ns__GPS:
		return soap_in_ns__GPS(soap, NULL, NULL, "ns:GPS");
	case SOAP_TYPE_ns__IP:
		return soap_in_ns__IP(soap, NULL, NULL, "ns:IP");
	case SOAP_TYPE_ns__UsersList:
		return soap_in_ns__UsersList(soap, NULL, NULL, "ns:UsersList");
	case SOAP_TYPE_ns__User:
		return soap_in_ns__User(soap, NULL, NULL, "ns:User");
	case SOAP_TYPE_ns__ErrorCode:
		return soap_in_ns__ErrorCode(soap, NULL, NULL, "ns:ErrorCode");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns__ChangeDeviceName:
		return soap_in_ns__ChangeDeviceName(soap, NULL, NULL, "ns:ChangeDeviceName");
	case SOAP_TYPE_ns__ChangeLocationName:
		return soap_in_ns__ChangeLocationName(soap, NULL, NULL, "ns:ChangeLocationName");
	case SOAP_TYPE_ns__ChangeCityName:
		return soap_in_ns__ChangeCityName(soap, NULL, NULL, "ns:ChangeCityName");
	case SOAP_TYPE_ns__GetCityAndLocations:
		return soap_in_ns__GetCityAndLocations(soap, NULL, NULL, "ns:GetCityAndLocations");
	case SOAP_TYPE_ns__SetServerOptions:
		return soap_in_ns__SetServerOptions(soap, NULL, NULL, "ns:SetServerOptions");
	case SOAP_TYPE_ns__GetServerOptions:
		return soap_in_ns__GetServerOptions(soap, NULL, NULL, "ns:GetServerOptions");
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		return soap_in_ns__GetDeviceStatusLog(soap, NULL, NULL, "ns:GetDeviceStatusLog");
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		return soap_in_ns__SaveDeviceStatusLog(soap, NULL, NULL, "ns:SaveDeviceStatusLog");
	case SOAP_TYPE_ns__GetUserLog:
		return soap_in_ns__GetUserLog(soap, NULL, NULL, "ns:GetUserLog");
	case SOAP_TYPE_ns__GetUserLogResponse:
		return soap_in_ns__GetUserLogResponse(soap, NULL, NULL, "ns:GetUserLogResponse");
	case SOAP_TYPE_ns__SaveUserLog:
		return soap_in_ns__SaveUserLog(soap, NULL, NULL, "ns:SaveUserLog");
	case SOAP_TYPE_ns__GetActivityLog:
		return soap_in_ns__GetActivityLog(soap, NULL, NULL, "ns:GetActivityLog");
	case SOAP_TYPE_ns__GetActivityLogResponse:
		return soap_in_ns__GetActivityLogResponse(soap, NULL, NULL, "ns:GetActivityLogResponse");
	case SOAP_TYPE_ns__SaveActivityLog:
		return soap_in_ns__SaveActivityLog(soap, NULL, NULL, "ns:SaveActivityLog");
	case SOAP_TYPE_ns__GetUserDevices:
		return soap_in_ns__GetUserDevices(soap, NULL, NULL, "ns:GetUserDevices");
	case SOAP_TYPE_ns__DeleteDeviceFromUser:
		return soap_in_ns__DeleteDeviceFromUser(soap, NULL, NULL, "ns:DeleteDeviceFromUser");
	case SOAP_TYPE_ns__AssignDeviceToUser:
		return soap_in_ns__AssignDeviceToUser(soap, NULL, NULL, "ns:AssignDeviceToUser");
	case SOAP_TYPE_ns__DeleteUser:
		return soap_in_ns__DeleteUser(soap, NULL, NULL, "ns:DeleteUser");
	case SOAP_TYPE_ns__UpdateUser:
		return soap_in_ns__UpdateUser(soap, NULL, NULL, "ns:UpdateUser");
	case SOAP_TYPE_ns__AddUser:
		return soap_in_ns__AddUser(soap, NULL, NULL, "ns:AddUser");
	case SOAP_TYPE_ns__GetUsersList:
		return soap_in_ns__GetUsersList(soap, NULL, NULL, "ns:GetUsersList");
	case SOAP_TYPE_ns__GetUserDeviceList:
		return soap_in_ns__GetUserDeviceList(soap, NULL, NULL, "ns:GetUserDeviceList");
	case SOAP_TYPE_ns__Login:
		return soap_in_ns__Login(soap, NULL, NULL, "ns:Login");
	case SOAP_TYPE_ns__GetDeviceCalibration:
		return soap_in_ns__GetDeviceCalibration(soap, NULL, NULL, "ns:GetDeviceCalibration");
	case SOAP_TYPE_ns__SetDeviceCalibration:
		return soap_in_ns__SetDeviceCalibration(soap, NULL, NULL, "ns:SetDeviceCalibration");
	case SOAP_TYPE_ns__DeleteDevices:
		return soap_in_ns__DeleteDevices(soap, NULL, NULL, "ns:DeleteDevices");
	case SOAP_TYPE_ns__DeleteDevicesResponse:
		return soap_in_ns__DeleteDevicesResponse(soap, NULL, NULL, "ns:DeleteDevicesResponse");
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		return soap_in_ns__SetAllDeviceSetting(soap, NULL, NULL, "ns:SetAllDeviceSetting");
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		return soap_in_ns__SetAllDeviceSettingResponse(soap, NULL, NULL, "ns:SetAllDeviceSettingResponse");
	case SOAP_TYPE_ns__SetDeviceSettingSMS:
		return soap_in_ns__SetDeviceSettingSMS(soap, NULL, NULL, "ns:SetDeviceSettingSMS");
	case SOAP_TYPE_ns__SetDeviceSetting:
		return soap_in_ns__SetDeviceSetting(soap, NULL, NULL, "ns:SetDeviceSetting");
	case SOAP_TYPE_ns__SetDeviceSettingResponse:
		return soap_in_ns__SetDeviceSettingResponse(soap, NULL, NULL, "ns:SetDeviceSettingResponse");
	case SOAP_TYPE_ns__GetDevicePicturePart:
		return soap_in_ns__GetDevicePicturePart(soap, NULL, NULL, "ns:GetDevicePicturePart");
	case SOAP_TYPE_ns__GetDevicePicture:
		return soap_in_ns__GetDevicePicture(soap, NULL, NULL, "ns:GetDevicePicture");
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		return soap_in_ns__GetAllDeviceStatus(soap, NULL, NULL, "ns:GetAllDeviceStatus");
	case SOAP_TYPE_ns__GetDeviceStatusSMS:
		return soap_in_ns__GetDeviceStatusSMS(soap, NULL, NULL, "ns:GetDeviceStatusSMS");
	case SOAP_TYPE_ns__GetDeviceStatus:
		return soap_in_ns__GetDeviceStatus(soap, NULL, NULL, "ns:GetDeviceStatus");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns:AllCityLocatoins"))
		{	*type = SOAP_TYPE_ns__AllCityLocatoins;
			return soap_in_ns__AllCityLocatoins(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:CityLocation"))
		{	*type = SOAP_TYPE_ns__CityLocation;
			return soap_in_ns__CityLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ServerOptions"))
		{	*type = SOAP_TYPE_ns__ServerOptions;
			return soap_in_ns__ServerOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DataBase"))
		{	*type = SOAP_TYPE_ns__DataBase;
			return soap_in_ns__DataBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UserDevice"))
		{	*type = SOAP_TYPE_ns__UserDevice;
			return soap_in_ns__UserDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ErrorLog"))
		{	*type = SOAP_TYPE_ns__ErrorLog;
			return soap_in_ns__ErrorLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeviceStatus"))
		{	*type = SOAP_TYPE_ns__DeviceStatus;
			return soap_in_ns__DeviceStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeviceStatusLogList"))
		{	*type = SOAP_TYPE_ns__DeviceStatusLogList;
			return soap_in_ns__DeviceStatusLogList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeviceStatusLog"))
		{	*type = SOAP_TYPE_ns__DeviceStatusLog;
			return soap_in_ns__DeviceStatusLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UserLog"))
		{	*type = SOAP_TYPE_ns__UserLog;
			return soap_in_ns__UserLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ActivityLog"))
		{	*type = SOAP_TYPE_ns__ActivityLog;
			return soap_in_ns__ActivityLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ReportRange"))
		{	*type = SOAP_TYPE_ns__ReportRange;
			return soap_in_ns__ReportRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Device"))
		{	*type = SOAP_TYPE_ns__Device;
			return soap_in_ns__Device(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Picture"))
		{	*type = SOAP_TYPE_ns__Picture;
			return soap_in_ns__Picture(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:PicturePart"))
		{	*type = SOAP_TYPE_ns__PicturePart;
			return soap_in_ns__PicturePart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Camera"))
		{	*type = SOAP_TYPE_ns__Camera;
			return soap_in_ns__Camera(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SensorExtension"))
		{	*type = SOAP_TYPE_ns__SensorExtension;
			return soap_in_ns__SensorExtension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Sensor"))
		{	*type = SOAP_TYPE_ns__Sensor;
			return soap_in_ns__Sensor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:CalibrationList"))
		{	*type = SOAP_TYPE_ns__CalibrationList;
			return soap_in_ns__CalibrationList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Calibration"))
		{	*type = SOAP_TYPE_ns__Calibration;
			return soap_in_ns__Calibration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GPS"))
		{	*type = SOAP_TYPE_ns__GPS;
			return soap_in_ns__GPS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:IP"))
		{	*type = SOAP_TYPE_ns__IP;
			return soap_in_ns__IP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UsersList"))
		{	*type = SOAP_TYPE_ns__UsersList;
			return soap_in_ns__UsersList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:User"))
		{	*type = SOAP_TYPE_ns__User;
			return soap_in_ns__User(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ErrorCode"))
		{	*type = SOAP_TYPE_ns__ErrorCode;
			return soap_in_ns__ErrorCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:RequestType"))
		{	*type = SOAP_TYPE_ns__RequestType;
			return soap_in_ns__RequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeviceModel"))
		{	*type = SOAP_TYPE_ns__DeviceModel;
			return soap_in_ns__DeviceModel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SensorName"))
		{	*type = SOAP_TYPE_ns__SensorName;
			return soap_in_ns__SensorName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SensorType"))
		{	*type = SOAP_TYPE_ns__SensorType;
			return soap_in_ns__SensorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UserType"))
		{	*type = SOAP_TYPE_ns__UserType;
			return soap_in_ns__UserType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SettingLevel"))
		{	*type = SOAP_TYPE_ns__SettingLevel;
			return soap_in_ns__SettingLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ChangeDeviceName"))
		{	*type = SOAP_TYPE_ns__ChangeDeviceName;
			return soap_in_ns__ChangeDeviceName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ChangeLocationName"))
		{	*type = SOAP_TYPE_ns__ChangeLocationName;
			return soap_in_ns__ChangeLocationName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:ChangeCityName"))
		{	*type = SOAP_TYPE_ns__ChangeCityName;
			return soap_in_ns__ChangeCityName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetCityAndLocations"))
		{	*type = SOAP_TYPE_ns__GetCityAndLocations;
			return soap_in_ns__GetCityAndLocations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetServerOptions"))
		{	*type = SOAP_TYPE_ns__SetServerOptions;
			return soap_in_ns__SetServerOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetServerOptions"))
		{	*type = SOAP_TYPE_ns__GetServerOptions;
			return soap_in_ns__GetServerOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetDeviceStatusLog"))
		{	*type = SOAP_TYPE_ns__GetDeviceStatusLog;
			return soap_in_ns__GetDeviceStatusLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SaveDeviceStatusLog"))
		{	*type = SOAP_TYPE_ns__SaveDeviceStatusLog;
			return soap_in_ns__SaveDeviceStatusLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetUserLog"))
		{	*type = SOAP_TYPE_ns__GetUserLog;
			return soap_in_ns__GetUserLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetUserLogResponse"))
		{	*type = SOAP_TYPE_ns__GetUserLogResponse;
			return soap_in_ns__GetUserLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SaveUserLog"))
		{	*type = SOAP_TYPE_ns__SaveUserLog;
			return soap_in_ns__SaveUserLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetActivityLog"))
		{	*type = SOAP_TYPE_ns__GetActivityLog;
			return soap_in_ns__GetActivityLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetActivityLogResponse"))
		{	*type = SOAP_TYPE_ns__GetActivityLogResponse;
			return soap_in_ns__GetActivityLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SaveActivityLog"))
		{	*type = SOAP_TYPE_ns__SaveActivityLog;
			return soap_in_ns__SaveActivityLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetUserDevices"))
		{	*type = SOAP_TYPE_ns__GetUserDevices;
			return soap_in_ns__GetUserDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeleteDeviceFromUser"))
		{	*type = SOAP_TYPE_ns__DeleteDeviceFromUser;
			return soap_in_ns__DeleteDeviceFromUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AssignDeviceToUser"))
		{	*type = SOAP_TYPE_ns__AssignDeviceToUser;
			return soap_in_ns__AssignDeviceToUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeleteUser"))
		{	*type = SOAP_TYPE_ns__DeleteUser;
			return soap_in_ns__DeleteUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:UpdateUser"))
		{	*type = SOAP_TYPE_ns__UpdateUser;
			return soap_in_ns__UpdateUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:AddUser"))
		{	*type = SOAP_TYPE_ns__AddUser;
			return soap_in_ns__AddUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetUsersList"))
		{	*type = SOAP_TYPE_ns__GetUsersList;
			return soap_in_ns__GetUsersList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetUserDeviceList"))
		{	*type = SOAP_TYPE_ns__GetUserDeviceList;
			return soap_in_ns__GetUserDeviceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Login"))
		{	*type = SOAP_TYPE_ns__Login;
			return soap_in_ns__Login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetDeviceCalibration"))
		{	*type = SOAP_TYPE_ns__GetDeviceCalibration;
			return soap_in_ns__GetDeviceCalibration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetDeviceCalibration"))
		{	*type = SOAP_TYPE_ns__SetDeviceCalibration;
			return soap_in_ns__SetDeviceCalibration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeleteDevices"))
		{	*type = SOAP_TYPE_ns__DeleteDevices;
			return soap_in_ns__DeleteDevices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:DeleteDevicesResponse"))
		{	*type = SOAP_TYPE_ns__DeleteDevicesResponse;
			return soap_in_ns__DeleteDevicesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetAllDeviceSetting"))
		{	*type = SOAP_TYPE_ns__SetAllDeviceSetting;
			return soap_in_ns__SetAllDeviceSetting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetAllDeviceSettingResponse"))
		{	*type = SOAP_TYPE_ns__SetAllDeviceSettingResponse;
			return soap_in_ns__SetAllDeviceSettingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetDeviceSettingSMS"))
		{	*type = SOAP_TYPE_ns__SetDeviceSettingSMS;
			return soap_in_ns__SetDeviceSettingSMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetDeviceSetting"))
		{	*type = SOAP_TYPE_ns__SetDeviceSetting;
			return soap_in_ns__SetDeviceSetting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SetDeviceSettingResponse"))
		{	*type = SOAP_TYPE_ns__SetDeviceSettingResponse;
			return soap_in_ns__SetDeviceSettingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetDevicePicturePart"))
		{	*type = SOAP_TYPE_ns__GetDevicePicturePart;
			return soap_in_ns__GetDevicePicturePart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetDevicePicture"))
		{	*type = SOAP_TYPE_ns__GetDevicePicture;
			return soap_in_ns__GetDevicePicture(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetAllDeviceStatus"))
		{	*type = SOAP_TYPE_ns__GetAllDeviceStatus;
			return soap_in_ns__GetAllDeviceStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetDeviceStatusSMS"))
		{	*type = SOAP_TYPE_ns__GetDeviceStatusSMS;
			return soap_in_ns__GetDeviceStatusSMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:GetDeviceStatus"))
		{	*type = SOAP_TYPE_ns__GetDeviceStatus;
			return soap_in_ns__GetDeviceStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_out_xsd__int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_xsd__long:
		return soap_out_xsd__long(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_xsd__double:
		return soap_out_xsd__double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_xsd__dateTime:
		return soap_out_xsd__dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ns__RequestType:
		return soap_out_ns__RequestType(soap, tag, id, (const enum ns__RequestType *)ptr, "ns:RequestType");
	case SOAP_TYPE_ns__DeviceModel:
		return soap_out_ns__DeviceModel(soap, tag, id, (const enum ns__DeviceModel *)ptr, "ns:DeviceModel");
	case SOAP_TYPE_ns__SensorName:
		return soap_out_ns__SensorName(soap, tag, id, (const enum ns__SensorName *)ptr, "ns:SensorName");
	case SOAP_TYPE_ns__SensorType:
		return soap_out_ns__SensorType(soap, tag, id, (const enum ns__SensorType *)ptr, "ns:SensorType");
	case SOAP_TYPE_ns__UserType:
		return soap_out_ns__UserType(soap, tag, id, (const enum ns__UserType *)ptr, "ns:UserType");
	case SOAP_TYPE_ns__SettingLevel:
		return soap_out_ns__SettingLevel(soap, tag, id, (const enum ns__SettingLevel *)ptr, "ns:SettingLevel");
	case SOAP_TYPE_xsd__boolean:
		return soap_out_xsd__boolean(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns__AllCityLocatoins:
		return ((ns__AllCityLocatoins *)ptr)->soap_out(soap, tag, id, "ns:AllCityLocatoins");
	case SOAP_TYPE_ns__CityLocation:
		return ((ns__CityLocation *)ptr)->soap_out(soap, tag, id, "ns:CityLocation");
	case SOAP_TYPE_ns__ServerOptions:
		return ((ns__ServerOptions *)ptr)->soap_out(soap, tag, id, "ns:ServerOptions");
	case SOAP_TYPE_ns__DataBase:
		return ((ns__DataBase *)ptr)->soap_out(soap, tag, id, "ns:DataBase");
	case SOAP_TYPE_ns__UserDevice:
		return ((ns__UserDevice *)ptr)->soap_out(soap, tag, id, "ns:UserDevice");
	case SOAP_TYPE_ns__ErrorLog:
		return ((ns__ErrorLog *)ptr)->soap_out(soap, tag, id, "ns:ErrorLog");
	case SOAP_TYPE_ns__DeviceStatus:
		return ((ns__DeviceStatus *)ptr)->soap_out(soap, tag, id, "ns:DeviceStatus");
	case SOAP_TYPE_ns__DeviceStatusLogList:
		return ((ns__DeviceStatusLogList *)ptr)->soap_out(soap, tag, id, "ns:DeviceStatusLogList");
	case SOAP_TYPE_ns__DeviceStatusLog:
		return ((ns__DeviceStatusLog *)ptr)->soap_out(soap, tag, id, "ns:DeviceStatusLog");
	case SOAP_TYPE_ns__UserLog:
		return ((ns__UserLog *)ptr)->soap_out(soap, tag, id, "ns:UserLog");
	case SOAP_TYPE_ns__ActivityLog:
		return ((ns__ActivityLog *)ptr)->soap_out(soap, tag, id, "ns:ActivityLog");
	case SOAP_TYPE_ns__ReportRange:
		return ((ns__ReportRange *)ptr)->soap_out(soap, tag, id, "ns:ReportRange");
	case SOAP_TYPE_ns__Device:
		return ((ns__Device *)ptr)->soap_out(soap, tag, id, "ns:Device");
	case SOAP_TYPE_ns__Picture:
		return ((ns__Picture *)ptr)->soap_out(soap, tag, id, "ns:Picture");
	case SOAP_TYPE_ns__PicturePart:
		return ((ns__PicturePart *)ptr)->soap_out(soap, tag, id, "ns:PicturePart");
	case SOAP_TYPE_ns__Camera:
		return ((ns__Camera *)ptr)->soap_out(soap, tag, id, "ns:Camera");
	case SOAP_TYPE_ns__SensorExtension:
		return ((ns__SensorExtension *)ptr)->soap_out(soap, tag, id, "ns:SensorExtension");
	case SOAP_TYPE_ns__Sensor:
		return ((ns__Sensor *)ptr)->soap_out(soap, tag, id, "ns:Sensor");
	case SOAP_TYPE_ns__CalibrationList:
		return ((ns__CalibrationList *)ptr)->soap_out(soap, tag, id, "ns:CalibrationList");
	case SOAP_TYPE_ns__Calibration:
		return ((ns__Calibration *)ptr)->soap_out(soap, tag, id, "ns:Calibration");
	case SOAP_TYPE_ns__GPS:
		return ((ns__GPS *)ptr)->soap_out(soap, tag, id, "ns:GPS");
	case SOAP_TYPE_ns__IP:
		return ((ns__IP *)ptr)->soap_out(soap, tag, id, "ns:IP");
	case SOAP_TYPE_ns__UsersList:
		return ((ns__UsersList *)ptr)->soap_out(soap, tag, id, "ns:UsersList");
	case SOAP_TYPE_ns__User:
		return ((ns__User *)ptr)->soap_out(soap, tag, id, "ns:User");
	case SOAP_TYPE_ns__ErrorCode:
		return ((ns__ErrorCode *)ptr)->soap_out(soap, tag, id, "ns:ErrorCode");
	case SOAP_TYPE_xsd__string:
		return soap_out_xsd__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns__ChangeDeviceName:
		return soap_out_ns__ChangeDeviceName(soap, tag, id, (const struct ns__ChangeDeviceName *)ptr, "ns:ChangeDeviceName");
	case SOAP_TYPE_ns__ChangeLocationName:
		return soap_out_ns__ChangeLocationName(soap, tag, id, (const struct ns__ChangeLocationName *)ptr, "ns:ChangeLocationName");
	case SOAP_TYPE_ns__ChangeCityName:
		return soap_out_ns__ChangeCityName(soap, tag, id, (const struct ns__ChangeCityName *)ptr, "ns:ChangeCityName");
	case SOAP_TYPE_ns__GetCityAndLocations:
		return soap_out_ns__GetCityAndLocations(soap, tag, id, (const struct ns__GetCityAndLocations *)ptr, "ns:GetCityAndLocations");
	case SOAP_TYPE_ns__SetServerOptions:
		return soap_out_ns__SetServerOptions(soap, tag, id, (const struct ns__SetServerOptions *)ptr, "ns:SetServerOptions");
	case SOAP_TYPE_ns__GetServerOptions:
		return soap_out_ns__GetServerOptions(soap, tag, id, (const struct ns__GetServerOptions *)ptr, "ns:GetServerOptions");
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		return soap_out_ns__GetDeviceStatusLog(soap, tag, id, (const struct ns__GetDeviceStatusLog *)ptr, "ns:GetDeviceStatusLog");
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		return soap_out_ns__SaveDeviceStatusLog(soap, tag, id, (const struct ns__SaveDeviceStatusLog *)ptr, "ns:SaveDeviceStatusLog");
	case SOAP_TYPE_ns__GetUserLog:
		return soap_out_ns__GetUserLog(soap, tag, id, (const struct ns__GetUserLog *)ptr, "ns:GetUserLog");
	case SOAP_TYPE_ns__GetUserLogResponse:
		return soap_out_ns__GetUserLogResponse(soap, tag, id, (const struct ns__GetUserLogResponse *)ptr, "ns:GetUserLogResponse");
	case SOAP_TYPE_ns__SaveUserLog:
		return soap_out_ns__SaveUserLog(soap, tag, id, (const struct ns__SaveUserLog *)ptr, "ns:SaveUserLog");
	case SOAP_TYPE_ns__GetActivityLog:
		return soap_out_ns__GetActivityLog(soap, tag, id, (const struct ns__GetActivityLog *)ptr, "ns:GetActivityLog");
	case SOAP_TYPE_ns__GetActivityLogResponse:
		return soap_out_ns__GetActivityLogResponse(soap, tag, id, (const struct ns__GetActivityLogResponse *)ptr, "ns:GetActivityLogResponse");
	case SOAP_TYPE_ns__SaveActivityLog:
		return soap_out_ns__SaveActivityLog(soap, tag, id, (const struct ns__SaveActivityLog *)ptr, "ns:SaveActivityLog");
	case SOAP_TYPE_ns__GetUserDevices:
		return soap_out_ns__GetUserDevices(soap, tag, id, (const struct ns__GetUserDevices *)ptr, "ns:GetUserDevices");
	case SOAP_TYPE_ns__DeleteDeviceFromUser:
		return soap_out_ns__DeleteDeviceFromUser(soap, tag, id, (const struct ns__DeleteDeviceFromUser *)ptr, "ns:DeleteDeviceFromUser");
	case SOAP_TYPE_ns__AssignDeviceToUser:
		return soap_out_ns__AssignDeviceToUser(soap, tag, id, (const struct ns__AssignDeviceToUser *)ptr, "ns:AssignDeviceToUser");
	case SOAP_TYPE_ns__DeleteUser:
		return soap_out_ns__DeleteUser(soap, tag, id, (const struct ns__DeleteUser *)ptr, "ns:DeleteUser");
	case SOAP_TYPE_ns__UpdateUser:
		return soap_out_ns__UpdateUser(soap, tag, id, (const struct ns__UpdateUser *)ptr, "ns:UpdateUser");
	case SOAP_TYPE_ns__AddUser:
		return soap_out_ns__AddUser(soap, tag, id, (const struct ns__AddUser *)ptr, "ns:AddUser");
	case SOAP_TYPE_ns__GetUsersList:
		return soap_out_ns__GetUsersList(soap, tag, id, (const struct ns__GetUsersList *)ptr, "ns:GetUsersList");
	case SOAP_TYPE_ns__GetUserDeviceList:
		return soap_out_ns__GetUserDeviceList(soap, tag, id, (const struct ns__GetUserDeviceList *)ptr, "ns:GetUserDeviceList");
	case SOAP_TYPE_ns__Login:
		return soap_out_ns__Login(soap, tag, id, (const struct ns__Login *)ptr, "ns:Login");
	case SOAP_TYPE_ns__GetDeviceCalibration:
		return soap_out_ns__GetDeviceCalibration(soap, tag, id, (const struct ns__GetDeviceCalibration *)ptr, "ns:GetDeviceCalibration");
	case SOAP_TYPE_ns__SetDeviceCalibration:
		return soap_out_ns__SetDeviceCalibration(soap, tag, id, (const struct ns__SetDeviceCalibration *)ptr, "ns:SetDeviceCalibration");
	case SOAP_TYPE_ns__DeleteDevices:
		return soap_out_ns__DeleteDevices(soap, tag, id, (const struct ns__DeleteDevices *)ptr, "ns:DeleteDevices");
	case SOAP_TYPE_ns__DeleteDevicesResponse:
		return soap_out_ns__DeleteDevicesResponse(soap, tag, id, (const struct ns__DeleteDevicesResponse *)ptr, "ns:DeleteDevicesResponse");
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		return soap_out_ns__SetAllDeviceSetting(soap, tag, id, (const struct ns__SetAllDeviceSetting *)ptr, "ns:SetAllDeviceSetting");
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		return soap_out_ns__SetAllDeviceSettingResponse(soap, tag, id, (const struct ns__SetAllDeviceSettingResponse *)ptr, "ns:SetAllDeviceSettingResponse");
	case SOAP_TYPE_ns__SetDeviceSettingSMS:
		return soap_out_ns__SetDeviceSettingSMS(soap, tag, id, (const struct ns__SetDeviceSettingSMS *)ptr, "ns:SetDeviceSettingSMS");
	case SOAP_TYPE_ns__SetDeviceSetting:
		return soap_out_ns__SetDeviceSetting(soap, tag, id, (const struct ns__SetDeviceSetting *)ptr, "ns:SetDeviceSetting");
	case SOAP_TYPE_ns__SetDeviceSettingResponse:
		return soap_out_ns__SetDeviceSettingResponse(soap, tag, id, (const struct ns__SetDeviceSettingResponse *)ptr, "ns:SetDeviceSettingResponse");
	case SOAP_TYPE_ns__GetDevicePicturePart:
		return soap_out_ns__GetDevicePicturePart(soap, tag, id, (const struct ns__GetDevicePicturePart *)ptr, "ns:GetDevicePicturePart");
	case SOAP_TYPE_ns__GetDevicePicture:
		return soap_out_ns__GetDevicePicture(soap, tag, id, (const struct ns__GetDevicePicture *)ptr, "ns:GetDevicePicture");
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		return soap_out_ns__GetAllDeviceStatus(soap, tag, id, (const struct ns__GetAllDeviceStatus *)ptr, "ns:GetAllDeviceStatus");
	case SOAP_TYPE_ns__GetDeviceStatusSMS:
		return soap_out_ns__GetDeviceStatusSMS(soap, tag, id, (const struct ns__GetDeviceStatusSMS *)ptr, "ns:GetDeviceStatusSMS");
	case SOAP_TYPE_ns__GetDeviceStatus:
		return soap_out_ns__GetDeviceStatus(soap, tag, id, (const struct ns__GetDeviceStatus *)ptr, "ns:GetDeviceStatus");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in E:\Projects\WebService\GeneratedCode\Sectionner\source\WebService\Server\soapC.cpp\n", tag ? tag : "", type));
	return soap->error = SOAP_TYPE; /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns__AllCityLocatoins:
		((ns__AllCityLocatoins *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__CityLocation:
		((ns__CityLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ServerOptions:
		((ns__ServerOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DataBase:
		((ns__DataBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__UserDevice:
		((ns__UserDevice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ErrorLog:
		((ns__ErrorLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DeviceStatus:
		((ns__DeviceStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DeviceStatusLogList:
		((ns__DeviceStatusLogList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__DeviceStatusLog:
		((ns__DeviceStatusLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__UserLog:
		((ns__UserLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ActivityLog:
		((ns__ActivityLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ReportRange:
		((ns__ReportRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Device:
		((ns__Device *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Picture:
		((ns__Picture *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__PicturePart:
		((ns__PicturePart *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Camera:
		((ns__Camera *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__SensorExtension:
		((ns__SensorExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Sensor:
		((ns__Sensor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__CalibrationList:
		((ns__CalibrationList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__Calibration:
		((ns__Calibration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__GPS:
		((ns__GPS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__IP:
		((ns__IP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__UsersList:
		((ns__UsersList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__User:
		((ns__User *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns__ErrorCode:
		((ns__ErrorCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__string:
		soap_serialize_xsd__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns__ChangeDeviceName:
		soap_serialize_ns__ChangeDeviceName(soap, (const struct ns__ChangeDeviceName *)ptr);
		break;
	case SOAP_TYPE_ns__ChangeLocationName:
		soap_serialize_ns__ChangeLocationName(soap, (const struct ns__ChangeLocationName *)ptr);
		break;
	case SOAP_TYPE_ns__ChangeCityName:
		soap_serialize_ns__ChangeCityName(soap, (const struct ns__ChangeCityName *)ptr);
		break;
	case SOAP_TYPE_ns__GetCityAndLocations:
		soap_serialize_ns__GetCityAndLocations(soap, (const struct ns__GetCityAndLocations *)ptr);
		break;
	case SOAP_TYPE_ns__SetServerOptions:
		soap_serialize_ns__SetServerOptions(soap, (const struct ns__SetServerOptions *)ptr);
		break;
	case SOAP_TYPE_ns__GetServerOptions:
		soap_serialize_ns__GetServerOptions(soap, (const struct ns__GetServerOptions *)ptr);
		break;
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		soap_serialize_ns__GetDeviceStatusLog(soap, (const struct ns__GetDeviceStatusLog *)ptr);
		break;
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		soap_serialize_ns__SaveDeviceStatusLog(soap, (const struct ns__SaveDeviceStatusLog *)ptr);
		break;
	case SOAP_TYPE_ns__GetUserLog:
		soap_serialize_ns__GetUserLog(soap, (const struct ns__GetUserLog *)ptr);
		break;
	case SOAP_TYPE_ns__GetUserLogResponse:
		soap_serialize_ns__GetUserLogResponse(soap, (const struct ns__GetUserLogResponse *)ptr);
		break;
	case SOAP_TYPE_ns__SaveUserLog:
		soap_serialize_ns__SaveUserLog(soap, (const struct ns__SaveUserLog *)ptr);
		break;
	case SOAP_TYPE_ns__GetActivityLog:
		soap_serialize_ns__GetActivityLog(soap, (const struct ns__GetActivityLog *)ptr);
		break;
	case SOAP_TYPE_ns__GetActivityLogResponse:
		soap_serialize_ns__GetActivityLogResponse(soap, (const struct ns__GetActivityLogResponse *)ptr);
		break;
	case SOAP_TYPE_ns__SaveActivityLog:
		soap_serialize_ns__SaveActivityLog(soap, (const struct ns__SaveActivityLog *)ptr);
		break;
	case SOAP_TYPE_ns__GetUserDevices:
		soap_serialize_ns__GetUserDevices(soap, (const struct ns__GetUserDevices *)ptr);
		break;
	case SOAP_TYPE_ns__DeleteDeviceFromUser:
		soap_serialize_ns__DeleteDeviceFromUser(soap, (const struct ns__DeleteDeviceFromUser *)ptr);
		break;
	case SOAP_TYPE_ns__AssignDeviceToUser:
		soap_serialize_ns__AssignDeviceToUser(soap, (const struct ns__AssignDeviceToUser *)ptr);
		break;
	case SOAP_TYPE_ns__DeleteUser:
		soap_serialize_ns__DeleteUser(soap, (const struct ns__DeleteUser *)ptr);
		break;
	case SOAP_TYPE_ns__UpdateUser:
		soap_serialize_ns__UpdateUser(soap, (const struct ns__UpdateUser *)ptr);
		break;
	case SOAP_TYPE_ns__AddUser:
		soap_serialize_ns__AddUser(soap, (const struct ns__AddUser *)ptr);
		break;
	case SOAP_TYPE_ns__GetUsersList:
		soap_serialize_ns__GetUsersList(soap, (const struct ns__GetUsersList *)ptr);
		break;
	case SOAP_TYPE_ns__GetUserDeviceList:
		soap_serialize_ns__GetUserDeviceList(soap, (const struct ns__GetUserDeviceList *)ptr);
		break;
	case SOAP_TYPE_ns__Login:
		soap_serialize_ns__Login(soap, (const struct ns__Login *)ptr);
		break;
	case SOAP_TYPE_ns__GetDeviceCalibration:
		soap_serialize_ns__GetDeviceCalibration(soap, (const struct ns__GetDeviceCalibration *)ptr);
		break;
	case SOAP_TYPE_ns__SetDeviceCalibration:
		soap_serialize_ns__SetDeviceCalibration(soap, (const struct ns__SetDeviceCalibration *)ptr);
		break;
	case SOAP_TYPE_ns__DeleteDevices:
		soap_serialize_ns__DeleteDevices(soap, (const struct ns__DeleteDevices *)ptr);
		break;
	case SOAP_TYPE_ns__DeleteDevicesResponse:
		soap_serialize_ns__DeleteDevicesResponse(soap, (const struct ns__DeleteDevicesResponse *)ptr);
		break;
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		soap_serialize_ns__SetAllDeviceSetting(soap, (const struct ns__SetAllDeviceSetting *)ptr);
		break;
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		soap_serialize_ns__SetAllDeviceSettingResponse(soap, (const struct ns__SetAllDeviceSettingResponse *)ptr);
		break;
	case SOAP_TYPE_ns__SetDeviceSettingSMS:
		soap_serialize_ns__SetDeviceSettingSMS(soap, (const struct ns__SetDeviceSettingSMS *)ptr);
		break;
	case SOAP_TYPE_ns__SetDeviceSetting:
		soap_serialize_ns__SetDeviceSetting(soap, (const struct ns__SetDeviceSetting *)ptr);
		break;
	case SOAP_TYPE_ns__SetDeviceSettingResponse:
		soap_serialize_ns__SetDeviceSettingResponse(soap, (const struct ns__SetDeviceSettingResponse *)ptr);
		break;
	case SOAP_TYPE_ns__GetDevicePicturePart:
		soap_serialize_ns__GetDevicePicturePart(soap, (const struct ns__GetDevicePicturePart *)ptr);
		break;
	case SOAP_TYPE_ns__GetDevicePicture:
		soap_serialize_ns__GetDevicePicture(soap, (const struct ns__GetDevicePicture *)ptr);
		break;
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		soap_serialize_ns__GetAllDeviceStatus(soap, (const struct ns__GetAllDeviceStatus *)ptr);
		break;
	case SOAP_TYPE_ns__GetDeviceStatusSMS:
		soap_serialize_ns__GetDeviceStatusSMS(soap, (const struct ns__GetDeviceStatusSMS *)ptr);
		break;
	case SOAP_TYPE_ns__GetDeviceStatus:
		soap_serialize_ns__GetDeviceStatus(soap, (const struct ns__GetDeviceStatus *)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ErrorCode:
		return (void*)soap_instantiate_ns__ErrorCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__User:
		return (void*)soap_instantiate_ns__User(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__UsersList:
		return (void*)soap_instantiate_ns__UsersList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__IP:
		return (void*)soap_instantiate_ns__IP(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GPS:
		return (void*)soap_instantiate_ns__GPS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Calibration:
		return (void*)soap_instantiate_ns__Calibration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__CalibrationList:
		return (void*)soap_instantiate_ns__CalibrationList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Sensor:
		return (void*)soap_instantiate_ns__Sensor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SensorExtension:
		return (void*)soap_instantiate_ns__SensorExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Camera:
		return (void*)soap_instantiate_ns__Camera(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__PicturePart:
		return (void*)soap_instantiate_ns__PicturePart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Picture:
		return (void*)soap_instantiate_ns__Picture(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Device:
		return (void*)soap_instantiate_ns__Device(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ReportRange:
		return (void*)soap_instantiate_ns__ReportRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ActivityLog:
		return (void*)soap_instantiate_ns__ActivityLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__UserLog:
		return (void*)soap_instantiate_ns__UserLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeviceStatusLog:
		return (void*)soap_instantiate_ns__DeviceStatusLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeviceStatusLogList:
		return (void*)soap_instantiate_ns__DeviceStatusLogList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeviceStatus:
		return (void*)soap_instantiate_ns__DeviceStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ErrorLog:
		return (void*)soap_instantiate_ns__ErrorLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__UserDevice:
		return (void*)soap_instantiate_ns__UserDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DataBase:
		return (void*)soap_instantiate_ns__DataBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ServerOptions:
		return (void*)soap_instantiate_ns__ServerOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__CityLocation:
		return (void*)soap_instantiate_ns__CityLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AllCityLocatoins:
		return (void*)soap_instantiate_ns__AllCityLocatoins(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetDeviceStatus:
		return (void*)soap_instantiate_ns__GetDeviceStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetDeviceStatusSMS:
		return (void*)soap_instantiate_ns__GetDeviceStatusSMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		return (void*)soap_instantiate_ns__GetAllDeviceStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetDevicePicture:
		return (void*)soap_instantiate_ns__GetDevicePicture(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetDevicePicturePart:
		return (void*)soap_instantiate_ns__GetDevicePicturePart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetDeviceSettingResponse:
		return (void*)soap_instantiate_ns__SetDeviceSettingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetDeviceSetting:
		return (void*)soap_instantiate_ns__SetDeviceSetting(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetDeviceSettingSMS:
		return (void*)soap_instantiate_ns__SetDeviceSettingSMS(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		return (void*)soap_instantiate_ns__SetAllDeviceSettingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		return (void*)soap_instantiate_ns__SetAllDeviceSetting(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeleteDevicesResponse:
		return (void*)soap_instantiate_ns__DeleteDevicesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeleteDevices:
		return (void*)soap_instantiate_ns__DeleteDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetDeviceCalibration:
		return (void*)soap_instantiate_ns__SetDeviceCalibration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetDeviceCalibration:
		return (void*)soap_instantiate_ns__GetDeviceCalibration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Login:
		return (void*)soap_instantiate_ns__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetUserDeviceList:
		return (void*)soap_instantiate_ns__GetUserDeviceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetUsersList:
		return (void*)soap_instantiate_ns__GetUsersList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AddUser:
		return (void*)soap_instantiate_ns__AddUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__UpdateUser:
		return (void*)soap_instantiate_ns__UpdateUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeleteUser:
		return (void*)soap_instantiate_ns__DeleteUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__AssignDeviceToUser:
		return (void*)soap_instantiate_ns__AssignDeviceToUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__DeleteDeviceFromUser:
		return (void*)soap_instantiate_ns__DeleteDeviceFromUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetUserDevices:
		return (void*)soap_instantiate_ns__GetUserDevices(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SaveActivityLog:
		return (void*)soap_instantiate_ns__SaveActivityLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetActivityLogResponse:
		return (void*)soap_instantiate_ns__GetActivityLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetActivityLog:
		return (void*)soap_instantiate_ns__GetActivityLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SaveUserLog:
		return (void*)soap_instantiate_ns__SaveUserLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetUserLogResponse:
		return (void*)soap_instantiate_ns__GetUserLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetUserLog:
		return (void*)soap_instantiate_ns__GetUserLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		return (void*)soap_instantiate_ns__SaveDeviceStatusLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		return (void*)soap_instantiate_ns__GetDeviceStatusLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetServerOptions:
		return (void*)soap_instantiate_ns__GetServerOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SetServerOptions:
		return (void*)soap_instantiate_ns__SetServerOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__GetCityAndLocations:
		return (void*)soap_instantiate_ns__GetCityAndLocations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ChangeCityName:
		return (void*)soap_instantiate_ns__ChangeCityName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ChangeLocationName:
		return (void*)soap_instantiate_ns__ChangeLocationName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__ChangeDeviceName:
		return (void*)soap_instantiate_ns__ChangeDeviceName(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__UserLog:
		return (void*)soap_instantiate_std__vectorTemplateOfns__UserLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__ActivityLog:
		return (void*)soap_instantiate_std__vectorTemplateOfns__ActivityLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__ErrorCode:
		return (void*)soap_instantiate_std__vectorTemplateOfns__ErrorCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__CityLocation:
		return (void*)soap_instantiate_std__vectorTemplateOfns__CityLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__Device:
		return (void*)soap_instantiate_std__vectorTemplateOfns__Device(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog:
		return (void*)soap_instantiate_std__vectorTemplateOfns__DeviceStatusLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__SensorExtension:
		return (void*)soap_instantiate_std__vectorTemplateOfns__SensorExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__RequestType:
		return (void*)soap_instantiate_std__vectorTemplateOfns__RequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__boolean:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__PicturePart:
		return (void*)soap_instantiate_std__vectorTemplateOfns__PicturePart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__double:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__double(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__Calibration:
		return (void*)soap_instantiate_std__vectorTemplateOfns__Calibration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns__User:
		return (void*)soap_instantiate_std__vectorTemplateOfns__User(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ErrorCode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__ErrorCode*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__ErrorCode*>(p->ptr));
		break;
	case SOAP_TYPE_ns__User:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__User*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__User*>(p->ptr));
		break;
	case SOAP_TYPE_ns__UsersList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__UsersList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__UsersList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__IP:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__IP*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__IP*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GPS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__GPS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__GPS*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Calibration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Calibration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Calibration*>(p->ptr));
		break;
	case SOAP_TYPE_ns__CalibrationList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__CalibrationList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__CalibrationList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Sensor:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Sensor*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Sensor*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SensorExtension:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__SensorExtension*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__SensorExtension*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Camera:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Camera*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Camera*>(p->ptr));
		break;
	case SOAP_TYPE_ns__PicturePart:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__PicturePart*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__PicturePart*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Picture:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Picture*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Picture*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Device:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__Device*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__Device*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ReportRange:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__ReportRange*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__ReportRange*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ActivityLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__ActivityLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__ActivityLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__UserLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__UserLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__UserLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeviceStatusLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__DeviceStatusLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__DeviceStatusLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeviceStatusLogList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__DeviceStatusLogList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__DeviceStatusLogList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeviceStatus:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__DeviceStatus*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__DeviceStatus*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ErrorLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__ErrorLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__ErrorLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__UserDevice:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__UserDevice*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__UserDevice*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DataBase:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__DataBase*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__DataBase*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ServerOptions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__ServerOptions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__ServerOptions*>(p->ptr));
		break;
	case SOAP_TYPE_ns__CityLocation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__CityLocation*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__CityLocation*>(p->ptr));
		break;
	case SOAP_TYPE_ns__AllCityLocatoins:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns__AllCityLocatoins*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns__AllCityLocatoins*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetDeviceStatus:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetDeviceStatus*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetDeviceStatus*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetDeviceStatusSMS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetDeviceStatusSMS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetDeviceStatusSMS*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetAllDeviceStatus*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetAllDeviceStatus*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetDevicePicture:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetDevicePicture*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetDevicePicture*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetDevicePicturePart:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetDevicePicturePart*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetDevicePicturePart*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SetDeviceSettingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SetDeviceSettingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SetDeviceSettingResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SetDeviceSetting:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SetDeviceSetting*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SetDeviceSetting*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SetDeviceSettingSMS:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SetDeviceSettingSMS*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SetDeviceSettingSMS*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SetAllDeviceSettingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SetAllDeviceSettingResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SetAllDeviceSetting*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SetAllDeviceSetting*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeleteDevicesResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__DeleteDevicesResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__DeleteDevicesResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeleteDevices:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__DeleteDevices*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__DeleteDevices*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SetDeviceCalibration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SetDeviceCalibration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SetDeviceCalibration*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetDeviceCalibration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetDeviceCalibration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetDeviceCalibration*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__Login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__Login*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetUserDeviceList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetUserDeviceList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetUserDeviceList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetUsersList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetUsersList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetUsersList*>(p->ptr));
		break;
	case SOAP_TYPE_ns__AddUser:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__AddUser*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__AddUser*>(p->ptr));
		break;
	case SOAP_TYPE_ns__UpdateUser:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__UpdateUser*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__UpdateUser*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeleteUser:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__DeleteUser*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__DeleteUser*>(p->ptr));
		break;
	case SOAP_TYPE_ns__AssignDeviceToUser:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__AssignDeviceToUser*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__AssignDeviceToUser*>(p->ptr));
		break;
	case SOAP_TYPE_ns__DeleteDeviceFromUser:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__DeleteDeviceFromUser*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__DeleteDeviceFromUser*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetUserDevices:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetUserDevices*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetUserDevices*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SaveActivityLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SaveActivityLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SaveActivityLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetActivityLogResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetActivityLogResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetActivityLogResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetActivityLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetActivityLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetActivityLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SaveUserLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SaveUserLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SaveUserLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetUserLogResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetUserLogResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetUserLogResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetUserLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetUserLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetUserLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SaveDeviceStatusLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SaveDeviceStatusLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetDeviceStatusLog*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetDeviceStatusLog*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetServerOptions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetServerOptions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetServerOptions*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SetServerOptions:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SetServerOptions*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SetServerOptions*>(p->ptr));
		break;
	case SOAP_TYPE_ns__GetCityAndLocations:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__GetCityAndLocations*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__GetCityAndLocations*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ChangeCityName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__ChangeCityName*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__ChangeCityName*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ChangeLocationName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__ChangeLocationName*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__ChangeLocationName*>(p->ptr));
		break;
	case SOAP_TYPE_ns__ChangeDeviceName:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__ChangeDeviceName*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__ChangeDeviceName*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__UserLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__UserLog> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__UserLog> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__ActivityLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__ActivityLog> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__ActivityLog> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__ErrorCode:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__ErrorCode> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__ErrorCode> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__CityLocation:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__CityLocation> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__CityLocation> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<std::string> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<std::string> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<std::string> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<std::string> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__Device:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__Device> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__Device> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__DeviceStatusLog> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__DeviceStatusLog> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__SensorExtension:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__SensorExtension> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__SensorExtension> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__RequestType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<enum ns__RequestType> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<enum ns__RequestType> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__boolean:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<bool> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<bool> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__PicturePart:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__PicturePart> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__PicturePart> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__double:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<double> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<double> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__Calibration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__Calibration> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__Calibration> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__User:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns__User> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns__User> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfns__UserLog:
		if (t == SOAP_TYPE_ns__UserLog)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__UserLog>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__UserLog> *)p)[index] = *(ns__UserLog *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__ActivityLog:
		if (t == SOAP_TYPE_ns__ActivityLog)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__ActivityLog>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__ActivityLog> *)p)[index] = *(ns__ActivityLog *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__ErrorCode:
		if (t == SOAP_TYPE_ns__ErrorCode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__ErrorCode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__ErrorCode> *)p)[index] = *(ns__ErrorCode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__CityLocation:
		if (t == SOAP_TYPE_ns__CityLocation)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__CityLocation>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__CityLocation> *)p)[index] = *(ns__CityLocation *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__string:
		if (t == SOAP_TYPE_xsd__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (t == SOAP_TYPE_std__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__Device:
		if (t == SOAP_TYPE_ns__Device)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__Device>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__Device> *)p)[index] = *(ns__Device *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog:
		if (t == SOAP_TYPE_ns__DeviceStatusLog)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__DeviceStatusLog>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__DeviceStatusLog> *)p)[index] = *(ns__DeviceStatusLog *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__SensorExtension:
		if (t == SOAP_TYPE_ns__SensorExtension)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__SensorExtension>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__SensorExtension> *)p)[index] = *(ns__SensorExtension *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__RequestType:
		if (t == SOAP_TYPE_ns__RequestType)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum ns__RequestType>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum ns__RequestType> *)p)[index] = *(enum ns__RequestType *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__boolean:
		if (t == SOAP_TYPE_xsd__boolean)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<bool>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<bool> *)p)[index] = *(bool *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__PicturePart:
		if (t == SOAP_TYPE_ns__PicturePart)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__PicturePart>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__PicturePart> *)p)[index] = *(ns__PicturePart *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__double:
		if (t == SOAP_TYPE_xsd__double)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<double>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<double> *)p)[index] = *(double *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__Calibration:
		if (t == SOAP_TYPE_ns__Calibration)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__Calibration>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__Calibration> *)p)[index] = *(ns__Calibration *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfns__User:
		if (t == SOAP_TYPE_ns__User)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns__User>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns__User> *)p)[index] = *(ns__User *)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns__ErrorCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__ErrorCode type=%d location=%p object=%p\n", t, p, q));
		*(ns__ErrorCode*)p = *(ns__ErrorCode*)q;
		break;
	case SOAP_TYPE_ns__User:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__User type=%d location=%p object=%p\n", t, p, q));
		*(ns__User*)p = *(ns__User*)q;
		break;
	case SOAP_TYPE_ns__UsersList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__UsersList type=%d location=%p object=%p\n", t, p, q));
		*(ns__UsersList*)p = *(ns__UsersList*)q;
		break;
	case SOAP_TYPE_ns__IP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__IP type=%d location=%p object=%p\n", t, p, q));
		*(ns__IP*)p = *(ns__IP*)q;
		break;
	case SOAP_TYPE_ns__GPS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__GPS type=%d location=%p object=%p\n", t, p, q));
		*(ns__GPS*)p = *(ns__GPS*)q;
		break;
	case SOAP_TYPE_ns__Calibration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Calibration type=%d location=%p object=%p\n", t, p, q));
		*(ns__Calibration*)p = *(ns__Calibration*)q;
		break;
	case SOAP_TYPE_ns__CalibrationList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__CalibrationList type=%d location=%p object=%p\n", t, p, q));
		*(ns__CalibrationList*)p = *(ns__CalibrationList*)q;
		break;
	case SOAP_TYPE_ns__Sensor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Sensor type=%d location=%p object=%p\n", t, p, q));
		*(ns__Sensor*)p = *(ns__Sensor*)q;
		break;
	case SOAP_TYPE_ns__SensorExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__SensorExtension type=%d location=%p object=%p\n", t, p, q));
		*(ns__SensorExtension*)p = *(ns__SensorExtension*)q;
		break;
	case SOAP_TYPE_ns__Camera:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Camera type=%d location=%p object=%p\n", t, p, q));
		*(ns__Camera*)p = *(ns__Camera*)q;
		break;
	case SOAP_TYPE_ns__PicturePart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__PicturePart type=%d location=%p object=%p\n", t, p, q));
		*(ns__PicturePart*)p = *(ns__PicturePart*)q;
		break;
	case SOAP_TYPE_ns__Picture:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Picture type=%d location=%p object=%p\n", t, p, q));
		*(ns__Picture*)p = *(ns__Picture*)q;
		break;
	case SOAP_TYPE_ns__Device:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__Device type=%d location=%p object=%p\n", t, p, q));
		*(ns__Device*)p = *(ns__Device*)q;
		break;
	case SOAP_TYPE_ns__ReportRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__ReportRange type=%d location=%p object=%p\n", t, p, q));
		*(ns__ReportRange*)p = *(ns__ReportRange*)q;
		break;
	case SOAP_TYPE_ns__ActivityLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__ActivityLog type=%d location=%p object=%p\n", t, p, q));
		*(ns__ActivityLog*)p = *(ns__ActivityLog*)q;
		break;
	case SOAP_TYPE_ns__UserLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__UserLog type=%d location=%p object=%p\n", t, p, q));
		*(ns__UserLog*)p = *(ns__UserLog*)q;
		break;
	case SOAP_TYPE_ns__DeviceStatusLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__DeviceStatusLog type=%d location=%p object=%p\n", t, p, q));
		*(ns__DeviceStatusLog*)p = *(ns__DeviceStatusLog*)q;
		break;
	case SOAP_TYPE_ns__DeviceStatusLogList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__DeviceStatusLogList type=%d location=%p object=%p\n", t, p, q));
		*(ns__DeviceStatusLogList*)p = *(ns__DeviceStatusLogList*)q;
		break;
	case SOAP_TYPE_ns__DeviceStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__DeviceStatus type=%d location=%p object=%p\n", t, p, q));
		*(ns__DeviceStatus*)p = *(ns__DeviceStatus*)q;
		break;
	case SOAP_TYPE_ns__ErrorLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__ErrorLog type=%d location=%p object=%p\n", t, p, q));
		*(ns__ErrorLog*)p = *(ns__ErrorLog*)q;
		break;
	case SOAP_TYPE_ns__UserDevice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__UserDevice type=%d location=%p object=%p\n", t, p, q));
		*(ns__UserDevice*)p = *(ns__UserDevice*)q;
		break;
	case SOAP_TYPE_ns__DataBase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__DataBase type=%d location=%p object=%p\n", t, p, q));
		*(ns__DataBase*)p = *(ns__DataBase*)q;
		break;
	case SOAP_TYPE_ns__ServerOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__ServerOptions type=%d location=%p object=%p\n", t, p, q));
		*(ns__ServerOptions*)p = *(ns__ServerOptions*)q;
		break;
	case SOAP_TYPE_ns__CityLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__CityLocation type=%d location=%p object=%p\n", t, p, q));
		*(ns__CityLocation*)p = *(ns__CityLocation*)q;
		break;
	case SOAP_TYPE_ns__AllCityLocatoins:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns__AllCityLocatoins type=%d location=%p object=%p\n", t, p, q));
		*(ns__AllCityLocatoins*)p = *(ns__AllCityLocatoins*)q;
		break;
	case SOAP_TYPE_ns__GetDeviceStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetDeviceStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetDeviceStatus*)p = *(struct ns__GetDeviceStatus*)q;
		break;
	case SOAP_TYPE_ns__GetDeviceStatusSMS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetDeviceStatusSMS type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetDeviceStatusSMS*)p = *(struct ns__GetDeviceStatusSMS*)q;
		break;
	case SOAP_TYPE_ns__GetAllDeviceStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetAllDeviceStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetAllDeviceStatus*)p = *(struct ns__GetAllDeviceStatus*)q;
		break;
	case SOAP_TYPE_ns__GetDevicePicture:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetDevicePicture type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetDevicePicture*)p = *(struct ns__GetDevicePicture*)q;
		break;
	case SOAP_TYPE_ns__GetDevicePicturePart:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetDevicePicturePart type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetDevicePicturePart*)p = *(struct ns__GetDevicePicturePart*)q;
		break;
	case SOAP_TYPE_ns__SetDeviceSettingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SetDeviceSettingResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SetDeviceSettingResponse*)p = *(struct ns__SetDeviceSettingResponse*)q;
		break;
	case SOAP_TYPE_ns__SetDeviceSetting:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SetDeviceSetting type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SetDeviceSetting*)p = *(struct ns__SetDeviceSetting*)q;
		break;
	case SOAP_TYPE_ns__SetDeviceSettingSMS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SetDeviceSettingSMS type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SetDeviceSettingSMS*)p = *(struct ns__SetDeviceSettingSMS*)q;
		break;
	case SOAP_TYPE_ns__SetAllDeviceSettingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SetAllDeviceSettingResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SetAllDeviceSettingResponse*)p = *(struct ns__SetAllDeviceSettingResponse*)q;
		break;
	case SOAP_TYPE_ns__SetAllDeviceSetting:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SetAllDeviceSetting type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SetAllDeviceSetting*)p = *(struct ns__SetAllDeviceSetting*)q;
		break;
	case SOAP_TYPE_ns__DeleteDevicesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__DeleteDevicesResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__DeleteDevicesResponse*)p = *(struct ns__DeleteDevicesResponse*)q;
		break;
	case SOAP_TYPE_ns__DeleteDevices:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__DeleteDevices type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__DeleteDevices*)p = *(struct ns__DeleteDevices*)q;
		break;
	case SOAP_TYPE_ns__SetDeviceCalibration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SetDeviceCalibration type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SetDeviceCalibration*)p = *(struct ns__SetDeviceCalibration*)q;
		break;
	case SOAP_TYPE_ns__GetDeviceCalibration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetDeviceCalibration type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetDeviceCalibration*)p = *(struct ns__GetDeviceCalibration*)q;
		break;
	case SOAP_TYPE_ns__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__Login type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__Login*)p = *(struct ns__Login*)q;
		break;
	case SOAP_TYPE_ns__GetUserDeviceList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetUserDeviceList type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetUserDeviceList*)p = *(struct ns__GetUserDeviceList*)q;
		break;
	case SOAP_TYPE_ns__GetUsersList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetUsersList type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetUsersList*)p = *(struct ns__GetUsersList*)q;
		break;
	case SOAP_TYPE_ns__AddUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__AddUser type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__AddUser*)p = *(struct ns__AddUser*)q;
		break;
	case SOAP_TYPE_ns__UpdateUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__UpdateUser type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__UpdateUser*)p = *(struct ns__UpdateUser*)q;
		break;
	case SOAP_TYPE_ns__DeleteUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__DeleteUser type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__DeleteUser*)p = *(struct ns__DeleteUser*)q;
		break;
	case SOAP_TYPE_ns__AssignDeviceToUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__AssignDeviceToUser type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__AssignDeviceToUser*)p = *(struct ns__AssignDeviceToUser*)q;
		break;
	case SOAP_TYPE_ns__DeleteDeviceFromUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__DeleteDeviceFromUser type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__DeleteDeviceFromUser*)p = *(struct ns__DeleteDeviceFromUser*)q;
		break;
	case SOAP_TYPE_ns__GetUserDevices:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetUserDevices type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetUserDevices*)p = *(struct ns__GetUserDevices*)q;
		break;
	case SOAP_TYPE_ns__SaveActivityLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SaveActivityLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SaveActivityLog*)p = *(struct ns__SaveActivityLog*)q;
		break;
	case SOAP_TYPE_ns__GetActivityLogResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetActivityLogResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetActivityLogResponse*)p = *(struct ns__GetActivityLogResponse*)q;
		break;
	case SOAP_TYPE_ns__GetActivityLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetActivityLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetActivityLog*)p = *(struct ns__GetActivityLog*)q;
		break;
	case SOAP_TYPE_ns__SaveUserLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SaveUserLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SaveUserLog*)p = *(struct ns__SaveUserLog*)q;
		break;
	case SOAP_TYPE_ns__GetUserLogResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetUserLogResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetUserLogResponse*)p = *(struct ns__GetUserLogResponse*)q;
		break;
	case SOAP_TYPE_ns__GetUserLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetUserLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetUserLog*)p = *(struct ns__GetUserLog*)q;
		break;
	case SOAP_TYPE_ns__SaveDeviceStatusLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SaveDeviceStatusLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SaveDeviceStatusLog*)p = *(struct ns__SaveDeviceStatusLog*)q;
		break;
	case SOAP_TYPE_ns__GetDeviceStatusLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetDeviceStatusLog type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetDeviceStatusLog*)p = *(struct ns__GetDeviceStatusLog*)q;
		break;
	case SOAP_TYPE_ns__GetServerOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetServerOptions type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetServerOptions*)p = *(struct ns__GetServerOptions*)q;
		break;
	case SOAP_TYPE_ns__SetServerOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SetServerOptions type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SetServerOptions*)p = *(struct ns__SetServerOptions*)q;
		break;
	case SOAP_TYPE_ns__GetCityAndLocations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__GetCityAndLocations type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__GetCityAndLocations*)p = *(struct ns__GetCityAndLocations*)q;
		break;
	case SOAP_TYPE_ns__ChangeCityName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__ChangeCityName type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__ChangeCityName*)p = *(struct ns__ChangeCityName*)q;
		break;
	case SOAP_TYPE_ns__ChangeLocationName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__ChangeLocationName type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__ChangeLocationName*)p = *(struct ns__ChangeLocationName*)q;
		break;
	case SOAP_TYPE_ns__ChangeDeviceName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__ChangeDeviceName type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__ChangeDeviceName*)p = *(struct ns__ChangeDeviceName*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_xsd__int);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_xsd__int(soap, tag ? tag : "xsd:int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{
	a = soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
	return a;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_new_long(struct soap *soap, int n)
{
	long *a = static_cast<long *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(long)));
	for (long *p = a; p && n--; ++p)
		soap_default_long(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	if (soap_out_long(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_xsd__long);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_xsd__long);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__long(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_xsd__long(soap, tag ? tag : "xsd:long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	a = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return a;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_new_LONG64(struct soap *soap, int n)
{
	LONG64 *a = static_cast<LONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(LONG64)));
	for (LONG64 *p = a; p && n--; ++p)
		soap_default_LONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	if (soap_out_LONG64(soap, tag ? tag : "long", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_xsd__double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_xsd__double);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_xsd__double(soap, tag ? tag : "xsd:double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_xsd__dateTime);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__dateTime(struct soap *soap, const char *s, time_t *a)
{
	int err = soap_s2dateTime(soap, s, a);
	if (!err)
	{
	}
	return err;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_xsd__dateTime);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_xsd__dateTime(soap, tag ? tag : "xsd:dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns__RequestType[] =
{	{ (LONG64)CALIBRATION, "CALIBRATION" },
	{ (LONG64)SAMPLING, "SAMPLING" },
	{ (LONG64)OUTRELAY, "OUTRELAY" },
	{ (LONG64)DATETIME, "DATETIME" },
	{ (LONG64)PICTURE, "PICTURE" },
	{ (LONG64)PARTS, "PARTS" },
	{ (LONG64)RESET, "RESET" },
	{ (LONG64)LIVE, "LIVE" },
	{ (LONG64)OK, "OK" },
	{ (LONG64)DATA, "DATA" },
	{ (LONG64)CUSTOM, "CUSTOM" },
	{ (LONG64)STT, "STT" },
	{ (LONG64)ALM, "ALM" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__RequestType2s(struct soap *soap, enum ns__RequestType n)
{	const char *s = soap_code_str(soap_codes_ns__RequestType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__RequestType(struct soap *soap, const char *tag, int id, const enum ns__RequestType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__RequestType), type) || soap_send(soap, soap_ns__RequestType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__RequestType(struct soap *soap, const char *s, enum ns__RequestType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__RequestType, s);
	if (map)
		*a = (enum ns__RequestType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 12)
			return soap->error = SOAP_TYPE;
		*a = (enum ns__RequestType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__RequestType * SOAP_FMAC4 soap_in_ns__RequestType(struct soap *soap, const char *tag, enum ns__RequestType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__RequestType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__RequestType, sizeof(enum ns__RequestType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns__RequestType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns__RequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__RequestType, SOAP_TYPE_ns__RequestType, sizeof(enum ns__RequestType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns__RequestType * SOAP_FMAC4 soap_new_ns__RequestType(struct soap *soap, int n)
{
	enum ns__RequestType *a = static_cast<enum ns__RequestType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns__RequestType)));
	for (enum ns__RequestType *p = a; p && n--; ++p)
		soap_default_ns__RequestType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__RequestType(struct soap *soap, const enum ns__RequestType *a, const char *tag, const char *type)
{
	if (soap_out_ns__RequestType(soap, tag ? tag : "ns:RequestType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__RequestType * SOAP_FMAC4 soap_get_ns__RequestType(struct soap *soap, enum ns__RequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__RequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns__DeviceModel[] =
{	{ (LONG64)PROTECTOR, "PROTECTOR" },
	{ (LONG64)SECTIONNER, "SECTIONNER" },
	{ (LONG64)TRANSISTOR, "TRANSISTOR" },
	{ (LONG64)SERVER, "SERVER" },
	{ (LONG64)MANAGER, "MANAGER" },
	{ (LONG64)ROBER, "ROBER" },
	{ (LONG64)ALARM, "ALARM" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__DeviceModel2s(struct soap *soap, enum ns__DeviceModel n)
{	const char *s = soap_code_str(soap_codes_ns__DeviceModel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceModel(struct soap *soap, const char *tag, int id, const enum ns__DeviceModel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeviceModel), type) || soap_send(soap, soap_ns__DeviceModel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__DeviceModel(struct soap *soap, const char *s, enum ns__DeviceModel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__DeviceModel, s);
	if (map)
		*a = (enum ns__DeviceModel)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum ns__DeviceModel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__DeviceModel * SOAP_FMAC4 soap_in_ns__DeviceModel(struct soap *soap, const char *tag, enum ns__DeviceModel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__DeviceModel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeviceModel, sizeof(enum ns__DeviceModel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns__DeviceModel(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns__DeviceModel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeviceModel, SOAP_TYPE_ns__DeviceModel, sizeof(enum ns__DeviceModel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns__DeviceModel * SOAP_FMAC4 soap_new_ns__DeviceModel(struct soap *soap, int n)
{
	enum ns__DeviceModel *a = static_cast<enum ns__DeviceModel *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns__DeviceModel)));
	for (enum ns__DeviceModel *p = a; p && n--; ++p)
		soap_default_ns__DeviceModel(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeviceModel(struct soap *soap, const enum ns__DeviceModel *a, const char *tag, const char *type)
{
	if (soap_out_ns__DeviceModel(soap, tag ? tag : "ns:DeviceModel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__DeviceModel * SOAP_FMAC4 soap_get_ns__DeviceModel(struct soap *soap, enum ns__DeviceModel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeviceModel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns__SensorName[] =
{	{ (LONG64)TEMPERATURE, "TEMPERATURE" },
	{ (LONG64)HUMIDITY, "HUMIDITY" },
	{ (LONG64)ACVOLTAGE, "ACVOLTAGE" },
	{ (LONG64)ACAMPERE, "ACAMPERE" },
	{ (LONG64)DCVOLTAGE, "DCVOLTAGE" },
	{ (LONG64)DCAMPERE, "DCAMPERE" },
	{ (LONG64)COSQ, "COSQ" },
	{ (LONG64)DIGITALINPUT, "DIGITALINPUT" },
	{ (LONG64)DIGITALOUTPUT, "DIGITALOUTPUT" },
	{ (LONG64)DIGITALEXIST, "DIGITALEXIST" },
	{ (LONG64)RELAY, "RELAY" },
	{ (LONG64)UNKNOWN, "UNKNOWN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SensorName2s(struct soap *soap, enum ns__SensorName n)
{	const char *s = soap_code_str(soap_codes_ns__SensorName, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SensorName(struct soap *soap, const char *tag, int id, const enum ns__SensorName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SensorName), type) || soap_send(soap, soap_ns__SensorName2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SensorName(struct soap *soap, const char *s, enum ns__SensorName *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__SensorName, s);
	if (map)
		*a = (enum ns__SensorName)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 11)
			return soap->error = SOAP_TYPE;
		*a = (enum ns__SensorName)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__SensorName * SOAP_FMAC4 soap_in_ns__SensorName(struct soap *soap, const char *tag, enum ns__SensorName *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__SensorName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SensorName, sizeof(enum ns__SensorName), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns__SensorName(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns__SensorName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SensorName, SOAP_TYPE_ns__SensorName, sizeof(enum ns__SensorName), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns__SensorName * SOAP_FMAC4 soap_new_ns__SensorName(struct soap *soap, int n)
{
	enum ns__SensorName *a = static_cast<enum ns__SensorName *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns__SensorName)));
	for (enum ns__SensorName *p = a; p && n--; ++p)
		soap_default_ns__SensorName(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SensorName(struct soap *soap, const enum ns__SensorName *a, const char *tag, const char *type)
{
	if (soap_out_ns__SensorName(soap, tag ? tag : "ns:SensorName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__SensorName * SOAP_FMAC4 soap_get_ns__SensorName(struct soap *soap, enum ns__SensorName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SensorName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns__SensorType[] =
{	{ (LONG64)Multi, "Multi" },
	{ (LONG64)Mono, "Mono" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SensorType2s(struct soap *soap, enum ns__SensorType n)
{	const char *s = soap_code_str(soap_codes_ns__SensorType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SensorType(struct soap *soap, const char *tag, int id, const enum ns__SensorType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SensorType), type) || soap_send(soap, soap_ns__SensorType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SensorType(struct soap *soap, const char *s, enum ns__SensorType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__SensorType, s);
	if (map)
		*a = (enum ns__SensorType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum ns__SensorType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__SensorType * SOAP_FMAC4 soap_in_ns__SensorType(struct soap *soap, const char *tag, enum ns__SensorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__SensorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SensorType, sizeof(enum ns__SensorType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns__SensorType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns__SensorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SensorType, SOAP_TYPE_ns__SensorType, sizeof(enum ns__SensorType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns__SensorType * SOAP_FMAC4 soap_new_ns__SensorType(struct soap *soap, int n)
{
	enum ns__SensorType *a = static_cast<enum ns__SensorType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns__SensorType)));
	for (enum ns__SensorType *p = a; p && n--; ++p)
		soap_default_ns__SensorType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SensorType(struct soap *soap, const enum ns__SensorType *a, const char *tag, const char *type)
{
	if (soap_out_ns__SensorType(soap, tag ? tag : "ns:SensorType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__SensorType * SOAP_FMAC4 soap_get_ns__SensorType(struct soap *soap, enum ns__SensorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SensorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns__UserType[] =
{	{ (LONG64)Admin, "Admin" },
	{ (LONG64)Control, "Control" },
	{ (LONG64)Monitor, "Monitor" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__UserType2s(struct soap *soap, enum ns__UserType n)
{	const char *s = soap_code_str(soap_codes_ns__UserType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserType(struct soap *soap, const char *tag, int id, const enum ns__UserType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UserType), type) || soap_send(soap, soap_ns__UserType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__UserType(struct soap *soap, const char *s, enum ns__UserType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__UserType, s);
	if (map)
		*a = (enum ns__UserType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum ns__UserType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__UserType * SOAP_FMAC4 soap_in_ns__UserType(struct soap *soap, const char *tag, enum ns__UserType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__UserType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UserType, sizeof(enum ns__UserType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns__UserType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns__UserType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UserType, SOAP_TYPE_ns__UserType, sizeof(enum ns__UserType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns__UserType * SOAP_FMAC4 soap_new_ns__UserType(struct soap *soap, int n)
{
	enum ns__UserType *a = static_cast<enum ns__UserType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns__UserType)));
	for (enum ns__UserType *p = a; p && n--; ++p)
		soap_default_ns__UserType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__UserType(struct soap *soap, const enum ns__UserType *a, const char *tag, const char *type)
{
	if (soap_out_ns__UserType(soap, tag ? tag : "ns:UserType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__UserType * SOAP_FMAC4 soap_get_ns__UserType(struct soap *soap, enum ns__UserType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UserType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns__SettingLevel[] =
{	{ (LONG64)Normal, "Normal" },
	{ (LONG64)Disable, "Disable" },
	{ (LONG64)Warning, "Warning" },
	{ (LONG64)Minor, "Minor" },
	{ (LONG64)Major, "Major" },
	{ (LONG64)Critical, "Critical" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns__SettingLevel2s(struct soap *soap, enum ns__SettingLevel n)
{	const char *s = soap_code_str(soap_codes_ns__SettingLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SettingLevel(struct soap *soap, const char *tag, int id, const enum ns__SettingLevel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SettingLevel), type) || soap_send(soap, soap_ns__SettingLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns__SettingLevel(struct soap *soap, const char *s, enum ns__SettingLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns__SettingLevel, s);
	if (map)
		*a = (enum ns__SettingLevel)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum ns__SettingLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns__SettingLevel * SOAP_FMAC4 soap_in_ns__SettingLevel(struct soap *soap, const char *tag, enum ns__SettingLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns__SettingLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SettingLevel, sizeof(enum ns__SettingLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2ns__SettingLevel(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum ns__SettingLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SettingLevel, SOAP_TYPE_ns__SettingLevel, sizeof(enum ns__SettingLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns__SettingLevel * SOAP_FMAC4 soap_new_ns__SettingLevel(struct soap *soap, int n)
{
	enum ns__SettingLevel *a = static_cast<enum ns__SettingLevel *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns__SettingLevel)));
	for (enum ns__SettingLevel *p = a; p && n--; ++p)
		soap_default_ns__SettingLevel(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SettingLevel(struct soap *soap, const enum ns__SettingLevel *a, const char *tag, const char *type)
{
	if (soap_out_ns__SettingLevel(soap, tag ? tag : "ns:SettingLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns__SettingLevel * SOAP_FMAC4 soap_get_ns__SettingLevel(struct soap *soap, enum ns__SettingLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SettingLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type) || soap_send(soap, soap_xsd__boolean2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2xsd__boolean(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__boolean, SOAP_TYPE_xsd__boolean, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__boolean(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_xsd__boolean(soap, tag ? tag : "xsd:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__AllCityLocatoins::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__CityLocation(soap, &this->ns__AllCityLocatoins::aclCityLocatoins);
	this->ns__AllCityLocatoins::aclErr.ns__ErrorCode::soap_default(soap);
}

void ns__AllCityLocatoins::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__CityLocation(soap, &this->ns__AllCityLocatoins::aclCityLocatoins);
	this->ns__AllCityLocatoins::aclErr.soap_serialize(soap);
#endif
}

int ns__AllCityLocatoins::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__AllCityLocatoins(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AllCityLocatoins(struct soap *soap, const char *tag, int id, const ns__AllCityLocatoins *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AllCityLocatoins), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__CityLocation(soap, "aclCityLocatoins", -1, &a->ns__AllCityLocatoins::aclCityLocatoins, ""))
		return soap->error;
	if ((a->ns__AllCityLocatoins::aclErr).soap_out(soap, "aclErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__AllCityLocatoins::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__AllCityLocatoins(soap, tag, this, type);
}

SOAP_FMAC3 ns__AllCityLocatoins * SOAP_FMAC4 soap_in_ns__AllCityLocatoins(struct soap *soap, const char *tag, ns__AllCityLocatoins *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__AllCityLocatoins *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AllCityLocatoins, sizeof(ns__AllCityLocatoins), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__AllCityLocatoins)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__AllCityLocatoins *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_aclErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__CityLocation(soap, "aclCityLocatoins", &a->ns__AllCityLocatoins::aclCityLocatoins, "ns:CityLocation"))
					continue;
			}
			if (soap_flag_aclErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__AllCityLocatoins::aclErr).soap_in(soap, "aclErr", "ns:ErrorCode"))
				{	soap_flag_aclErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_aclErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__AllCityLocatoins *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AllCityLocatoins, SOAP_TYPE_ns__AllCityLocatoins, sizeof(ns__AllCityLocatoins), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__AllCityLocatoins * SOAP_FMAC2 soap_instantiate_ns__AllCityLocatoins(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AllCityLocatoins(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__AllCityLocatoins *p;
	size_t k = sizeof(ns__AllCityLocatoins);
	if (n < 0)
	{	p = SOAP_NEW(ns__AllCityLocatoins);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__AllCityLocatoins, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__AllCityLocatoins location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__AllCityLocatoins, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__AllCityLocatoins::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__AllCityLocatoins(soap, tag ? tag : "ns:AllCityLocatoins", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__AllCityLocatoins::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__AllCityLocatoins(soap, this, tag, type);
}

SOAP_FMAC3 ns__AllCityLocatoins * SOAP_FMAC4 soap_get_ns__AllCityLocatoins(struct soap *soap, ns__AllCityLocatoins *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AllCityLocatoins(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__CityLocation::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__CityLocation::clCity = "";
	soap_default_std__vectorTemplateOfxsd__string(soap, &this->ns__CityLocation::clLocations);
	this->ns__CityLocation::clErr.ns__ErrorCode::soap_default(soap);
}

void ns__CityLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__CityLocation::clCity);
	soap_serialize_std__vectorTemplateOfxsd__string(soap, &this->ns__CityLocation::clLocations);
	this->ns__CityLocation::clErr.soap_serialize(soap);
#endif
}

int ns__CityLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__CityLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__CityLocation(struct soap *soap, const char *tag, int id, const ns__CityLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__CityLocation), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "clCity", -1, &a->ns__CityLocation::clCity, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__string(soap, "clLocations", -1, &a->ns__CityLocation::clLocations, ""))
		return soap->error;
	if ((a->ns__CityLocation::clErr).soap_out(soap, "clErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__CityLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__CityLocation(soap, tag, this, type);
}

SOAP_FMAC3 ns__CityLocation * SOAP_FMAC4 soap_in_ns__CityLocation(struct soap *soap, const char *tag, ns__CityLocation *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__CityLocation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__CityLocation, sizeof(ns__CityLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__CityLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__CityLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clCity1 = 1;
	size_t soap_flag_clErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_clCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "clCity", &a->ns__CityLocation::clCity, "xsd:string"))
				{	soap_flag_clCity1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__string(soap, "clLocations", &a->ns__CityLocation::clLocations, "xsd:string"))
					continue;
			}
			if (soap_flag_clErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__CityLocation::clErr).soap_in(soap, "clErr", "ns:ErrorCode"))
				{	soap_flag_clErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_clErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__CityLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__CityLocation, SOAP_TYPE_ns__CityLocation, sizeof(ns__CityLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__CityLocation * SOAP_FMAC2 soap_instantiate_ns__CityLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__CityLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__CityLocation *p;
	size_t k = sizeof(ns__CityLocation);
	if (n < 0)
	{	p = SOAP_NEW(ns__CityLocation);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__CityLocation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__CityLocation location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__CityLocation, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__CityLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__CityLocation(soap, tag ? tag : "ns:CityLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__CityLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__CityLocation(soap, this, tag, type);
}

SOAP_FMAC3 ns__CityLocation * SOAP_FMAC4 soap_get_ns__CityLocation(struct soap *soap, ns__CityLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__CityLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__ServerOptions::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__ServerOptions::soDataBase.ns__DataBase::soap_default(soap);
	this->ns__ServerOptions::soRepeat = 0;
	this->ns__ServerOptions::soErr.ns__ErrorCode::soap_default(soap);
}

void ns__ServerOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__ServerOptions::soDataBase.soap_serialize(soap);
	this->ns__ServerOptions::soErr.soap_serialize(soap);
#endif
}

int ns__ServerOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__ServerOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ServerOptions(struct soap *soap, const char *tag, int id, const ns__ServerOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ServerOptions), type))
		return soap->error;
	if ((a->ns__ServerOptions::soDataBase).soap_out(soap, "soDataBase", -1, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "soRepeat", -1, &a->ns__ServerOptions::soRepeat, ""))
		return soap->error;
	if ((a->ns__ServerOptions::soErr).soap_out(soap, "soErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__ServerOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__ServerOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns__ServerOptions * SOAP_FMAC4 soap_in_ns__ServerOptions(struct soap *soap, const char *tag, ns__ServerOptions *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__ServerOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ServerOptions, sizeof(ns__ServerOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__ServerOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__ServerOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_soDataBase1 = 1;
	size_t soap_flag_soRepeat1 = 1;
	size_t soap_flag_soErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soDataBase1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__ServerOptions::soDataBase).soap_in(soap, "soDataBase", "ns:DataBase"))
				{	soap_flag_soDataBase1--;
					continue;
				}
			}
			if (soap_flag_soRepeat1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "soRepeat", &a->ns__ServerOptions::soRepeat, "xsd:int"))
				{	soap_flag_soRepeat1--;
					continue;
				}
			}
			if (soap_flag_soErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__ServerOptions::soErr).soap_in(soap, "soErr", "ns:ErrorCode"))
				{	soap_flag_soErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_soDataBase1 > 0 || soap_flag_soErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__ServerOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ServerOptions, SOAP_TYPE_ns__ServerOptions, sizeof(ns__ServerOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__ServerOptions * SOAP_FMAC2 soap_instantiate_ns__ServerOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ServerOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__ServerOptions *p;
	size_t k = sizeof(ns__ServerOptions);
	if (n < 0)
	{	p = SOAP_NEW(ns__ServerOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__ServerOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__ServerOptions location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ServerOptions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__ServerOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__ServerOptions(soap, tag ? tag : "ns:ServerOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__ServerOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__ServerOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns__ServerOptions * SOAP_FMAC4 soap_get_ns__ServerOptions(struct soap *soap, ns__ServerOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ServerOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__DataBase::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__DataBase::dbServer = "";
	this->ns__DataBase::bdPort = 0;
	this->ns__DataBase::dbUser = "";
	this->ns__DataBase::dbPassWord = "";
	this->ns__DataBase::dbErr.ns__ErrorCode::soap_default(soap);
}

void ns__DataBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__DataBase::dbServer);
	soap_serialize_xsd__string(soap, &this->ns__DataBase::dbUser);
	soap_serialize_xsd__string(soap, &this->ns__DataBase::dbPassWord);
	this->ns__DataBase::dbErr.soap_serialize(soap);
#endif
}

int ns__DataBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DataBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DataBase(struct soap *soap, const char *tag, int id, const ns__DataBase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DataBase), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "dbServer", -1, &a->ns__DataBase::dbServer, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "bdPort", -1, &a->ns__DataBase::bdPort, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "dbUser", -1, &a->ns__DataBase::dbUser, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "dbPassWord", -1, &a->ns__DataBase::dbPassWord, ""))
		return soap->error;
	if ((a->ns__DataBase::dbErr).soap_out(soap, "dbErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DataBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DataBase(soap, tag, this, type);
}

SOAP_FMAC3 ns__DataBase * SOAP_FMAC4 soap_in_ns__DataBase(struct soap *soap, const char *tag, ns__DataBase *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DataBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DataBase, sizeof(ns__DataBase), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__DataBase)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__DataBase *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dbServer1 = 1;
	size_t soap_flag_bdPort1 = 1;
	size_t soap_flag_dbUser1 = 1;
	size_t soap_flag_dbPassWord1 = 1;
	size_t soap_flag_dbErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dbServer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "dbServer", &a->ns__DataBase::dbServer, "xsd:string"))
				{	soap_flag_dbServer1--;
					continue;
				}
			}
			if (soap_flag_bdPort1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "bdPort", &a->ns__DataBase::bdPort, "xsd:int"))
				{	soap_flag_bdPort1--;
					continue;
				}
			}
			if (soap_flag_dbUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "dbUser", &a->ns__DataBase::dbUser, "xsd:string"))
				{	soap_flag_dbUser1--;
					continue;
				}
			}
			if (soap_flag_dbPassWord1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "dbPassWord", &a->ns__DataBase::dbPassWord, "xsd:string"))
				{	soap_flag_dbPassWord1--;
					continue;
				}
			}
			if (soap_flag_dbErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__DataBase::dbErr).soap_in(soap, "dbErr", "ns:ErrorCode"))
				{	soap_flag_dbErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dbErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__DataBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DataBase, SOAP_TYPE_ns__DataBase, sizeof(ns__DataBase), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__DataBase * SOAP_FMAC2 soap_instantiate_ns__DataBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DataBase(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__DataBase *p;
	size_t k = sizeof(ns__DataBase);
	if (n < 0)
	{	p = SOAP_NEW(ns__DataBase);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__DataBase, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__DataBase location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DataBase, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__DataBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__DataBase(soap, tag ? tag : "ns:DataBase", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__DataBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DataBase(soap, this, tag, type);
}

SOAP_FMAC3 ns__DataBase * SOAP_FMAC4 soap_get_ns__DataBase(struct soap *soap, ns__DataBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DataBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__UserDevice::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__UserDevice::udUser.ns__User::soap_default(soap);
	soap_default_std__vectorTemplateOfns__Device(soap, &this->ns__UserDevice::udDevs);
	this->ns__UserDevice::udErr.ns__ErrorCode::soap_default(soap);
}

void ns__UserDevice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__UserDevice::udUser.soap_serialize(soap);
	soap_serialize_std__vectorTemplateOfns__Device(soap, &this->ns__UserDevice::udDevs);
	this->ns__UserDevice::udErr.soap_serialize(soap);
#endif
}

int ns__UserDevice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__UserDevice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserDevice(struct soap *soap, const char *tag, int id, const ns__UserDevice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UserDevice), type))
		return soap->error;
	if ((a->ns__UserDevice::udUser).soap_out(soap, "udUser", -1, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__Device(soap, "udDevs", -1, &a->ns__UserDevice::udDevs, ""))
		return soap->error;
	if ((a->ns__UserDevice::udErr).soap_out(soap, "udErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__UserDevice::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__UserDevice(soap, tag, this, type);
}

SOAP_FMAC3 ns__UserDevice * SOAP_FMAC4 soap_in_ns__UserDevice(struct soap *soap, const char *tag, ns__UserDevice *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__UserDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UserDevice, sizeof(ns__UserDevice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__UserDevice)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__UserDevice *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_udUser1 = 1;
	size_t soap_flag_udErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_udUser1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__UserDevice::udUser).soap_in(soap, "udUser", "ns:User"))
				{	soap_flag_udUser1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__Device(soap, "udDevs", &a->ns__UserDevice::udDevs, "ns:Device"))
					continue;
			}
			if (soap_flag_udErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__UserDevice::udErr).soap_in(soap, "udErr", "ns:ErrorCode"))
				{	soap_flag_udErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_udUser1 > 0 || soap_flag_udErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__UserDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UserDevice, SOAP_TYPE_ns__UserDevice, sizeof(ns__UserDevice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__UserDevice * SOAP_FMAC2 soap_instantiate_ns__UserDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__UserDevice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__UserDevice *p;
	size_t k = sizeof(ns__UserDevice);
	if (n < 0)
	{	p = SOAP_NEW(ns__UserDevice);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__UserDevice, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__UserDevice location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__UserDevice, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__UserDevice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__UserDevice(soap, tag ? tag : "ns:UserDevice", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__UserDevice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__UserDevice(soap, this, tag, type);
}

SOAP_FMAC3 ns__UserDevice * SOAP_FMAC4 soap_get_ns__UserDevice(struct soap *soap, ns__UserDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UserDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__ErrorLog::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__ErrorLog::elDateTime = 0;
	this->ns__ErrorLog::elDevice.ns__Device::soap_default(soap);
	this->ns__ErrorLog::elErr.ns__ErrorCode::soap_default(soap);
}

void ns__ErrorLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__ErrorLog::elDevice.soap_serialize(soap);
	this->ns__ErrorLog::elErr.soap_serialize(soap);
#endif
}

int ns__ErrorLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__ErrorLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ErrorLog(struct soap *soap, const char *tag, int id, const ns__ErrorLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ErrorLog), type))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "elDateTime", -1, &a->ns__ErrorLog::elDateTime, ""))
		return soap->error;
	if ((a->ns__ErrorLog::elDevice).soap_out(soap, "elDevice", -1, ""))
		return soap->error;
	if ((a->ns__ErrorLog::elErr).soap_out(soap, "elErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__ErrorLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__ErrorLog(soap, tag, this, type);
}

SOAP_FMAC3 ns__ErrorLog * SOAP_FMAC4 soap_in_ns__ErrorLog(struct soap *soap, const char *tag, ns__ErrorLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__ErrorLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ErrorLog, sizeof(ns__ErrorLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__ErrorLog)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__ErrorLog *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_elDateTime1 = 1;
	size_t soap_flag_elDevice1 = 1;
	size_t soap_flag_elErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_elDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "elDateTime", &a->ns__ErrorLog::elDateTime, "xsd:dateTime"))
				{	soap_flag_elDateTime1--;
					continue;
				}
			}
			if (soap_flag_elDevice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__ErrorLog::elDevice).soap_in(soap, "elDevice", "ns:Device"))
				{	soap_flag_elDevice1--;
					continue;
				}
			}
			if (soap_flag_elErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__ErrorLog::elErr).soap_in(soap, "elErr", "ns:ErrorCode"))
				{	soap_flag_elErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_elDevice1 > 0 || soap_flag_elErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__ErrorLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ErrorLog, SOAP_TYPE_ns__ErrorLog, sizeof(ns__ErrorLog), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__ErrorLog * SOAP_FMAC2 soap_instantiate_ns__ErrorLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ErrorLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__ErrorLog *p;
	size_t k = sizeof(ns__ErrorLog);
	if (n < 0)
	{	p = SOAP_NEW(ns__ErrorLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__ErrorLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__ErrorLog location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ErrorLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__ErrorLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__ErrorLog(soap, tag ? tag : "ns:ErrorLog", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__ErrorLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__ErrorLog(soap, this, tag, type);
}

SOAP_FMAC3 ns__ErrorLog * SOAP_FMAC4 soap_get_ns__ErrorLog(struct soap *soap, ns__ErrorLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ErrorLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__DeviceStatus::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__DeviceStatus::dsRange.ns__ReportRange::soap_default(soap);
	soap_default_std__vectorTemplateOfns__Device(soap, &this->ns__DeviceStatus::dsDevice);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns__DeviceStatus::dsErr);
}

void ns__DeviceStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__DeviceStatus::dsRange.soap_serialize(soap);
	soap_serialize_std__vectorTemplateOfns__Device(soap, &this->ns__DeviceStatus::dsDevice);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns__DeviceStatus::dsErr);
#endif
}

int ns__DeviceStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DeviceStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceStatus(struct soap *soap, const char *tag, int id, const ns__DeviceStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeviceStatus), type))
		return soap->error;
	if ((a->ns__DeviceStatus::dsRange).soap_out(soap, "dsRange", -1, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__Device(soap, "dsDevice", -1, &a->ns__DeviceStatus::dsDevice, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "dsErr", -1, &a->ns__DeviceStatus::dsErr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DeviceStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DeviceStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns__DeviceStatus * SOAP_FMAC4 soap_in_ns__DeviceStatus(struct soap *soap, const char *tag, ns__DeviceStatus *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DeviceStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeviceStatus, sizeof(ns__DeviceStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__DeviceStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__DeviceStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dsRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dsRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__DeviceStatus::dsRange).soap_in(soap, "dsRange", "ns:ReportRange"))
				{	soap_flag_dsRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__Device(soap, "dsDevice", &a->ns__DeviceStatus::dsDevice, "ns:Device"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "dsErr", &a->ns__DeviceStatus::dsErr, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dsRange1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__DeviceStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeviceStatus, SOAP_TYPE_ns__DeviceStatus, sizeof(ns__DeviceStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__DeviceStatus * SOAP_FMAC2 soap_instantiate_ns__DeviceStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeviceStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__DeviceStatus *p;
	size_t k = sizeof(ns__DeviceStatus);
	if (n < 0)
	{	p = SOAP_NEW(ns__DeviceStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__DeviceStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__DeviceStatus location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeviceStatus, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__DeviceStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__DeviceStatus(soap, tag ? tag : "ns:DeviceStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__DeviceStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DeviceStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns__DeviceStatus * SOAP_FMAC4 soap_get_ns__DeviceStatus(struct soap *soap, ns__DeviceStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeviceStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__DeviceStatusLogList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__DeviceStatusLog(soap, &this->ns__DeviceStatusLogList::dsllStatus);
	this->ns__DeviceStatusLogList::dsllErr.ns__ErrorCode::soap_default(soap);
}

void ns__DeviceStatusLogList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__DeviceStatusLog(soap, &this->ns__DeviceStatusLogList::dsllStatus);
	this->ns__DeviceStatusLogList::dsllErr.soap_serialize(soap);
#endif
}

int ns__DeviceStatusLogList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DeviceStatusLogList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceStatusLogList(struct soap *soap, const char *tag, int id, const ns__DeviceStatusLogList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeviceStatusLogList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__DeviceStatusLog(soap, "dsllStatus", -1, &a->ns__DeviceStatusLogList::dsllStatus, ""))
		return soap->error;
	if ((a->ns__DeviceStatusLogList::dsllErr).soap_out(soap, "dsllErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DeviceStatusLogList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DeviceStatusLogList(soap, tag, this, type);
}

SOAP_FMAC3 ns__DeviceStatusLogList * SOAP_FMAC4 soap_in_ns__DeviceStatusLogList(struct soap *soap, const char *tag, ns__DeviceStatusLogList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DeviceStatusLogList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeviceStatusLogList, sizeof(ns__DeviceStatusLogList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__DeviceStatusLogList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__DeviceStatusLogList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dsllErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__DeviceStatusLog(soap, "dsllStatus", &a->ns__DeviceStatusLogList::dsllStatus, "ns:DeviceStatusLog"))
					continue;
			}
			if (soap_flag_dsllErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__DeviceStatusLogList::dsllErr).soap_in(soap, "dsllErr", "ns:ErrorCode"))
				{	soap_flag_dsllErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dsllErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__DeviceStatusLogList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeviceStatusLogList, SOAP_TYPE_ns__DeviceStatusLogList, sizeof(ns__DeviceStatusLogList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__DeviceStatusLogList * SOAP_FMAC2 soap_instantiate_ns__DeviceStatusLogList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeviceStatusLogList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__DeviceStatusLogList *p;
	size_t k = sizeof(ns__DeviceStatusLogList);
	if (n < 0)
	{	p = SOAP_NEW(ns__DeviceStatusLogList);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__DeviceStatusLogList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__DeviceStatusLogList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeviceStatusLogList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__DeviceStatusLogList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__DeviceStatusLogList(soap, tag ? tag : "ns:DeviceStatusLogList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__DeviceStatusLogList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DeviceStatusLogList(soap, this, tag, type);
}

SOAP_FMAC3 ns__DeviceStatusLogList * SOAP_FMAC4 soap_get_ns__DeviceStatusLogList(struct soap *soap, ns__DeviceStatusLogList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeviceStatusLogList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__DeviceStatusLog::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__DeviceStatusLog::dslDateTime = 0;
	this->ns__DeviceStatusLog::dslDevice.ns__Device::soap_default(soap);
	this->ns__DeviceStatusLog::dslErr.ns__ErrorCode::soap_default(soap);
}

void ns__DeviceStatusLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__DeviceStatusLog::dslDevice.soap_serialize(soap);
	this->ns__DeviceStatusLog::dslErr.soap_serialize(soap);
#endif
}

int ns__DeviceStatusLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__DeviceStatusLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeviceStatusLog(struct soap *soap, const char *tag, int id, const ns__DeviceStatusLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeviceStatusLog), type))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "dslDateTime", -1, &a->ns__DeviceStatusLog::dslDateTime, ""))
		return soap->error;
	if ((a->ns__DeviceStatusLog::dslDevice).soap_out(soap, "dslDevice", -1, ""))
		return soap->error;
	if ((a->ns__DeviceStatusLog::dslErr).soap_out(soap, "dslErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__DeviceStatusLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__DeviceStatusLog(soap, tag, this, type);
}

SOAP_FMAC3 ns__DeviceStatusLog * SOAP_FMAC4 soap_in_ns__DeviceStatusLog(struct soap *soap, const char *tag, ns__DeviceStatusLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__DeviceStatusLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeviceStatusLog, sizeof(ns__DeviceStatusLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__DeviceStatusLog)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__DeviceStatusLog *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dslDateTime1 = 1;
	size_t soap_flag_dslDevice1 = 1;
	size_t soap_flag_dslErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dslDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "dslDateTime", &a->ns__DeviceStatusLog::dslDateTime, "xsd:dateTime"))
				{	soap_flag_dslDateTime1--;
					continue;
				}
			}
			if (soap_flag_dslDevice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__DeviceStatusLog::dslDevice).soap_in(soap, "dslDevice", "ns:Device"))
				{	soap_flag_dslDevice1--;
					continue;
				}
			}
			if (soap_flag_dslErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__DeviceStatusLog::dslErr).soap_in(soap, "dslErr", "ns:ErrorCode"))
				{	soap_flag_dslErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dslDevice1 > 0 || soap_flag_dslErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__DeviceStatusLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeviceStatusLog, SOAP_TYPE_ns__DeviceStatusLog, sizeof(ns__DeviceStatusLog), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__DeviceStatusLog * SOAP_FMAC2 soap_instantiate_ns__DeviceStatusLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeviceStatusLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__DeviceStatusLog *p;
	size_t k = sizeof(ns__DeviceStatusLog);
	if (n < 0)
	{	p = SOAP_NEW(ns__DeviceStatusLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__DeviceStatusLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__DeviceStatusLog location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeviceStatusLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__DeviceStatusLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__DeviceStatusLog(soap, tag ? tag : "ns:DeviceStatusLog", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__DeviceStatusLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__DeviceStatusLog(soap, this, tag, type);
}

SOAP_FMAC3 ns__DeviceStatusLog * SOAP_FMAC4 soap_get_ns__DeviceStatusLog(struct soap *soap, ns__DeviceStatusLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeviceStatusLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__UserLog::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__UserLog::ulRange.ns__ReportRange::soap_default(soap);
	this->ns__UserLog::ulData = "";
	this->ns__UserLog::ulUser.ns__User::soap_default(soap);
}

void ns__UserLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__UserLog::ulRange.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &this->ns__UserLog::ulData);
	this->ns__UserLog::ulUser.soap_serialize(soap);
#endif
}

int ns__UserLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__UserLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UserLog(struct soap *soap, const char *tag, int id, const ns__UserLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UserLog), type))
		return soap->error;
	if ((a->ns__UserLog::ulRange).soap_out(soap, "ulRange", -1, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "ulData", -1, &a->ns__UserLog::ulData, ""))
		return soap->error;
	if ((a->ns__UserLog::ulUser).soap_out(soap, "ulUser", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__UserLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__UserLog(soap, tag, this, type);
}

SOAP_FMAC3 ns__UserLog * SOAP_FMAC4 soap_in_ns__UserLog(struct soap *soap, const char *tag, ns__UserLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__UserLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UserLog, sizeof(ns__UserLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__UserLog)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__UserLog *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ulRange1 = 1;
	size_t soap_flag_ulData1 = 1;
	size_t soap_flag_ulUser1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ulRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__UserLog::ulRange).soap_in(soap, "ulRange", "ns:ReportRange"))
				{	soap_flag_ulRange1--;
					continue;
				}
			}
			if (soap_flag_ulData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "ulData", &a->ns__UserLog::ulData, "xsd:string"))
				{	soap_flag_ulData1--;
					continue;
				}
			}
			if (soap_flag_ulUser1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__UserLog::ulUser).soap_in(soap, "ulUser", "ns:User"))
				{	soap_flag_ulUser1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ulRange1 > 0 || soap_flag_ulUser1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__UserLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UserLog, SOAP_TYPE_ns__UserLog, sizeof(ns__UserLog), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__UserLog * SOAP_FMAC2 soap_instantiate_ns__UserLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__UserLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__UserLog *p;
	size_t k = sizeof(ns__UserLog);
	if (n < 0)
	{	p = SOAP_NEW(ns__UserLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__UserLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__UserLog location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__UserLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__UserLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__UserLog(soap, tag ? tag : "ns:UserLog", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__UserLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__UserLog(soap, this, tag, type);
}

SOAP_FMAC3 ns__UserLog * SOAP_FMAC4 soap_get_ns__UserLog(struct soap *soap, ns__UserLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UserLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__ActivityLog::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__ActivityLog::alRange.ns__ReportRange::soap_default(soap);
	this->ns__ActivityLog::alData = "";
	this->ns__ActivityLog::alDevice.ns__Device::soap_default(soap);
	this->ns__ActivityLog::alUser.ns__User::soap_default(soap);
	this->ns__ActivityLog::alErr.ns__ErrorCode::soap_default(soap);
}

void ns__ActivityLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__ActivityLog::alRange.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &this->ns__ActivityLog::alData);
	this->ns__ActivityLog::alDevice.soap_serialize(soap);
	this->ns__ActivityLog::alUser.soap_serialize(soap);
	this->ns__ActivityLog::alErr.soap_serialize(soap);
#endif
}

int ns__ActivityLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__ActivityLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ActivityLog(struct soap *soap, const char *tag, int id, const ns__ActivityLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ActivityLog), type))
		return soap->error;
	if ((a->ns__ActivityLog::alRange).soap_out(soap, "alRange", -1, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "alData", -1, &a->ns__ActivityLog::alData, ""))
		return soap->error;
	if ((a->ns__ActivityLog::alDevice).soap_out(soap, "alDevice", -1, ""))
		return soap->error;
	if ((a->ns__ActivityLog::alUser).soap_out(soap, "alUser", -1, ""))
		return soap->error;
	if ((a->ns__ActivityLog::alErr).soap_out(soap, "alErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__ActivityLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__ActivityLog(soap, tag, this, type);
}

SOAP_FMAC3 ns__ActivityLog * SOAP_FMAC4 soap_in_ns__ActivityLog(struct soap *soap, const char *tag, ns__ActivityLog *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__ActivityLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ActivityLog, sizeof(ns__ActivityLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__ActivityLog)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__ActivityLog *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_alRange1 = 1;
	size_t soap_flag_alData1 = 1;
	size_t soap_flag_alDevice1 = 1;
	size_t soap_flag_alUser1 = 1;
	size_t soap_flag_alErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__ActivityLog::alRange).soap_in(soap, "alRange", "ns:ReportRange"))
				{	soap_flag_alRange1--;
					continue;
				}
			}
			if (soap_flag_alData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "alData", &a->ns__ActivityLog::alData, "xsd:string"))
				{	soap_flag_alData1--;
					continue;
				}
			}
			if (soap_flag_alDevice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__ActivityLog::alDevice).soap_in(soap, "alDevice", "ns:Device"))
				{	soap_flag_alDevice1--;
					continue;
				}
			}
			if (soap_flag_alUser1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__ActivityLog::alUser).soap_in(soap, "alUser", "ns:User"))
				{	soap_flag_alUser1--;
					continue;
				}
			}
			if (soap_flag_alErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__ActivityLog::alErr).soap_in(soap, "alErr", "ns:ErrorCode"))
				{	soap_flag_alErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alRange1 > 0 || soap_flag_alDevice1 > 0 || soap_flag_alUser1 > 0 || soap_flag_alErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__ActivityLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ActivityLog, SOAP_TYPE_ns__ActivityLog, sizeof(ns__ActivityLog), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__ActivityLog * SOAP_FMAC2 soap_instantiate_ns__ActivityLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ActivityLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__ActivityLog *p;
	size_t k = sizeof(ns__ActivityLog);
	if (n < 0)
	{	p = SOAP_NEW(ns__ActivityLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__ActivityLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__ActivityLog location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ActivityLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__ActivityLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__ActivityLog(soap, tag ? tag : "ns:ActivityLog", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__ActivityLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__ActivityLog(soap, this, tag, type);
}

SOAP_FMAC3 ns__ActivityLog * SOAP_FMAC4 soap_get_ns__ActivityLog(struct soap *soap, ns__ActivityLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ActivityLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__ReportRange::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__ReportRange::rrStart = 0;
	this->ns__ReportRange::rrEnd = 0;
}

void ns__ReportRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns__ReportRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__ReportRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ReportRange(struct soap *soap, const char *tag, int id, const ns__ReportRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ReportRange), type))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "rrStart", -1, &a->ns__ReportRange::rrStart, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "rrEnd", -1, &a->ns__ReportRange::rrEnd, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__ReportRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__ReportRange(soap, tag, this, type);
}

SOAP_FMAC3 ns__ReportRange * SOAP_FMAC4 soap_in_ns__ReportRange(struct soap *soap, const char *tag, ns__ReportRange *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__ReportRange *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ReportRange, sizeof(ns__ReportRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__ReportRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__ReportRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_rrStart1 = 1;
	size_t soap_flag_rrEnd1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_rrStart1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "rrStart", &a->ns__ReportRange::rrStart, "xsd:dateTime"))
				{	soap_flag_rrStart1--;
					continue;
				}
			}
			if (soap_flag_rrEnd1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "rrEnd", &a->ns__ReportRange::rrEnd, "xsd:dateTime"))
				{	soap_flag_rrEnd1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__ReportRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ReportRange, SOAP_TYPE_ns__ReportRange, sizeof(ns__ReportRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__ReportRange * SOAP_FMAC2 soap_instantiate_ns__ReportRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ReportRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__ReportRange *p;
	size_t k = sizeof(ns__ReportRange);
	if (n < 0)
	{	p = SOAP_NEW(ns__ReportRange);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__ReportRange, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__ReportRange location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ReportRange, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__ReportRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__ReportRange(soap, tag ? tag : "ns:ReportRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__ReportRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__ReportRange(soap, this, tag, type);
}

SOAP_FMAC3 ns__ReportRange * SOAP_FMAC4 soap_get_ns__ReportRange(struct soap *soap, ns__ReportRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ReportRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Device::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Device::dSerialNumber = 0;
	this->ns__Device::dModel = (enum ns__DeviceModel)1;
	this->ns__Device::dName = "";
	this->ns__Device::dNikeName = "";
	this->ns__Device::dLocation = "";
	this->ns__Device::dCity = "";
	this->ns__Device::dSocket = 0;
	this->ns__Device::dDNSAddress = "";
	this->ns__Device::dIP.ns__IP::soap_default(soap);
	this->ns__Device::dPort = 0;
	this->ns__Device::dDateTime = 0;
	this->ns__Device::dDDateTime = 0;
	this->ns__Device::dCamera.ns__Camera::soap_default(soap);
	this->ns__Device::dGPS.ns__GPS::soap_default(soap);
	this->ns__Device::dReset = (bool)0;
	this->ns__Device::dSamplingTime = 0;
	this->ns__Device::dTransPower = 0;
	this->ns__Device::dTableCapacity = 0;
	this->ns__Device::dPOK = 0;
	this->ns__Device::dPTotal = 0;
	this->ns__Device::dPR = 0;
	this->ns__Device::dPS = 0;
	this->ns__Device::dPT = 0;
	this->ns__Device::dQR = 0;
	this->ns__Device::dQS = 0;
	this->ns__Device::dQT = 0;
	this->ns__Device::dKeyName = "";
	this->ns__Device::dPicture.ns__Picture::soap_default(soap);
	this->ns__Device::dCustomCommand = "";
	soap_default_std__vectorTemplateOfxsd__boolean(soap, &this->ns__Device::dRelays);
	soap_default_std__vectorTemplateOfns__RequestType(soap, &this->ns__Device::dRequests);
	soap_default_std__vectorTemplateOfns__SensorExtension(soap, &this->ns__Device::dSensors);
	this->ns__Device::dSmsTerm = 60;
	this->ns__Device::dSms = (bool)0;
	this->ns__Device::dSmsTime = 0;
	this->ns__Device::dErr.ns__ErrorCode::soap_default(soap);
}

void ns__Device::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__Device::dName);
	soap_serialize_xsd__string(soap, &this->ns__Device::dNikeName);
	soap_serialize_xsd__string(soap, &this->ns__Device::dLocation);
	soap_serialize_xsd__string(soap, &this->ns__Device::dCity);
	soap_serialize_xsd__string(soap, &this->ns__Device::dDNSAddress);
	this->ns__Device::dIP.soap_serialize(soap);
	this->ns__Device::dCamera.soap_serialize(soap);
	this->ns__Device::dGPS.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &this->ns__Device::dKeyName);
	this->ns__Device::dPicture.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &this->ns__Device::dCustomCommand);
	soap_serialize_std__vectorTemplateOfxsd__boolean(soap, &this->ns__Device::dRelays);
	soap_serialize_std__vectorTemplateOfns__RequestType(soap, &this->ns__Device::dRequests);
	soap_serialize_std__vectorTemplateOfns__SensorExtension(soap, &this->ns__Device::dSensors);
	this->ns__Device::dErr.soap_serialize(soap);
#endif
}

int ns__Device::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Device(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Device(struct soap *soap, const char *tag, int id, const ns__Device *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Device), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "dSerialNumber", -1, &a->ns__Device::dSerialNumber, ""))
		return soap->error;
	if (soap_out_ns__DeviceModel(soap, "dModel", -1, &a->ns__Device::dModel, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "dName", -1, &a->ns__Device::dName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "dNikeName", -1, &a->ns__Device::dNikeName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "dLocation", -1, &a->ns__Device::dLocation, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "dCity", -1, &a->ns__Device::dCity, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "dSocket", -1, &a->ns__Device::dSocket, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "dDNSAddress", -1, &a->ns__Device::dDNSAddress, ""))
		return soap->error;
	if ((a->ns__Device::dIP).soap_out(soap, "dIP", -1, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "dPort", -1, &a->ns__Device::dPort, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "dDateTime", -1, &a->ns__Device::dDateTime, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "dDDateTime", -1, &a->ns__Device::dDDateTime, ""))
		return soap->error;
	if ((a->ns__Device::dCamera).soap_out(soap, "dCamera", -1, ""))
		return soap->error;
	if ((a->ns__Device::dGPS).soap_out(soap, "dGPS", -1, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "dReset", -1, &a->ns__Device::dReset, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "dSamplingTime", -1, &a->ns__Device::dSamplingTime, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "dTransPower", -1, &a->ns__Device::dTransPower, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "dTableCapacity", -1, &a->ns__Device::dTableCapacity, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "dPOK", -1, &a->ns__Device::dPOK, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "dPTotal", -1, &a->ns__Device::dPTotal, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "dPR", -1, &a->ns__Device::dPR, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "dPS", -1, &a->ns__Device::dPS, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "dPT", -1, &a->ns__Device::dPT, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "dQR", -1, &a->ns__Device::dQR, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "dQS", -1, &a->ns__Device::dQS, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "dQT", -1, &a->ns__Device::dQT, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "dKeyName", -1, &a->ns__Device::dKeyName, ""))
		return soap->error;
	if ((a->ns__Device::dPicture).soap_out(soap, "dPicture", -1, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "dCustomCommand", -1, &a->ns__Device::dCustomCommand, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__boolean(soap, "dRelays", -1, &a->ns__Device::dRelays, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__RequestType(soap, "dRequests", -1, &a->ns__Device::dRequests, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__SensorExtension(soap, "dSensors", -1, &a->ns__Device::dSensors, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "dSmsTerm", -1, &a->ns__Device::dSmsTerm, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "dSms", -1, &a->ns__Device::dSms, ""))
		return soap->error;
	if (soap_out_xsd__dateTime(soap, "dSmsTime", -1, &a->ns__Device::dSmsTime, ""))
		return soap->error;
	if ((a->ns__Device::dErr).soap_out(soap, "dErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Device::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Device(soap, tag, this, type);
}

SOAP_FMAC3 ns__Device * SOAP_FMAC4 soap_in_ns__Device(struct soap *soap, const char *tag, ns__Device *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Device *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Device, sizeof(ns__Device), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__Device)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__Device *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dSerialNumber1 = 1;
	size_t soap_flag_dModel1 = 1;
	size_t soap_flag_dName1 = 1;
	size_t soap_flag_dNikeName1 = 1;
	size_t soap_flag_dLocation1 = 1;
	size_t soap_flag_dCity1 = 1;
	size_t soap_flag_dSocket1 = 1;
	size_t soap_flag_dDNSAddress1 = 1;
	size_t soap_flag_dIP1 = 1;
	size_t soap_flag_dPort1 = 1;
	size_t soap_flag_dDateTime1 = 1;
	size_t soap_flag_dDDateTime1 = 1;
	size_t soap_flag_dCamera1 = 1;
	size_t soap_flag_dGPS1 = 1;
	size_t soap_flag_dReset1 = 1;
	size_t soap_flag_dSamplingTime1 = 1;
	size_t soap_flag_dTransPower1 = 1;
	size_t soap_flag_dTableCapacity1 = 1;
	size_t soap_flag_dPOK1 = 1;
	size_t soap_flag_dPTotal1 = 1;
	size_t soap_flag_dPR1 = 1;
	size_t soap_flag_dPS1 = 1;
	size_t soap_flag_dPT1 = 1;
	size_t soap_flag_dQR1 = 1;
	size_t soap_flag_dQS1 = 1;
	size_t soap_flag_dQT1 = 1;
	size_t soap_flag_dKeyName1 = 1;
	size_t soap_flag_dPicture1 = 1;
	size_t soap_flag_dCustomCommand1 = 1;
	size_t soap_flag_dSmsTerm1 = 1;
	size_t soap_flag_dSms1 = 1;
	size_t soap_flag_dSmsTime1 = 1;
	size_t soap_flag_dErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dSerialNumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "dSerialNumber", &a->ns__Device::dSerialNumber, "xsd:int"))
				{	soap_flag_dSerialNumber1--;
					continue;
				}
			}
			if (soap_flag_dModel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns__DeviceModel(soap, "dModel", &a->ns__Device::dModel, "ns:DeviceModel"))
				{	soap_flag_dModel1--;
					continue;
				}
			}
			if (soap_flag_dName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "dName", &a->ns__Device::dName, "xsd:string"))
				{	soap_flag_dName1--;
					continue;
				}
			}
			if (soap_flag_dNikeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "dNikeName", &a->ns__Device::dNikeName, "xsd:string"))
				{	soap_flag_dNikeName1--;
					continue;
				}
			}
			if (soap_flag_dLocation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "dLocation", &a->ns__Device::dLocation, "xsd:string"))
				{	soap_flag_dLocation1--;
					continue;
				}
			}
			if (soap_flag_dCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "dCity", &a->ns__Device::dCity, "xsd:string"))
				{	soap_flag_dCity1--;
					continue;
				}
			}
			if (soap_flag_dSocket1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "dSocket", &a->ns__Device::dSocket, "xsd:int"))
				{	soap_flag_dSocket1--;
					continue;
				}
			}
			if (soap_flag_dDNSAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "dDNSAddress", &a->ns__Device::dDNSAddress, "xsd:string"))
				{	soap_flag_dDNSAddress1--;
					continue;
				}
			}
			if (soap_flag_dIP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__Device::dIP).soap_in(soap, "dIP", "ns:IP"))
				{	soap_flag_dIP1--;
					continue;
				}
			}
			if (soap_flag_dPort1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "dPort", &a->ns__Device::dPort, "xsd:int"))
				{	soap_flag_dPort1--;
					continue;
				}
			}
			if (soap_flag_dDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "dDateTime", &a->ns__Device::dDateTime, "xsd:dateTime"))
				{	soap_flag_dDateTime1--;
					continue;
				}
			}
			if (soap_flag_dDDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "dDDateTime", &a->ns__Device::dDDateTime, "xsd:dateTime"))
				{	soap_flag_dDDateTime1--;
					continue;
				}
			}
			if (soap_flag_dCamera1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__Device::dCamera).soap_in(soap, "dCamera", "ns:Camera"))
				{	soap_flag_dCamera1--;
					continue;
				}
			}
			if (soap_flag_dGPS1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__Device::dGPS).soap_in(soap, "dGPS", "ns:GPS"))
				{	soap_flag_dGPS1--;
					continue;
				}
			}
			if (soap_flag_dReset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "dReset", &a->ns__Device::dReset, "xsd:boolean"))
				{	soap_flag_dReset1--;
					continue;
				}
			}
			if (soap_flag_dSamplingTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "dSamplingTime", &a->ns__Device::dSamplingTime, "xsd:int"))
				{	soap_flag_dSamplingTime1--;
					continue;
				}
			}
			if (soap_flag_dTransPower1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "dTransPower", &a->ns__Device::dTransPower, "xsd:double"))
				{	soap_flag_dTransPower1--;
					continue;
				}
			}
			if (soap_flag_dTableCapacity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "dTableCapacity", &a->ns__Device::dTableCapacity, "xsd:double"))
				{	soap_flag_dTableCapacity1--;
					continue;
				}
			}
			if (soap_flag_dPOK1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "dPOK", &a->ns__Device::dPOK, "xsd:double"))
				{	soap_flag_dPOK1--;
					continue;
				}
			}
			if (soap_flag_dPTotal1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "dPTotal", &a->ns__Device::dPTotal, "xsd:double"))
				{	soap_flag_dPTotal1--;
					continue;
				}
			}
			if (soap_flag_dPR1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "dPR", &a->ns__Device::dPR, "xsd:double"))
				{	soap_flag_dPR1--;
					continue;
				}
			}
			if (soap_flag_dPS1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "dPS", &a->ns__Device::dPS, "xsd:double"))
				{	soap_flag_dPS1--;
					continue;
				}
			}
			if (soap_flag_dPT1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "dPT", &a->ns__Device::dPT, "xsd:double"))
				{	soap_flag_dPT1--;
					continue;
				}
			}
			if (soap_flag_dQR1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "dQR", &a->ns__Device::dQR, "xsd:double"))
				{	soap_flag_dQR1--;
					continue;
				}
			}
			if (soap_flag_dQS1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "dQS", &a->ns__Device::dQS, "xsd:double"))
				{	soap_flag_dQS1--;
					continue;
				}
			}
			if (soap_flag_dQT1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "dQT", &a->ns__Device::dQT, "xsd:double"))
				{	soap_flag_dQT1--;
					continue;
				}
			}
			if (soap_flag_dKeyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "dKeyName", &a->ns__Device::dKeyName, "xsd:string"))
				{	soap_flag_dKeyName1--;
					continue;
				}
			}
			if (soap_flag_dPicture1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__Device::dPicture).soap_in(soap, "dPicture", "ns:Picture"))
				{	soap_flag_dPicture1--;
					continue;
				}
			}
			if (soap_flag_dCustomCommand1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "dCustomCommand", &a->ns__Device::dCustomCommand, "xsd:string"))
				{	soap_flag_dCustomCommand1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__boolean(soap, "dRelays", &a->ns__Device::dRelays, "xsd:boolean"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__RequestType(soap, "dRequests", &a->ns__Device::dRequests, "ns:RequestType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__SensorExtension(soap, "dSensors", &a->ns__Device::dSensors, "ns:SensorExtension"))
					continue;
			}
			if (soap_flag_dSmsTerm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "dSmsTerm", &a->ns__Device::dSmsTerm, "xsd:int"))
				{	soap_flag_dSmsTerm1--;
					continue;
				}
			}
			if (soap_flag_dSms1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__boolean(soap, "dSms", &a->ns__Device::dSms, "xsd:boolean"))
				{	soap_flag_dSms1--;
					continue;
				}
			}
			if (soap_flag_dSmsTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__dateTime(soap, "dSmsTime", &a->ns__Device::dSmsTime, "xsd:dateTime"))
				{	soap_flag_dSmsTime1--;
					continue;
				}
			}
			if (soap_flag_dErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__Device::dErr).soap_in(soap, "dErr", "ns:ErrorCode"))
				{	soap_flag_dErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dIP1 > 0 || soap_flag_dCamera1 > 0 || soap_flag_dGPS1 > 0 || soap_flag_dPicture1 > 0 || soap_flag_dErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__Device *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Device, SOAP_TYPE_ns__Device, sizeof(ns__Device), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Device * SOAP_FMAC2 soap_instantiate_ns__Device(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Device(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Device *p;
	size_t k = sizeof(ns__Device);
	if (n < 0)
	{	p = SOAP_NEW(ns__Device);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Device, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Device location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Device, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Device::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__Device(soap, tag ? tag : "ns:Device", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Device::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Device(soap, this, tag, type);
}

SOAP_FMAC3 ns__Device * SOAP_FMAC4 soap_get_ns__Device(struct soap *soap, ns__Device *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Device(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Picture::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Picture::pName = "";
	this->ns__Picture::pSize = 0;
	this->ns__Picture::pPartSize = 0;
	this->ns__Picture::pPartNo = 0;
	this->ns__Picture::pCRC = 0;
	soap_default_std__vectorTemplateOfns__PicturePart(soap, &this->ns__Picture::pParts);
}

void ns__Picture::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__Picture::pName);
	soap_serialize_std__vectorTemplateOfns__PicturePart(soap, &this->ns__Picture::pParts);
#endif
}

int ns__Picture::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Picture(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Picture(struct soap *soap, const char *tag, int id, const ns__Picture *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Picture), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "pName", -1, &a->ns__Picture::pName, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "pSize", -1, &a->ns__Picture::pSize, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "pPartSize", -1, &a->ns__Picture::pPartSize, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "pPartNo", -1, &a->ns__Picture::pPartNo, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "pCRC", -1, &a->ns__Picture::pCRC, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__PicturePart(soap, "pParts", -1, &a->ns__Picture::pParts, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Picture::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Picture(soap, tag, this, type);
}

SOAP_FMAC3 ns__Picture * SOAP_FMAC4 soap_in_ns__Picture(struct soap *soap, const char *tag, ns__Picture *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Picture *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Picture, sizeof(ns__Picture), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__Picture)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__Picture *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_pName1 = 1;
	size_t soap_flag_pSize1 = 1;
	size_t soap_flag_pPartSize1 = 1;
	size_t soap_flag_pPartNo1 = 1;
	size_t soap_flag_pCRC1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "pName", &a->ns__Picture::pName, "xsd:string"))
				{	soap_flag_pName1--;
					continue;
				}
			}
			if (soap_flag_pSize1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "pSize", &a->ns__Picture::pSize, "xsd:int"))
				{	soap_flag_pSize1--;
					continue;
				}
			}
			if (soap_flag_pPartSize1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "pPartSize", &a->ns__Picture::pPartSize, "xsd:int"))
				{	soap_flag_pPartSize1--;
					continue;
				}
			}
			if (soap_flag_pPartNo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "pPartNo", &a->ns__Picture::pPartNo, "xsd:int"))
				{	soap_flag_pPartNo1--;
					continue;
				}
			}
			if (soap_flag_pCRC1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "pCRC", &a->ns__Picture::pCRC, "xsd:int"))
				{	soap_flag_pCRC1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__PicturePart(soap, "pParts", &a->ns__Picture::pParts, "ns:PicturePart"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Picture *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Picture, SOAP_TYPE_ns__Picture, sizeof(ns__Picture), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Picture * SOAP_FMAC2 soap_instantiate_ns__Picture(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Picture(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Picture *p;
	size_t k = sizeof(ns__Picture);
	if (n < 0)
	{	p = SOAP_NEW(ns__Picture);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Picture, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Picture location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Picture, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Picture::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__Picture(soap, tag ? tag : "ns:Picture", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Picture::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Picture(soap, this, tag, type);
}

SOAP_FMAC3 ns__Picture * SOAP_FMAC4 soap_get_ns__Picture(struct soap *soap, ns__Picture *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Picture(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__PicturePart::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__PicturePart::ppIndex = 0;
	this->ns__PicturePart::ppData = "";
	this->ns__PicturePart::ppCRC = 0;
}

void ns__PicturePart::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__PicturePart::ppData);
#endif
}

int ns__PicturePart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__PicturePart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__PicturePart(struct soap *soap, const char *tag, int id, const ns__PicturePart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__PicturePart), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "ppIndex", -1, &a->ns__PicturePart::ppIndex, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "ppData", -1, &a->ns__PicturePart::ppData, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "ppCRC", -1, &a->ns__PicturePart::ppCRC, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__PicturePart::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__PicturePart(soap, tag, this, type);
}

SOAP_FMAC3 ns__PicturePart * SOAP_FMAC4 soap_in_ns__PicturePart(struct soap *soap, const char *tag, ns__PicturePart *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__PicturePart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__PicturePart, sizeof(ns__PicturePart), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__PicturePart)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__PicturePart *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ppIndex1 = 1;
	size_t soap_flag_ppData1 = 1;
	size_t soap_flag_ppCRC1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ppIndex1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "ppIndex", &a->ns__PicturePart::ppIndex, "xsd:int"))
				{	soap_flag_ppIndex1--;
					continue;
				}
			}
			if (soap_flag_ppData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "ppData", &a->ns__PicturePart::ppData, "xsd:string"))
				{	soap_flag_ppData1--;
					continue;
				}
			}
			if (soap_flag_ppCRC1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "ppCRC", &a->ns__PicturePart::ppCRC, "xsd:int"))
				{	soap_flag_ppCRC1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__PicturePart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__PicturePart, SOAP_TYPE_ns__PicturePart, sizeof(ns__PicturePart), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__PicturePart * SOAP_FMAC2 soap_instantiate_ns__PicturePart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__PicturePart(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__PicturePart *p;
	size_t k = sizeof(ns__PicturePart);
	if (n < 0)
	{	p = SOAP_NEW(ns__PicturePart);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__PicturePart, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__PicturePart location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__PicturePart, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__PicturePart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__PicturePart(soap, tag ? tag : "ns:PicturePart", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__PicturePart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__PicturePart(soap, this, tag, type);
}

SOAP_FMAC3 ns__PicturePart * SOAP_FMAC4 soap_get_ns__PicturePart(struct soap *soap, ns__PicturePart *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__PicturePart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Camera::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Camera::cSocket = 0;
	this->ns__Camera::cIP.ns__IP::soap_default(soap);
	this->ns__Camera::cPort = 0;
	this->ns__Camera::cErr.ns__ErrorCode::soap_default(soap);
}

void ns__Camera::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->ns__Camera::cIP.soap_serialize(soap);
	this->ns__Camera::cErr.soap_serialize(soap);
#endif
}

int ns__Camera::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Camera(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Camera(struct soap *soap, const char *tag, int id, const ns__Camera *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Camera), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "cSocket", -1, &a->ns__Camera::cSocket, ""))
		return soap->error;
	if ((a->ns__Camera::cIP).soap_out(soap, "cIP", -1, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "cPort", -1, &a->ns__Camera::cPort, ""))
		return soap->error;
	if ((a->ns__Camera::cErr).soap_out(soap, "cErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Camera::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Camera(soap, tag, this, type);
}

SOAP_FMAC3 ns__Camera * SOAP_FMAC4 soap_in_ns__Camera(struct soap *soap, const char *tag, ns__Camera *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Camera *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Camera, sizeof(ns__Camera), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__Camera)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__Camera *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_cSocket1 = 1;
	size_t soap_flag_cIP1 = 1;
	size_t soap_flag_cPort1 = 1;
	size_t soap_flag_cErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cSocket1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "cSocket", &a->ns__Camera::cSocket, "xsd:int"))
				{	soap_flag_cSocket1--;
					continue;
				}
			}
			if (soap_flag_cIP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__Camera::cIP).soap_in(soap, "cIP", "ns:IP"))
				{	soap_flag_cIP1--;
					continue;
				}
			}
			if (soap_flag_cPort1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "cPort", &a->ns__Camera::cPort, "xsd:int"))
				{	soap_flag_cPort1--;
					continue;
				}
			}
			if (soap_flag_cErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__Camera::cErr).soap_in(soap, "cErr", "ns:ErrorCode"))
				{	soap_flag_cErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cIP1 > 0 || soap_flag_cErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__Camera *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Camera, SOAP_TYPE_ns__Camera, sizeof(ns__Camera), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Camera * SOAP_FMAC2 soap_instantiate_ns__Camera(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Camera(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Camera *p;
	size_t k = sizeof(ns__Camera);
	if (n < 0)
	{	p = SOAP_NEW(ns__Camera);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Camera, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Camera location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Camera, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Camera::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__Camera(soap, tag ? tag : "ns:Camera", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Camera::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Camera(soap, this, tag, type);
}

SOAP_FMAC3 ns__Camera * SOAP_FMAC4 soap_get_ns__Camera(struct soap *soap, ns__Camera *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Camera(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__SensorExtension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__SensorExtension::seName = (enum ns__SensorName)2;
	soap_default_std__vectorTemplateOfxsd__double(soap, &this->ns__SensorExtension::seVal);
}

void ns__SensorExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__double(soap, &this->ns__SensorExtension::seVal);
#endif
}

int ns__SensorExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__SensorExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SensorExtension(struct soap *soap, const char *tag, int id, const ns__SensorExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SensorExtension), type))
		return soap->error;
	if (soap_out_ns__SensorName(soap, "seName", -1, &a->ns__SensorExtension::seName, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__double(soap, "seVal", -1, &a->ns__SensorExtension::seVal, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__SensorExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__SensorExtension(soap, tag, this, type);
}

SOAP_FMAC3 ns__SensorExtension * SOAP_FMAC4 soap_in_ns__SensorExtension(struct soap *soap, const char *tag, ns__SensorExtension *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__SensorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SensorExtension, sizeof(ns__SensorExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__SensorExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__SensorExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_seName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_seName1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns__SensorName(soap, "seName", &a->ns__SensorExtension::seName, "ns:SensorName"))
				{	soap_flag_seName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__double(soap, "seVal", &a->ns__SensorExtension::seVal, "xsd:double"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__SensorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SensorExtension, SOAP_TYPE_ns__SensorExtension, sizeof(ns__SensorExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__SensorExtension * SOAP_FMAC2 soap_instantiate_ns__SensorExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SensorExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__SensorExtension *p;
	size_t k = sizeof(ns__SensorExtension);
	if (n < 0)
	{	p = SOAP_NEW(ns__SensorExtension);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__SensorExtension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__SensorExtension location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SensorExtension, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__SensorExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__SensorExtension(soap, tag ? tag : "ns:SensorExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__SensorExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__SensorExtension(soap, this, tag, type);
}

SOAP_FMAC3 ns__SensorExtension * SOAP_FMAC4 soap_get_ns__SensorExtension(struct soap *soap, ns__SensorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SensorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Sensor::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Sensor::sNkName = "";
	this->ns__Sensor::sVal = 0;
	this->ns__Sensor::sMin = 0;
	this->ns__Sensor::sMax = 0;
	this->ns__Sensor::sType = (enum ns__SensorType)0;
	this->ns__Sensor::sErr.ns__ErrorCode::soap_default(soap);
}

void ns__Sensor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__Sensor::sNkName);
	this->ns__Sensor::sErr.soap_serialize(soap);
#endif
}

int ns__Sensor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Sensor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Sensor(struct soap *soap, const char *tag, int id, const ns__Sensor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Sensor), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "sNkName", -1, &a->ns__Sensor::sNkName, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "sVal", -1, &a->ns__Sensor::sVal, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "sMin", -1, &a->ns__Sensor::sMin, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "sMax", -1, &a->ns__Sensor::sMax, ""))
		return soap->error;
	if (soap_out_ns__SensorType(soap, "sType", -1, &a->ns__Sensor::sType, ""))
		return soap->error;
	if ((a->ns__Sensor::sErr).soap_out(soap, "sErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Sensor::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Sensor(soap, tag, this, type);
}

SOAP_FMAC3 ns__Sensor * SOAP_FMAC4 soap_in_ns__Sensor(struct soap *soap, const char *tag, ns__Sensor *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Sensor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Sensor, sizeof(ns__Sensor), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__Sensor)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__Sensor *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sNkName1 = 1;
	size_t soap_flag_sVal1 = 1;
	size_t soap_flag_sMin1 = 1;
	size_t soap_flag_sMax1 = 1;
	size_t soap_flag_sType1 = 1;
	size_t soap_flag_sErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sNkName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "sNkName", &a->ns__Sensor::sNkName, "xsd:string"))
				{	soap_flag_sNkName1--;
					continue;
				}
			}
			if (soap_flag_sVal1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "sVal", &a->ns__Sensor::sVal, "xsd:double"))
				{	soap_flag_sVal1--;
					continue;
				}
			}
			if (soap_flag_sMin1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "sMin", &a->ns__Sensor::sMin, "xsd:int"))
				{	soap_flag_sMin1--;
					continue;
				}
			}
			if (soap_flag_sMax1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "sMax", &a->ns__Sensor::sMax, "xsd:int"))
				{	soap_flag_sMax1--;
					continue;
				}
			}
			if (soap_flag_sType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns__SensorType(soap, "sType", &a->ns__Sensor::sType, "ns:SensorType"))
				{	soap_flag_sType1--;
					continue;
				}
			}
			if (soap_flag_sErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__Sensor::sErr).soap_in(soap, "sErr", "ns:ErrorCode"))
				{	soap_flag_sErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__Sensor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Sensor, SOAP_TYPE_ns__Sensor, sizeof(ns__Sensor), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Sensor * SOAP_FMAC2 soap_instantiate_ns__Sensor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Sensor(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Sensor *p;
	size_t k = sizeof(ns__Sensor);
	if (n < 0)
	{	p = SOAP_NEW(ns__Sensor);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Sensor, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Sensor location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Sensor, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Sensor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__Sensor(soap, tag ? tag : "ns:Sensor", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Sensor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Sensor(soap, this, tag, type);
}

SOAP_FMAC3 ns__Sensor * SOAP_FMAC4 soap_get_ns__Sensor(struct soap *soap, ns__Sensor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Sensor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__CalibrationList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__Calibration(soap, &this->ns__CalibrationList::clVoltage);
	soap_default_std__vectorTemplateOfns__Calibration(soap, &this->ns__CalibrationList::clAmpere);
	soap_default_std__vectorTemplateOfns__Calibration(soap, &this->ns__CalibrationList::clCosq);
	this->ns__CalibrationList::clErr.ns__ErrorCode::soap_default(soap);
}

void ns__CalibrationList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__Calibration(soap, &this->ns__CalibrationList::clVoltage);
	soap_serialize_std__vectorTemplateOfns__Calibration(soap, &this->ns__CalibrationList::clAmpere);
	soap_serialize_std__vectorTemplateOfns__Calibration(soap, &this->ns__CalibrationList::clCosq);
	this->ns__CalibrationList::clErr.soap_serialize(soap);
#endif
}

int ns__CalibrationList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__CalibrationList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__CalibrationList(struct soap *soap, const char *tag, int id, const ns__CalibrationList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__CalibrationList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__Calibration(soap, "clVoltage", -1, &a->ns__CalibrationList::clVoltage, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__Calibration(soap, "clAmpere", -1, &a->ns__CalibrationList::clAmpere, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__Calibration(soap, "clCosq", -1, &a->ns__CalibrationList::clCosq, ""))
		return soap->error;
	if ((a->ns__CalibrationList::clErr).soap_out(soap, "clErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__CalibrationList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__CalibrationList(soap, tag, this, type);
}

SOAP_FMAC3 ns__CalibrationList * SOAP_FMAC4 soap_in_ns__CalibrationList(struct soap *soap, const char *tag, ns__CalibrationList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__CalibrationList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__CalibrationList, sizeof(ns__CalibrationList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__CalibrationList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__CalibrationList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_clErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__Calibration(soap, "clVoltage", &a->ns__CalibrationList::clVoltage, "ns:Calibration"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__Calibration(soap, "clAmpere", &a->ns__CalibrationList::clAmpere, "ns:Calibration"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__Calibration(soap, "clCosq", &a->ns__CalibrationList::clCosq, "ns:Calibration"))
					continue;
			}
			if (soap_flag_clErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__CalibrationList::clErr).soap_in(soap, "clErr", "ns:ErrorCode"))
				{	soap_flag_clErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_clErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__CalibrationList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__CalibrationList, SOAP_TYPE_ns__CalibrationList, sizeof(ns__CalibrationList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__CalibrationList * SOAP_FMAC2 soap_instantiate_ns__CalibrationList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__CalibrationList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__CalibrationList *p;
	size_t k = sizeof(ns__CalibrationList);
	if (n < 0)
	{	p = SOAP_NEW(ns__CalibrationList);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__CalibrationList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__CalibrationList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__CalibrationList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__CalibrationList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__CalibrationList(soap, tag ? tag : "ns:CalibrationList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__CalibrationList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__CalibrationList(soap, this, tag, type);
}

SOAP_FMAC3 ns__CalibrationList * SOAP_FMAC4 soap_get_ns__CalibrationList(struct soap *soap, ns__CalibrationList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__CalibrationList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__Calibration::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__Calibration::cOffset = 0;
	this->ns__Calibration::cZero = 0;
	this->ns__Calibration::cSpan = 0;
	this->ns__Calibration::cMin = 0;
	this->ns__Calibration::cMax = 0;
}

void ns__Calibration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns__Calibration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__Calibration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Calibration(struct soap *soap, const char *tag, int id, const ns__Calibration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Calibration), type))
		return soap->error;
	if (soap_out_xsd__double(soap, "cOffset", -1, &a->ns__Calibration::cOffset, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "cZero", -1, &a->ns__Calibration::cZero, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "cSpan", -1, &a->ns__Calibration::cSpan, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "cMin", -1, &a->ns__Calibration::cMin, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "cMax", -1, &a->ns__Calibration::cMax, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__Calibration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__Calibration(soap, tag, this, type);
}

SOAP_FMAC3 ns__Calibration * SOAP_FMAC4 soap_in_ns__Calibration(struct soap *soap, const char *tag, ns__Calibration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__Calibration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Calibration, sizeof(ns__Calibration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__Calibration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__Calibration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_cOffset1 = 1;
	size_t soap_flag_cZero1 = 1;
	size_t soap_flag_cSpan1 = 1;
	size_t soap_flag_cMin1 = 1;
	size_t soap_flag_cMax1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cOffset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "cOffset", &a->ns__Calibration::cOffset, "xsd:double"))
				{	soap_flag_cOffset1--;
					continue;
				}
			}
			if (soap_flag_cZero1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "cZero", &a->ns__Calibration::cZero, "xsd:double"))
				{	soap_flag_cZero1--;
					continue;
				}
			}
			if (soap_flag_cSpan1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "cSpan", &a->ns__Calibration::cSpan, "xsd:double"))
				{	soap_flag_cSpan1--;
					continue;
				}
			}
			if (soap_flag_cMin1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "cMin", &a->ns__Calibration::cMin, "xsd:double"))
				{	soap_flag_cMin1--;
					continue;
				}
			}
			if (soap_flag_cMax1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "cMax", &a->ns__Calibration::cMax, "xsd:double"))
				{	soap_flag_cMax1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__Calibration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Calibration, SOAP_TYPE_ns__Calibration, sizeof(ns__Calibration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__Calibration * SOAP_FMAC2 soap_instantiate_ns__Calibration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Calibration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__Calibration *p;
	size_t k = sizeof(ns__Calibration);
	if (n < 0)
	{	p = SOAP_NEW(ns__Calibration);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__Calibration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__Calibration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Calibration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__Calibration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__Calibration(soap, tag ? tag : "ns:Calibration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__Calibration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__Calibration(soap, this, tag, type);
}

SOAP_FMAC3 ns__Calibration * SOAP_FMAC4 soap_get_ns__Calibration(struct soap *soap, ns__Calibration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Calibration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__GPS::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__GPS::gX = 0;
	this->ns__GPS::gY = 0;
}

void ns__GPS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns__GPS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__GPS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GPS(struct soap *soap, const char *tag, int id, const ns__GPS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GPS), type))
		return soap->error;
	if (soap_out_xsd__double(soap, "gX", -1, &a->ns__GPS::gX, ""))
		return soap->error;
	if (soap_out_xsd__double(soap, "gY", -1, &a->ns__GPS::gY, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__GPS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__GPS(soap, tag, this, type);
}

SOAP_FMAC3 ns__GPS * SOAP_FMAC4 soap_in_ns__GPS(struct soap *soap, const char *tag, ns__GPS *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__GPS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GPS, sizeof(ns__GPS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__GPS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__GPS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_gX1 = 1;
	size_t soap_flag_gY1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gX1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "gX", &a->ns__GPS::gX, "xsd:double"))
				{	soap_flag_gX1--;
					continue;
				}
			}
			if (soap_flag_gY1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__double(soap, "gY", &a->ns__GPS::gY, "xsd:double"))
				{	soap_flag_gY1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__GPS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GPS, SOAP_TYPE_ns__GPS, sizeof(ns__GPS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__GPS * SOAP_FMAC2 soap_instantiate_ns__GPS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GPS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__GPS *p;
	size_t k = sizeof(ns__GPS);
	if (n < 0)
	{	p = SOAP_NEW(ns__GPS);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__GPS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__GPS location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GPS, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__GPS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__GPS(soap, tag ? tag : "ns:GPS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__GPS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__GPS(soap, this, tag, type);
}

SOAP_FMAC3 ns__GPS * SOAP_FMAC4 soap_get_ns__GPS(struct soap *soap, ns__GPS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GPS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__IP::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__IP::ip1 = 0;
	this->ns__IP::ip2 = 0;
	this->ns__IP::ip3 = 0;
	this->ns__IP::ip4 = 0;
}

void ns__IP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns__IP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__IP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__IP(struct soap *soap, const char *tag, int id, const ns__IP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__IP), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "ip1", -1, &a->ns__IP::ip1, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "ip2", -1, &a->ns__IP::ip2, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "ip3", -1, &a->ns__IP::ip3, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "ip4", -1, &a->ns__IP::ip4, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__IP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__IP(soap, tag, this, type);
}

SOAP_FMAC3 ns__IP * SOAP_FMAC4 soap_in_ns__IP(struct soap *soap, const char *tag, ns__IP *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__IP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__IP, sizeof(ns__IP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__IP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__IP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ip11 = 1;
	size_t soap_flag_ip21 = 1;
	size_t soap_flag_ip31 = 1;
	size_t soap_flag_ip41 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ip11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "ip1", &a->ns__IP::ip1, "xsd:int"))
				{	soap_flag_ip11--;
					continue;
				}
			}
			if (soap_flag_ip21 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "ip2", &a->ns__IP::ip2, "xsd:int"))
				{	soap_flag_ip21--;
					continue;
				}
			}
			if (soap_flag_ip31 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "ip3", &a->ns__IP::ip3, "xsd:int"))
				{	soap_flag_ip31--;
					continue;
				}
			}
			if (soap_flag_ip41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "ip4", &a->ns__IP::ip4, "xsd:int"))
				{	soap_flag_ip41--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__IP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__IP, SOAP_TYPE_ns__IP, sizeof(ns__IP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__IP * SOAP_FMAC2 soap_instantiate_ns__IP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__IP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__IP *p;
	size_t k = sizeof(ns__IP);
	if (n < 0)
	{	p = SOAP_NEW(ns__IP);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__IP, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__IP location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__IP, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__IP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__IP(soap, tag ? tag : "ns:IP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__IP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__IP(soap, this, tag, type);
}

SOAP_FMAC3 ns__IP * SOAP_FMAC4 soap_get_ns__IP(struct soap *soap, ns__IP *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__IP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__UsersList::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__User(soap, &this->ns__UsersList::ulUsers);
	this->ns__UsersList::ulErr.ns__ErrorCode::soap_default(soap);
}

void ns__UsersList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__User(soap, &this->ns__UsersList::ulUsers);
	this->ns__UsersList::ulErr.soap_serialize(soap);
#endif
}

int ns__UsersList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__UsersList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UsersList(struct soap *soap, const char *tag, int id, const ns__UsersList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UsersList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__User(soap, "ulUsers", -1, &a->ns__UsersList::ulUsers, ""))
		return soap->error;
	if ((a->ns__UsersList::ulErr).soap_out(soap, "ulErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__UsersList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__UsersList(soap, tag, this, type);
}

SOAP_FMAC3 ns__UsersList * SOAP_FMAC4 soap_in_ns__UsersList(struct soap *soap, const char *tag, ns__UsersList *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__UsersList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UsersList, sizeof(ns__UsersList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__UsersList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__UsersList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ulErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__User(soap, "ulUsers", &a->ns__UsersList::ulUsers, "ns:User"))
					continue;
			}
			if (soap_flag_ulErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__UsersList::ulErr).soap_in(soap, "ulErr", "ns:ErrorCode"))
				{	soap_flag_ulErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ulErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__UsersList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UsersList, SOAP_TYPE_ns__UsersList, sizeof(ns__UsersList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__UsersList * SOAP_FMAC2 soap_instantiate_ns__UsersList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__UsersList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__UsersList *p;
	size_t k = sizeof(ns__UsersList);
	if (n < 0)
	{	p = SOAP_NEW(ns__UsersList);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__UsersList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__UsersList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__UsersList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__UsersList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__UsersList(soap, tag ? tag : "ns:UsersList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__UsersList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__UsersList(soap, this, tag, type);
}

SOAP_FMAC3 ns__UsersList * SOAP_FMAC4 soap_get_ns__UsersList(struct soap *soap, ns__UsersList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UsersList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__User::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__User::uId = 0;
	this->ns__User::uName = "";
	this->ns__User::uPassword = "";
	this->ns__User::uRePassword = "";
	this->ns__User::uFirstName = "";
	this->ns__User::uLastName = "";
	this->ns__User::uType = (enum ns__UserType)2;
	this->ns__User::uKey = "";
	this->ns__User::uErr.ns__ErrorCode::soap_default(soap);
}

void ns__User::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__User::uName);
	soap_serialize_xsd__string(soap, &this->ns__User::uPassword);
	soap_serialize_xsd__string(soap, &this->ns__User::uRePassword);
	soap_serialize_xsd__string(soap, &this->ns__User::uFirstName);
	soap_serialize_xsd__string(soap, &this->ns__User::uLastName);
	soap_serialize_xsd__string(soap, &this->ns__User::uKey);
	this->ns__User::uErr.soap_serialize(soap);
#endif
}

int ns__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__User(struct soap *soap, const char *tag, int id, const ns__User *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__User), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "uId", -1, &a->ns__User::uId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "uName", -1, &a->ns__User::uName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "uPassword", -1, &a->ns__User::uPassword, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "uRePassword", -1, &a->ns__User::uRePassword, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "uFirstName", -1, &a->ns__User::uFirstName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "uLastName", -1, &a->ns__User::uLastName, ""))
		return soap->error;
	if (soap_out_ns__UserType(soap, "uType", -1, &a->ns__User::uType, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "uKey", -1, &a->ns__User::uKey, ""))
		return soap->error;
	if ((a->ns__User::uErr).soap_out(soap, "uErr", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__User::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__User(soap, tag, this, type);
}

SOAP_FMAC3 ns__User * SOAP_FMAC4 soap_in_ns__User(struct soap *soap, const char *tag, ns__User *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__User *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__User, sizeof(ns__User), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__User)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__User *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_uId1 = 1;
	size_t soap_flag_uName1 = 1;
	size_t soap_flag_uPassword1 = 1;
	size_t soap_flag_uRePassword1 = 1;
	size_t soap_flag_uFirstName1 = 1;
	size_t soap_flag_uLastName1 = 1;
	size_t soap_flag_uType1 = 1;
	size_t soap_flag_uKey1 = 1;
	size_t soap_flag_uErr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "uId", &a->ns__User::uId, "xsd:int"))
				{	soap_flag_uId1--;
					continue;
				}
			}
			if (soap_flag_uName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "uName", &a->ns__User::uName, "xsd:string"))
				{	soap_flag_uName1--;
					continue;
				}
			}
			if (soap_flag_uPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "uPassword", &a->ns__User::uPassword, "xsd:string"))
				{	soap_flag_uPassword1--;
					continue;
				}
			}
			if (soap_flag_uRePassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "uRePassword", &a->ns__User::uRePassword, "xsd:string"))
				{	soap_flag_uRePassword1--;
					continue;
				}
			}
			if (soap_flag_uFirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "uFirstName", &a->ns__User::uFirstName, "xsd:string"))
				{	soap_flag_uFirstName1--;
					continue;
				}
			}
			if (soap_flag_uLastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "uLastName", &a->ns__User::uLastName, "xsd:string"))
				{	soap_flag_uLastName1--;
					continue;
				}
			}
			if (soap_flag_uType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns__UserType(soap, "uType", &a->ns__User::uType, "ns:UserType"))
				{	soap_flag_uType1--;
					continue;
				}
			}
			if (soap_flag_uKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "uKey", &a->ns__User::uKey, "xsd:string"))
				{	soap_flag_uKey1--;
					continue;
				}
			}
			if (soap_flag_uErr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->ns__User::uErr).soap_in(soap, "uErr", "ns:ErrorCode"))
				{	soap_flag_uErr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uErr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__User, SOAP_TYPE_ns__User, sizeof(ns__User), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__User * SOAP_FMAC2 soap_instantiate_ns__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__User(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__User *p;
	size_t k = sizeof(ns__User);
	if (n < 0)
	{	p = SOAP_NEW(ns__User);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__User, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__User location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__User, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__User(soap, tag ? tag : "ns:User", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__User(soap, this, tag, type);
}

SOAP_FMAC3 ns__User * SOAP_FMAC4 soap_get_ns__User(struct soap *soap, ns__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns__ErrorCode::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns__ErrorCode::eNo = 0;
	this->ns__ErrorCode::eMsg = "";
	this->ns__ErrorCode::eType = (enum ns__SettingLevel)0;
}

void ns__ErrorCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__string(soap, &this->ns__ErrorCode::eMsg);
#endif
}

int ns__ErrorCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns__ErrorCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ErrorCode(struct soap *soap, const char *tag, int id, const ns__ErrorCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ErrorCode), type))
		return soap->error;
	if (soap_out_xsd__int(soap, "eNo", -1, &a->ns__ErrorCode::eNo, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "eMsg", -1, &a->ns__ErrorCode::eMsg, ""))
		return soap->error;
	if (soap_out_ns__SettingLevel(soap, "eType", -1, &a->ns__ErrorCode::eType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns__ErrorCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns__ErrorCode(soap, tag, this, type);
}

SOAP_FMAC3 ns__ErrorCode * SOAP_FMAC4 soap_in_ns__ErrorCode(struct soap *soap, const char *tag, ns__ErrorCode *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns__ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ErrorCode, sizeof(ns__ErrorCode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns__ErrorCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns__ErrorCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_eNo1 = 1;
	size_t soap_flag_eMsg1 = 1;
	size_t soap_flag_eType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eNo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "eNo", &a->ns__ErrorCode::eNo, "xsd:int"))
				{	soap_flag_eNo1--;
					continue;
				}
			}
			if (soap_flag_eMsg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "eMsg", &a->ns__ErrorCode::eMsg, "xsd:string"))
				{	soap_flag_eMsg1--;
					continue;
				}
			}
			if (soap_flag_eType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_ns__SettingLevel(soap, "eType", &a->ns__ErrorCode::eType, "ns:SettingLevel"))
				{	soap_flag_eType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns__ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ErrorCode, SOAP_TYPE_ns__ErrorCode, sizeof(ns__ErrorCode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns__ErrorCode * SOAP_FMAC2 soap_instantiate_ns__ErrorCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ErrorCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns__ErrorCode *p;
	size_t k = sizeof(ns__ErrorCode);
	if (n < 0)
	{	p = SOAP_NEW(ns__ErrorCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(ns__ErrorCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns__ErrorCode location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ErrorCode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns__ErrorCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns__ErrorCode(soap, tag ? tag : "ns:ErrorCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns__ErrorCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns__ErrorCode(soap, this, tag, type);
}

SOAP_FMAC3 ns__ErrorCode * SOAP_FMAC4 soap_get_ns__ErrorCode(struct soap *soap, ns__ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__string, SOAP_TYPE_xsd__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__string(soap, tag ? tag : "xsd:string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ChangeDeviceName(struct soap *soap, struct ns__ChangeDeviceName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	soap_default_xsd__int(soap, &a->deviceSerialNumber);
	soap_default_xsd__string(soap, &a->newCityName);
	soap_default_xsd__string(soap, &a->newLocationName);
	soap_default_xsd__string(soap, &a->newDeviceName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ChangeDeviceName(struct soap *soap, const struct ns__ChangeDeviceName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &a->newCityName);
	soap_serialize_xsd__string(soap, &a->newLocationName);
	soap_serialize_xsd__string(soap, &a->newDeviceName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ChangeDeviceName(struct soap *soap, const char *tag, int id, const struct ns__ChangeDeviceName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ChangeDeviceName), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (soap_out_xsd__int(soap, "deviceSerialNumber", -1, &a->deviceSerialNumber, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newCityName", -1, &a->newCityName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newLocationName", -1, &a->newLocationName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newDeviceName", -1, &a->newDeviceName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ChangeDeviceName * SOAP_FMAC4 soap_in_ns__ChangeDeviceName(struct soap *soap, const char *tag, struct ns__ChangeDeviceName *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_deviceSerialNumber = 1;
	size_t soap_flag_newCityName = 1;
	size_t soap_flag_newLocationName = 1;
	size_t soap_flag_newDeviceName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ChangeDeviceName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ChangeDeviceName, sizeof(struct ns__ChangeDeviceName), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__ChangeDeviceName(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_deviceSerialNumber && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_xsd__int(soap, "deviceSerialNumber", &a->deviceSerialNumber, "xsd:int"))
				{	soap_flag_deviceSerialNumber--;
					continue;
				}
			}
			if (soap_flag_newCityName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "newCityName", &a->newCityName, "xsd:string"))
				{	soap_flag_newCityName--;
					continue;
				}
			}
			if (soap_flag_newLocationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "newLocationName", &a->newLocationName, "xsd:string"))
				{	soap_flag_newLocationName--;
					continue;
				}
			}
			if (soap_flag_newDeviceName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "newDeviceName", &a->newDeviceName, "xsd:string"))
				{	soap_flag_newDeviceName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_deviceSerialNumber > 0 || soap_flag_newCityName > 0 || soap_flag_newLocationName > 0 || soap_flag_newDeviceName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__ChangeDeviceName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ChangeDeviceName, SOAP_TYPE_ns__ChangeDeviceName, sizeof(struct ns__ChangeDeviceName), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__ChangeDeviceName * SOAP_FMAC2 soap_instantiate_ns__ChangeDeviceName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ChangeDeviceName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__ChangeDeviceName *p;
	size_t k = sizeof(struct ns__ChangeDeviceName);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__ChangeDeviceName);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__ChangeDeviceName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__ChangeDeviceName location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ChangeDeviceName, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ChangeDeviceName(struct soap *soap, const struct ns__ChangeDeviceName *a, const char *tag, const char *type)
{
	if (soap_out_ns__ChangeDeviceName(soap, tag ? tag : "ns:ChangeDeviceName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__ChangeDeviceName * SOAP_FMAC4 soap_get_ns__ChangeDeviceName(struct soap *soap, struct ns__ChangeDeviceName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ChangeDeviceName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ChangeLocationName(struct soap *soap, struct ns__ChangeLocationName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	soap_default_xsd__string(soap, &a->oldCityName);
	soap_default_xsd__string(soap, &a->newCityName);
	soap_default_xsd__string(soap, &a->oldLocationName);
	soap_default_xsd__string(soap, &a->newLocationName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ChangeLocationName(struct soap *soap, const struct ns__ChangeLocationName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &a->oldCityName);
	soap_serialize_xsd__string(soap, &a->newCityName);
	soap_serialize_xsd__string(soap, &a->oldLocationName);
	soap_serialize_xsd__string(soap, &a->newLocationName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ChangeLocationName(struct soap *soap, const char *tag, int id, const struct ns__ChangeLocationName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ChangeLocationName), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "oldCityName", -1, &a->oldCityName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newCityName", -1, &a->newCityName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "oldLocationName", -1, &a->oldLocationName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newLocationName", -1, &a->newLocationName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ChangeLocationName * SOAP_FMAC4 soap_in_ns__ChangeLocationName(struct soap *soap, const char *tag, struct ns__ChangeLocationName *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_oldCityName = 1;
	size_t soap_flag_newCityName = 1;
	size_t soap_flag_oldLocationName = 1;
	size_t soap_flag_newLocationName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ChangeLocationName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ChangeLocationName, sizeof(struct ns__ChangeLocationName), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__ChangeLocationName(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_oldCityName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "oldCityName", &a->oldCityName, "xsd:string"))
				{	soap_flag_oldCityName--;
					continue;
				}
			}
			if (soap_flag_newCityName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "newCityName", &a->newCityName, "xsd:string"))
				{	soap_flag_newCityName--;
					continue;
				}
			}
			if (soap_flag_oldLocationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "oldLocationName", &a->oldLocationName, "xsd:string"))
				{	soap_flag_oldLocationName--;
					continue;
				}
			}
			if (soap_flag_newLocationName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "newLocationName", &a->newLocationName, "xsd:string"))
				{	soap_flag_newLocationName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_oldCityName > 0 || soap_flag_newCityName > 0 || soap_flag_oldLocationName > 0 || soap_flag_newLocationName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__ChangeLocationName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ChangeLocationName, SOAP_TYPE_ns__ChangeLocationName, sizeof(struct ns__ChangeLocationName), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__ChangeLocationName * SOAP_FMAC2 soap_instantiate_ns__ChangeLocationName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ChangeLocationName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__ChangeLocationName *p;
	size_t k = sizeof(struct ns__ChangeLocationName);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__ChangeLocationName);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__ChangeLocationName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__ChangeLocationName location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ChangeLocationName, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ChangeLocationName(struct soap *soap, const struct ns__ChangeLocationName *a, const char *tag, const char *type)
{
	if (soap_out_ns__ChangeLocationName(soap, tag ? tag : "ns:ChangeLocationName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__ChangeLocationName * SOAP_FMAC4 soap_get_ns__ChangeLocationName(struct soap *soap, struct ns__ChangeLocationName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ChangeLocationName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__ChangeCityName(struct soap *soap, struct ns__ChangeCityName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	soap_default_xsd__string(soap, &a->oldCityName);
	soap_default_xsd__string(soap, &a->newCityName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__ChangeCityName(struct soap *soap, const struct ns__ChangeCityName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	soap_serialize_xsd__string(soap, &a->oldCityName);
	soap_serialize_xsd__string(soap, &a->newCityName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__ChangeCityName(struct soap *soap, const char *tag, int id, const struct ns__ChangeCityName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__ChangeCityName), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "oldCityName", -1, &a->oldCityName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "newCityName", -1, &a->newCityName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__ChangeCityName * SOAP_FMAC4 soap_in_ns__ChangeCityName(struct soap *soap, const char *tag, struct ns__ChangeCityName *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_oldCityName = 1;
	size_t soap_flag_newCityName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__ChangeCityName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__ChangeCityName, sizeof(struct ns__ChangeCityName), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__ChangeCityName(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_oldCityName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "oldCityName", &a->oldCityName, "xsd:string"))
				{	soap_flag_oldCityName--;
					continue;
				}
			}
			if (soap_flag_newCityName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__string(soap, "newCityName", &a->newCityName, "xsd:string"))
				{	soap_flag_newCityName--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_oldCityName > 0 || soap_flag_newCityName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__ChangeCityName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__ChangeCityName, SOAP_TYPE_ns__ChangeCityName, sizeof(struct ns__ChangeCityName), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__ChangeCityName * SOAP_FMAC2 soap_instantiate_ns__ChangeCityName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__ChangeCityName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__ChangeCityName *p;
	size_t k = sizeof(struct ns__ChangeCityName);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__ChangeCityName);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__ChangeCityName, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__ChangeCityName location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__ChangeCityName, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__ChangeCityName(struct soap *soap, const struct ns__ChangeCityName *a, const char *tag, const char *type)
{
	if (soap_out_ns__ChangeCityName(soap, tag ? tag : "ns:ChangeCityName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__ChangeCityName * SOAP_FMAC4 soap_get_ns__ChangeCityName(struct soap *soap, struct ns__ChangeCityName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__ChangeCityName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetCityAndLocations(struct soap *soap, struct ns__GetCityAndLocations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetCityAndLocations(struct soap *soap, const struct ns__GetCityAndLocations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetCityAndLocations(struct soap *soap, const char *tag, int id, const struct ns__GetCityAndLocations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetCityAndLocations), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetCityAndLocations * SOAP_FMAC4 soap_in_ns__GetCityAndLocations(struct soap *soap, const char *tag, struct ns__GetCityAndLocations *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetCityAndLocations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetCityAndLocations, sizeof(struct ns__GetCityAndLocations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetCityAndLocations(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetCityAndLocations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetCityAndLocations, SOAP_TYPE_ns__GetCityAndLocations, sizeof(struct ns__GetCityAndLocations), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetCityAndLocations * SOAP_FMAC2 soap_instantiate_ns__GetCityAndLocations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetCityAndLocations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetCityAndLocations *p;
	size_t k = sizeof(struct ns__GetCityAndLocations);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetCityAndLocations);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetCityAndLocations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetCityAndLocations location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetCityAndLocations, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetCityAndLocations(struct soap *soap, const struct ns__GetCityAndLocations *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetCityAndLocations(soap, tag ? tag : "ns:GetCityAndLocations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetCityAndLocations * SOAP_FMAC4 soap_get_ns__GetCityAndLocations(struct soap *soap, struct ns__GetCityAndLocations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetCityAndLocations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetServerOptions(struct soap *soap, struct ns__SetServerOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->serverOptions.ns__ServerOptions::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetServerOptions(struct soap *soap, const struct ns__SetServerOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->serverOptions.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetServerOptions(struct soap *soap, const char *tag, int id, const struct ns__SetServerOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetServerOptions), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->serverOptions.soap_out(soap, "serverOptions", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetServerOptions * SOAP_FMAC4 soap_in_ns__SetServerOptions(struct soap *soap, const char *tag, struct ns__SetServerOptions *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_serverOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetServerOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetServerOptions, sizeof(struct ns__SetServerOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SetServerOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_serverOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->serverOptions.soap_in(soap, "serverOptions", "ns:ServerOptions"))
				{	soap_flag_serverOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_serverOptions > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SetServerOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetServerOptions, SOAP_TYPE_ns__SetServerOptions, sizeof(struct ns__SetServerOptions), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SetServerOptions * SOAP_FMAC2 soap_instantiate_ns__SetServerOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetServerOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SetServerOptions *p;
	size_t k = sizeof(struct ns__SetServerOptions);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SetServerOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SetServerOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SetServerOptions location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SetServerOptions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetServerOptions(struct soap *soap, const struct ns__SetServerOptions *a, const char *tag, const char *type)
{
	if (soap_out_ns__SetServerOptions(soap, tag ? tag : "ns:SetServerOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SetServerOptions * SOAP_FMAC4 soap_get_ns__SetServerOptions(struct soap *soap, struct ns__SetServerOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetServerOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetServerOptions(struct soap *soap, struct ns__GetServerOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetServerOptions(struct soap *soap, const struct ns__GetServerOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetServerOptions(struct soap *soap, const char *tag, int id, const struct ns__GetServerOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetServerOptions), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetServerOptions * SOAP_FMAC4 soap_in_ns__GetServerOptions(struct soap *soap, const char *tag, struct ns__GetServerOptions *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetServerOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetServerOptions, sizeof(struct ns__GetServerOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetServerOptions(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetServerOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetServerOptions, SOAP_TYPE_ns__GetServerOptions, sizeof(struct ns__GetServerOptions), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetServerOptions * SOAP_FMAC2 soap_instantiate_ns__GetServerOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetServerOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetServerOptions *p;
	size_t k = sizeof(struct ns__GetServerOptions);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetServerOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetServerOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetServerOptions location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetServerOptions, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetServerOptions(struct soap *soap, const struct ns__GetServerOptions *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetServerOptions(soap, tag ? tag : "ns:GetServerOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetServerOptions * SOAP_FMAC4 soap_get_ns__GetServerOptions(struct soap *soap, struct ns__GetServerOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetServerOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDeviceStatusLog(struct soap *soap, struct ns__GetDeviceStatusLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestStatusLog.ns__DeviceStatus::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDeviceStatusLog(struct soap *soap, const struct ns__GetDeviceStatusLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestStatusLog.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDeviceStatusLog(struct soap *soap, const char *tag, int id, const struct ns__GetDeviceStatusLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetDeviceStatusLog), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestStatusLog.soap_out(soap, "requestStatusLog", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetDeviceStatusLog * SOAP_FMAC4 soap_in_ns__GetDeviceStatusLog(struct soap *soap, const char *tag, struct ns__GetDeviceStatusLog *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestStatusLog = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetDeviceStatusLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetDeviceStatusLog, sizeof(struct ns__GetDeviceStatusLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetDeviceStatusLog(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestStatusLog && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestStatusLog.soap_in(soap, "requestStatusLog", "ns:DeviceStatus"))
				{	soap_flag_requestStatusLog--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestStatusLog > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetDeviceStatusLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetDeviceStatusLog, SOAP_TYPE_ns__GetDeviceStatusLog, sizeof(struct ns__GetDeviceStatusLog), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetDeviceStatusLog * SOAP_FMAC2 soap_instantiate_ns__GetDeviceStatusLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetDeviceStatusLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetDeviceStatusLog *p;
	size_t k = sizeof(struct ns__GetDeviceStatusLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetDeviceStatusLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetDeviceStatusLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetDeviceStatusLog location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetDeviceStatusLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDeviceStatusLog(struct soap *soap, const struct ns__GetDeviceStatusLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetDeviceStatusLog(soap, tag ? tag : "ns:GetDeviceStatusLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetDeviceStatusLog * SOAP_FMAC4 soap_get_ns__GetDeviceStatusLog(struct soap *soap, struct ns__GetDeviceStatusLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetDeviceStatusLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SaveDeviceStatusLog(struct soap *soap, struct ns__SaveDeviceStatusLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestStatusLog.ns__DeviceStatusLog::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SaveDeviceStatusLog(struct soap *soap, const struct ns__SaveDeviceStatusLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestStatusLog.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SaveDeviceStatusLog(struct soap *soap, const char *tag, int id, const struct ns__SaveDeviceStatusLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SaveDeviceStatusLog), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestStatusLog.soap_out(soap, "requestStatusLog", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SaveDeviceStatusLog * SOAP_FMAC4 soap_in_ns__SaveDeviceStatusLog(struct soap *soap, const char *tag, struct ns__SaveDeviceStatusLog *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestStatusLog = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SaveDeviceStatusLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SaveDeviceStatusLog, sizeof(struct ns__SaveDeviceStatusLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SaveDeviceStatusLog(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestStatusLog && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestStatusLog.soap_in(soap, "requestStatusLog", "ns:DeviceStatusLog"))
				{	soap_flag_requestStatusLog--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestStatusLog > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SaveDeviceStatusLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SaveDeviceStatusLog, SOAP_TYPE_ns__SaveDeviceStatusLog, sizeof(struct ns__SaveDeviceStatusLog), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SaveDeviceStatusLog * SOAP_FMAC2 soap_instantiate_ns__SaveDeviceStatusLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SaveDeviceStatusLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SaveDeviceStatusLog *p;
	size_t k = sizeof(struct ns__SaveDeviceStatusLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SaveDeviceStatusLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SaveDeviceStatusLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SaveDeviceStatusLog location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SaveDeviceStatusLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SaveDeviceStatusLog(struct soap *soap, const struct ns__SaveDeviceStatusLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__SaveDeviceStatusLog(soap, tag ? tag : "ns:SaveDeviceStatusLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SaveDeviceStatusLog * SOAP_FMAC4 soap_get_ns__SaveDeviceStatusLog(struct soap *soap, struct ns__SaveDeviceStatusLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SaveDeviceStatusLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserLog(struct soap *soap, struct ns__GetUserLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestReport.ns__ReportRange::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserLog(struct soap *soap, const struct ns__GetUserLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestReport.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserLog(struct soap *soap, const char *tag, int id, const struct ns__GetUserLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetUserLog), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestReport.soap_out(soap, "requestReport", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetUserLog * SOAP_FMAC4 soap_in_ns__GetUserLog(struct soap *soap, const char *tag, struct ns__GetUserLog *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestReport = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetUserLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetUserLog, sizeof(struct ns__GetUserLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetUserLog(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestReport && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestReport.soap_in(soap, "requestReport", "ns:ReportRange"))
				{	soap_flag_requestReport--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestReport > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetUserLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetUserLog, SOAP_TYPE_ns__GetUserLog, sizeof(struct ns__GetUserLog), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetUserLog * SOAP_FMAC2 soap_instantiate_ns__GetUserLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetUserLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetUserLog *p;
	size_t k = sizeof(struct ns__GetUserLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetUserLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetUserLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetUserLog location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetUserLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserLog(struct soap *soap, const struct ns__GetUserLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetUserLog(soap, tag ? tag : "ns:GetUserLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetUserLog * SOAP_FMAC4 soap_get_ns__GetUserLog(struct soap *soap, struct ns__GetUserLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetUserLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserLogResponse(struct soap *soap, struct ns__GetUserLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__UserLog(soap, &a->responseActivityLog);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserLogResponse(struct soap *soap, const struct ns__GetUserLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__UserLog(soap, &a->responseActivityLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserLogResponse(struct soap *soap, const char *tag, int id, const struct ns__GetUserLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetUserLogResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__UserLog(soap, "responseActivityLog", -1, &a->responseActivityLog, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetUserLogResponse * SOAP_FMAC4 soap_in_ns__GetUserLogResponse(struct soap *soap, const char *tag, struct ns__GetUserLogResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetUserLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetUserLogResponse, sizeof(struct ns__GetUserLogResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetUserLogResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__UserLog(soap, "responseActivityLog", &a->responseActivityLog, "ns:UserLog"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->responseActivityLog.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetUserLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetUserLogResponse, SOAP_TYPE_ns__GetUserLogResponse, sizeof(struct ns__GetUserLogResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetUserLogResponse * SOAP_FMAC2 soap_instantiate_ns__GetUserLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetUserLogResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetUserLogResponse *p;
	size_t k = sizeof(struct ns__GetUserLogResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetUserLogResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetUserLogResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetUserLogResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetUserLogResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserLogResponse(struct soap *soap, const struct ns__GetUserLogResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetUserLogResponse(soap, tag ? tag : "ns:GetUserLogResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetUserLogResponse * SOAP_FMAC4 soap_get_ns__GetUserLogResponse(struct soap *soap, struct ns__GetUserLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetUserLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SaveUserLog(struct soap *soap, struct ns__SaveUserLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestActivityLog.ns__UserLog::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SaveUserLog(struct soap *soap, const struct ns__SaveUserLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestActivityLog.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SaveUserLog(struct soap *soap, const char *tag, int id, const struct ns__SaveUserLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SaveUserLog), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestActivityLog.soap_out(soap, "requestActivityLog", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SaveUserLog * SOAP_FMAC4 soap_in_ns__SaveUserLog(struct soap *soap, const char *tag, struct ns__SaveUserLog *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestActivityLog = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SaveUserLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SaveUserLog, sizeof(struct ns__SaveUserLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SaveUserLog(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestActivityLog && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestActivityLog.soap_in(soap, "requestActivityLog", "ns:UserLog"))
				{	soap_flag_requestActivityLog--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestActivityLog > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SaveUserLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SaveUserLog, SOAP_TYPE_ns__SaveUserLog, sizeof(struct ns__SaveUserLog), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SaveUserLog * SOAP_FMAC2 soap_instantiate_ns__SaveUserLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SaveUserLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SaveUserLog *p;
	size_t k = sizeof(struct ns__SaveUserLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SaveUserLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SaveUserLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SaveUserLog location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SaveUserLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SaveUserLog(struct soap *soap, const struct ns__SaveUserLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__SaveUserLog(soap, tag ? tag : "ns:SaveUserLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SaveUserLog * SOAP_FMAC4 soap_get_ns__SaveUserLog(struct soap *soap, struct ns__SaveUserLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SaveUserLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetActivityLog(struct soap *soap, struct ns__GetActivityLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestReport.ns__ReportRange::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetActivityLog(struct soap *soap, const struct ns__GetActivityLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestReport.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetActivityLog(struct soap *soap, const char *tag, int id, const struct ns__GetActivityLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetActivityLog), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestReport.soap_out(soap, "requestReport", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetActivityLog * SOAP_FMAC4 soap_in_ns__GetActivityLog(struct soap *soap, const char *tag, struct ns__GetActivityLog *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestReport = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetActivityLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetActivityLog, sizeof(struct ns__GetActivityLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetActivityLog(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestReport && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestReport.soap_in(soap, "requestReport", "ns:ReportRange"))
				{	soap_flag_requestReport--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestReport > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetActivityLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetActivityLog, SOAP_TYPE_ns__GetActivityLog, sizeof(struct ns__GetActivityLog), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetActivityLog * SOAP_FMAC2 soap_instantiate_ns__GetActivityLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetActivityLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetActivityLog *p;
	size_t k = sizeof(struct ns__GetActivityLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetActivityLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetActivityLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetActivityLog location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetActivityLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetActivityLog(struct soap *soap, const struct ns__GetActivityLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetActivityLog(soap, tag ? tag : "ns:GetActivityLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetActivityLog * SOAP_FMAC4 soap_get_ns__GetActivityLog(struct soap *soap, struct ns__GetActivityLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetActivityLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetActivityLogResponse(struct soap *soap, struct ns__GetActivityLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__ActivityLog(soap, &a->responseActivityLog);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetActivityLogResponse(struct soap *soap, const struct ns__GetActivityLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__ActivityLog(soap, &a->responseActivityLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetActivityLogResponse(struct soap *soap, const char *tag, int id, const struct ns__GetActivityLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetActivityLogResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__ActivityLog(soap, "responseActivityLog", -1, &a->responseActivityLog, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetActivityLogResponse * SOAP_FMAC4 soap_in_ns__GetActivityLogResponse(struct soap *soap, const char *tag, struct ns__GetActivityLogResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetActivityLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetActivityLogResponse, sizeof(struct ns__GetActivityLogResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetActivityLogResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__ActivityLog(soap, "responseActivityLog", &a->responseActivityLog, "ns:ActivityLog"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->responseActivityLog.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetActivityLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetActivityLogResponse, SOAP_TYPE_ns__GetActivityLogResponse, sizeof(struct ns__GetActivityLogResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetActivityLogResponse * SOAP_FMAC2 soap_instantiate_ns__GetActivityLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetActivityLogResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetActivityLogResponse *p;
	size_t k = sizeof(struct ns__GetActivityLogResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetActivityLogResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetActivityLogResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetActivityLogResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetActivityLogResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetActivityLogResponse(struct soap *soap, const struct ns__GetActivityLogResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetActivityLogResponse(soap, tag ? tag : "ns:GetActivityLogResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetActivityLogResponse * SOAP_FMAC4 soap_get_ns__GetActivityLogResponse(struct soap *soap, struct ns__GetActivityLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetActivityLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SaveActivityLog(struct soap *soap, struct ns__SaveActivityLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestActivityLog.ns__ActivityLog::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SaveActivityLog(struct soap *soap, const struct ns__SaveActivityLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestActivityLog.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SaveActivityLog(struct soap *soap, const char *tag, int id, const struct ns__SaveActivityLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SaveActivityLog), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestActivityLog.soap_out(soap, "requestActivityLog", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SaveActivityLog * SOAP_FMAC4 soap_in_ns__SaveActivityLog(struct soap *soap, const char *tag, struct ns__SaveActivityLog *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestActivityLog = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SaveActivityLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SaveActivityLog, sizeof(struct ns__SaveActivityLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SaveActivityLog(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestActivityLog && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestActivityLog.soap_in(soap, "requestActivityLog", "ns:ActivityLog"))
				{	soap_flag_requestActivityLog--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestActivityLog > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SaveActivityLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SaveActivityLog, SOAP_TYPE_ns__SaveActivityLog, sizeof(struct ns__SaveActivityLog), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SaveActivityLog * SOAP_FMAC2 soap_instantiate_ns__SaveActivityLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SaveActivityLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SaveActivityLog *p;
	size_t k = sizeof(struct ns__SaveActivityLog);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SaveActivityLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SaveActivityLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SaveActivityLog location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SaveActivityLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SaveActivityLog(struct soap *soap, const struct ns__SaveActivityLog *a, const char *tag, const char *type)
{
	if (soap_out_ns__SaveActivityLog(soap, tag ? tag : "ns:SaveActivityLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SaveActivityLog * SOAP_FMAC4 soap_get_ns__SaveActivityLog(struct soap *soap, struct ns__SaveActivityLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SaveActivityLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserDevices(struct soap *soap, struct ns__GetUserDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestSelectedUser.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserDevices(struct soap *soap, const struct ns__GetUserDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestSelectedUser.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserDevices(struct soap *soap, const char *tag, int id, const struct ns__GetUserDevices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetUserDevices), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestSelectedUser.soap_out(soap, "requestSelectedUser", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetUserDevices * SOAP_FMAC4 soap_in_ns__GetUserDevices(struct soap *soap, const char *tag, struct ns__GetUserDevices *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestSelectedUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetUserDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetUserDevices, sizeof(struct ns__GetUserDevices), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetUserDevices(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestSelectedUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestSelectedUser.soap_in(soap, "requestSelectedUser", "ns:User"))
				{	soap_flag_requestSelectedUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestSelectedUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetUserDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetUserDevices, SOAP_TYPE_ns__GetUserDevices, sizeof(struct ns__GetUserDevices), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetUserDevices * SOAP_FMAC2 soap_instantiate_ns__GetUserDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetUserDevices(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetUserDevices *p;
	size_t k = sizeof(struct ns__GetUserDevices);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetUserDevices);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetUserDevices, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetUserDevices location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetUserDevices, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserDevices(struct soap *soap, const struct ns__GetUserDevices *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetUserDevices(soap, tag ? tag : "ns:GetUserDevices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetUserDevices * SOAP_FMAC4 soap_get_ns__GetUserDevices(struct soap *soap, struct ns__GetUserDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetUserDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeleteDeviceFromUser(struct soap *soap, struct ns__DeleteDeviceFromUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestUserDevice.ns__UserDevice::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DeleteDeviceFromUser(struct soap *soap, const struct ns__DeleteDeviceFromUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestUserDevice.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeleteDeviceFromUser(struct soap *soap, const char *tag, int id, const struct ns__DeleteDeviceFromUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeleteDeviceFromUser), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestUserDevice.soap_out(soap, "requestUserDevice", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__DeleteDeviceFromUser * SOAP_FMAC4 soap_in_ns__DeleteDeviceFromUser(struct soap *soap, const char *tag, struct ns__DeleteDeviceFromUser *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestUserDevice = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__DeleteDeviceFromUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeleteDeviceFromUser, sizeof(struct ns__DeleteDeviceFromUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__DeleteDeviceFromUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestUserDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUserDevice.soap_in(soap, "requestUserDevice", "ns:UserDevice"))
				{	soap_flag_requestUserDevice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestUserDevice > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__DeleteDeviceFromUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeleteDeviceFromUser, SOAP_TYPE_ns__DeleteDeviceFromUser, sizeof(struct ns__DeleteDeviceFromUser), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__DeleteDeviceFromUser * SOAP_FMAC2 soap_instantiate_ns__DeleteDeviceFromUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeleteDeviceFromUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__DeleteDeviceFromUser *p;
	size_t k = sizeof(struct ns__DeleteDeviceFromUser);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__DeleteDeviceFromUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__DeleteDeviceFromUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__DeleteDeviceFromUser location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeleteDeviceFromUser, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeleteDeviceFromUser(struct soap *soap, const struct ns__DeleteDeviceFromUser *a, const char *tag, const char *type)
{
	if (soap_out_ns__DeleteDeviceFromUser(soap, tag ? tag : "ns:DeleteDeviceFromUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__DeleteDeviceFromUser * SOAP_FMAC4 soap_get_ns__DeleteDeviceFromUser(struct soap *soap, struct ns__DeleteDeviceFromUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeleteDeviceFromUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AssignDeviceToUser(struct soap *soap, struct ns__AssignDeviceToUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestUserDevice.ns__UserDevice::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AssignDeviceToUser(struct soap *soap, const struct ns__AssignDeviceToUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestUserDevice.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AssignDeviceToUser(struct soap *soap, const char *tag, int id, const struct ns__AssignDeviceToUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AssignDeviceToUser), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestUserDevice.soap_out(soap, "requestUserDevice", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__AssignDeviceToUser * SOAP_FMAC4 soap_in_ns__AssignDeviceToUser(struct soap *soap, const char *tag, struct ns__AssignDeviceToUser *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestUserDevice = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__AssignDeviceToUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AssignDeviceToUser, sizeof(struct ns__AssignDeviceToUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__AssignDeviceToUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestUserDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUserDevice.soap_in(soap, "requestUserDevice", "ns:UserDevice"))
				{	soap_flag_requestUserDevice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestUserDevice > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__AssignDeviceToUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AssignDeviceToUser, SOAP_TYPE_ns__AssignDeviceToUser, sizeof(struct ns__AssignDeviceToUser), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__AssignDeviceToUser * SOAP_FMAC2 soap_instantiate_ns__AssignDeviceToUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AssignDeviceToUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__AssignDeviceToUser *p;
	size_t k = sizeof(struct ns__AssignDeviceToUser);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__AssignDeviceToUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__AssignDeviceToUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__AssignDeviceToUser location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__AssignDeviceToUser, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AssignDeviceToUser(struct soap *soap, const struct ns__AssignDeviceToUser *a, const char *tag, const char *type)
{
	if (soap_out_ns__AssignDeviceToUser(soap, tag ? tag : "ns:AssignDeviceToUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__AssignDeviceToUser * SOAP_FMAC4 soap_get_ns__AssignDeviceToUser(struct soap *soap, struct ns__AssignDeviceToUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AssignDeviceToUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeleteUser(struct soap *soap, struct ns__DeleteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestDeleteUser.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DeleteUser(struct soap *soap, const struct ns__DeleteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestDeleteUser.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeleteUser(struct soap *soap, const char *tag, int id, const struct ns__DeleteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeleteUser), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestDeleteUser.soap_out(soap, "requestDeleteUser", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__DeleteUser * SOAP_FMAC4 soap_in_ns__DeleteUser(struct soap *soap, const char *tag, struct ns__DeleteUser *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestDeleteUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__DeleteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeleteUser, sizeof(struct ns__DeleteUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__DeleteUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestDeleteUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestDeleteUser.soap_in(soap, "requestDeleteUser", "ns:User"))
				{	soap_flag_requestDeleteUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestDeleteUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__DeleteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeleteUser, SOAP_TYPE_ns__DeleteUser, sizeof(struct ns__DeleteUser), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__DeleteUser * SOAP_FMAC2 soap_instantiate_ns__DeleteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeleteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__DeleteUser *p;
	size_t k = sizeof(struct ns__DeleteUser);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__DeleteUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__DeleteUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__DeleteUser location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeleteUser, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeleteUser(struct soap *soap, const struct ns__DeleteUser *a, const char *tag, const char *type)
{
	if (soap_out_ns__DeleteUser(soap, tag ? tag : "ns:DeleteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__DeleteUser * SOAP_FMAC4 soap_get_ns__DeleteUser(struct soap *soap, struct ns__DeleteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeleteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__UpdateUser(struct soap *soap, struct ns__UpdateUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestNewUser.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__UpdateUser(struct soap *soap, const struct ns__UpdateUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestNewUser.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__UpdateUser(struct soap *soap, const char *tag, int id, const struct ns__UpdateUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__UpdateUser), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestNewUser.soap_out(soap, "requestNewUser", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__UpdateUser * SOAP_FMAC4 soap_in_ns__UpdateUser(struct soap *soap, const char *tag, struct ns__UpdateUser *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestNewUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__UpdateUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__UpdateUser, sizeof(struct ns__UpdateUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__UpdateUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestNewUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestNewUser.soap_in(soap, "requestNewUser", "ns:User"))
				{	soap_flag_requestNewUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestNewUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__UpdateUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__UpdateUser, SOAP_TYPE_ns__UpdateUser, sizeof(struct ns__UpdateUser), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__UpdateUser * SOAP_FMAC2 soap_instantiate_ns__UpdateUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__UpdateUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__UpdateUser *p;
	size_t k = sizeof(struct ns__UpdateUser);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__UpdateUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__UpdateUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__UpdateUser location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__UpdateUser, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__UpdateUser(struct soap *soap, const struct ns__UpdateUser *a, const char *tag, const char *type)
{
	if (soap_out_ns__UpdateUser(soap, tag ? tag : "ns:UpdateUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__UpdateUser * SOAP_FMAC4 soap_get_ns__UpdateUser(struct soap *soap, struct ns__UpdateUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__UpdateUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AddUser(struct soap *soap, struct ns__AddUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestNewUser.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AddUser(struct soap *soap, const struct ns__AddUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestNewUser.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AddUser(struct soap *soap, const char *tag, int id, const struct ns__AddUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__AddUser), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestNewUser.soap_out(soap, "requestNewUser", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__AddUser * SOAP_FMAC4 soap_in_ns__AddUser(struct soap *soap, const char *tag, struct ns__AddUser *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestNewUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__AddUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__AddUser, sizeof(struct ns__AddUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__AddUser(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestNewUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestNewUser.soap_in(soap, "requestNewUser", "ns:User"))
				{	soap_flag_requestNewUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestNewUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__AddUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__AddUser, SOAP_TYPE_ns__AddUser, sizeof(struct ns__AddUser), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__AddUser * SOAP_FMAC2 soap_instantiate_ns__AddUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__AddUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__AddUser *p;
	size_t k = sizeof(struct ns__AddUser);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__AddUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__AddUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__AddUser location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__AddUser, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AddUser(struct soap *soap, const struct ns__AddUser *a, const char *tag, const char *type)
{
	if (soap_out_ns__AddUser(soap, tag ? tag : "ns:AddUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__AddUser * SOAP_FMAC4 soap_get_ns__AddUser(struct soap *soap, struct ns__AddUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__AddUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUsersList(struct soap *soap, struct ns__GetUsersList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUsersList(struct soap *soap, const struct ns__GetUsersList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUsersList(struct soap *soap, const char *tag, int id, const struct ns__GetUsersList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetUsersList), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetUsersList * SOAP_FMAC4 soap_in_ns__GetUsersList(struct soap *soap, const char *tag, struct ns__GetUsersList *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetUsersList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetUsersList, sizeof(struct ns__GetUsersList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetUsersList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetUsersList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetUsersList, SOAP_TYPE_ns__GetUsersList, sizeof(struct ns__GetUsersList), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetUsersList * SOAP_FMAC2 soap_instantiate_ns__GetUsersList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetUsersList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetUsersList *p;
	size_t k = sizeof(struct ns__GetUsersList);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetUsersList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetUsersList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetUsersList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetUsersList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUsersList(struct soap *soap, const struct ns__GetUsersList *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetUsersList(soap, tag ? tag : "ns:GetUsersList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetUsersList * SOAP_FMAC4 soap_get_ns__GetUsersList(struct soap *soap, struct ns__GetUsersList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetUsersList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetUserDeviceList(struct soap *soap, struct ns__GetUserDeviceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetUserDeviceList(struct soap *soap, const struct ns__GetUserDeviceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetUserDeviceList(struct soap *soap, const char *tag, int id, const struct ns__GetUserDeviceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetUserDeviceList), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetUserDeviceList * SOAP_FMAC4 soap_in_ns__GetUserDeviceList(struct soap *soap, const char *tag, struct ns__GetUserDeviceList *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetUserDeviceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetUserDeviceList, sizeof(struct ns__GetUserDeviceList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetUserDeviceList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetUserDeviceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetUserDeviceList, SOAP_TYPE_ns__GetUserDeviceList, sizeof(struct ns__GetUserDeviceList), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetUserDeviceList * SOAP_FMAC2 soap_instantiate_ns__GetUserDeviceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetUserDeviceList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetUserDeviceList *p;
	size_t k = sizeof(struct ns__GetUserDeviceList);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetUserDeviceList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetUserDeviceList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetUserDeviceList location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetUserDeviceList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetUserDeviceList(struct soap *soap, const struct ns__GetUserDeviceList *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetUserDeviceList(soap, tag ? tag : "ns:GetUserDeviceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetUserDeviceList * SOAP_FMAC4 soap_get_ns__GetUserDeviceList(struct soap *soap, struct ns__GetUserDeviceList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetUserDeviceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Login(struct soap *soap, struct ns__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Login(struct soap *soap, const struct ns__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Login(struct soap *soap, const char *tag, int id, const struct ns__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Login), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Login * SOAP_FMAC4 soap_in_ns__Login(struct soap *soap, const char *tag, struct ns__Login *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Login, sizeof(struct ns__Login), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__Login(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Login, SOAP_TYPE_ns__Login, sizeof(struct ns__Login), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__Login * SOAP_FMAC2 soap_instantiate_ns__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__Login *p;
	size_t k = sizeof(struct ns__Login);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__Login);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__Login, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__Login location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Login, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Login(struct soap *soap, const struct ns__Login *a, const char *tag, const char *type)
{
	if (soap_out_ns__Login(soap, tag ? tag : "ns:Login", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Login * SOAP_FMAC4 soap_get_ns__Login(struct soap *soap, struct ns__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDeviceCalibration(struct soap *soap, struct ns__GetDeviceCalibration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestDevice.ns__Device::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDeviceCalibration(struct soap *soap, const struct ns__GetDeviceCalibration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestDevice.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDeviceCalibration(struct soap *soap, const char *tag, int id, const struct ns__GetDeviceCalibration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetDeviceCalibration), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestDevice.soap_out(soap, "requestDevice", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetDeviceCalibration * SOAP_FMAC4 soap_in_ns__GetDeviceCalibration(struct soap *soap, const char *tag, struct ns__GetDeviceCalibration *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestDevice = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetDeviceCalibration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetDeviceCalibration, sizeof(struct ns__GetDeviceCalibration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetDeviceCalibration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestDevice.soap_in(soap, "requestDevice", "ns:Device"))
				{	soap_flag_requestDevice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestDevice > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetDeviceCalibration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetDeviceCalibration, SOAP_TYPE_ns__GetDeviceCalibration, sizeof(struct ns__GetDeviceCalibration), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetDeviceCalibration * SOAP_FMAC2 soap_instantiate_ns__GetDeviceCalibration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetDeviceCalibration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetDeviceCalibration *p;
	size_t k = sizeof(struct ns__GetDeviceCalibration);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetDeviceCalibration);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetDeviceCalibration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetDeviceCalibration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetDeviceCalibration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDeviceCalibration(struct soap *soap, const struct ns__GetDeviceCalibration *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetDeviceCalibration(soap, tag ? tag : "ns:GetDeviceCalibration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetDeviceCalibration * SOAP_FMAC4 soap_get_ns__GetDeviceCalibration(struct soap *soap, struct ns__GetDeviceCalibration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetDeviceCalibration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetDeviceCalibration(struct soap *soap, struct ns__SetDeviceCalibration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestDevice.ns__Device::soap_default(soap);
	a->requestCalibrationList.ns__CalibrationList::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetDeviceCalibration(struct soap *soap, const struct ns__SetDeviceCalibration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestDevice.soap_serialize(soap);
	a->requestCalibrationList.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetDeviceCalibration(struct soap *soap, const char *tag, int id, const struct ns__SetDeviceCalibration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetDeviceCalibration), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestDevice.soap_out(soap, "requestDevice", -1, ""))
		return soap->error;
	if (a->requestCalibrationList.soap_out(soap, "requestCalibrationList", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetDeviceCalibration * SOAP_FMAC4 soap_in_ns__SetDeviceCalibration(struct soap *soap, const char *tag, struct ns__SetDeviceCalibration *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestDevice = 1;
	size_t soap_flag_requestCalibrationList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetDeviceCalibration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetDeviceCalibration, sizeof(struct ns__SetDeviceCalibration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SetDeviceCalibration(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestDevice.soap_in(soap, "requestDevice", "ns:Device"))
				{	soap_flag_requestDevice--;
					continue;
				}
			}
			if (soap_flag_requestCalibrationList && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestCalibrationList.soap_in(soap, "requestCalibrationList", "ns:CalibrationList"))
				{	soap_flag_requestCalibrationList--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestDevice > 0 || soap_flag_requestCalibrationList > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SetDeviceCalibration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetDeviceCalibration, SOAP_TYPE_ns__SetDeviceCalibration, sizeof(struct ns__SetDeviceCalibration), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SetDeviceCalibration * SOAP_FMAC2 soap_instantiate_ns__SetDeviceCalibration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetDeviceCalibration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SetDeviceCalibration *p;
	size_t k = sizeof(struct ns__SetDeviceCalibration);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SetDeviceCalibration);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SetDeviceCalibration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SetDeviceCalibration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SetDeviceCalibration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetDeviceCalibration(struct soap *soap, const struct ns__SetDeviceCalibration *a, const char *tag, const char *type)
{
	if (soap_out_ns__SetDeviceCalibration(soap, tag ? tag : "ns:SetDeviceCalibration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SetDeviceCalibration * SOAP_FMAC4 soap_get_ns__SetDeviceCalibration(struct soap *soap, struct ns__SetDeviceCalibration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetDeviceCalibration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeleteDevices(struct soap *soap, struct ns__DeleteDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	soap_default_std__vectorTemplateOfns__Device(soap, &a->requestDeviceList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DeleteDevices(struct soap *soap, const struct ns__DeleteDevices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	soap_serialize_std__vectorTemplateOfns__Device(soap, &a->requestDeviceList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeleteDevices(struct soap *soap, const char *tag, int id, const struct ns__DeleteDevices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeleteDevices), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__Device(soap, "requestDeviceList", -1, &a->requestDeviceList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__DeleteDevices * SOAP_FMAC4 soap_in_ns__DeleteDevices(struct soap *soap, const char *tag, struct ns__DeleteDevices *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__DeleteDevices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeleteDevices, sizeof(struct ns__DeleteDevices), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__DeleteDevices(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__Device(soap, "requestDeviceList", &a->requestDeviceList, "ns:Device"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__DeleteDevices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeleteDevices, SOAP_TYPE_ns__DeleteDevices, sizeof(struct ns__DeleteDevices), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__DeleteDevices * SOAP_FMAC2 soap_instantiate_ns__DeleteDevices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeleteDevices(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__DeleteDevices *p;
	size_t k = sizeof(struct ns__DeleteDevices);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__DeleteDevices);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__DeleteDevices, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__DeleteDevices location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeleteDevices, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeleteDevices(struct soap *soap, const struct ns__DeleteDevices *a, const char *tag, const char *type)
{
	if (soap_out_ns__DeleteDevices(soap, tag ? tag : "ns:DeleteDevices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__DeleteDevices * SOAP_FMAC4 soap_get_ns__DeleteDevices(struct soap *soap, struct ns__DeleteDevices *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeleteDevices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DeleteDevicesResponse(struct soap *soap, struct ns__DeleteDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__ErrorCode(soap, &a->responseError);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DeleteDevicesResponse(struct soap *soap, const struct ns__DeleteDevicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__ErrorCode(soap, &a->responseError);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DeleteDevicesResponse(struct soap *soap, const char *tag, int id, const struct ns__DeleteDevicesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__DeleteDevicesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__ErrorCode(soap, "responseError", -1, &a->responseError, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__DeleteDevicesResponse * SOAP_FMAC4 soap_in_ns__DeleteDevicesResponse(struct soap *soap, const char *tag, struct ns__DeleteDevicesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__DeleteDevicesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__DeleteDevicesResponse, sizeof(struct ns__DeleteDevicesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__DeleteDevicesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__ErrorCode(soap, "responseError", &a->responseError, "ns:ErrorCode"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->responseError.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__DeleteDevicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__DeleteDevicesResponse, SOAP_TYPE_ns__DeleteDevicesResponse, sizeof(struct ns__DeleteDevicesResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__DeleteDevicesResponse * SOAP_FMAC2 soap_instantiate_ns__DeleteDevicesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__DeleteDevicesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__DeleteDevicesResponse *p;
	size_t k = sizeof(struct ns__DeleteDevicesResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__DeleteDevicesResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__DeleteDevicesResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__DeleteDevicesResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__DeleteDevicesResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DeleteDevicesResponse(struct soap *soap, const struct ns__DeleteDevicesResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__DeleteDevicesResponse(soap, tag ? tag : "ns:DeleteDevicesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__DeleteDevicesResponse * SOAP_FMAC4 soap_get_ns__DeleteDevicesResponse(struct soap *soap, struct ns__DeleteDevicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__DeleteDevicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetAllDeviceSetting(struct soap *soap, struct ns__SetAllDeviceSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	soap_default_std__vectorTemplateOfns__Device(soap, &a->requestDevice);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetAllDeviceSetting(struct soap *soap, const struct ns__SetAllDeviceSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	soap_serialize_std__vectorTemplateOfns__Device(soap, &a->requestDevice);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetAllDeviceSetting(struct soap *soap, const char *tag, int id, const struct ns__SetAllDeviceSetting *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetAllDeviceSetting), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__Device(soap, "requestDevice", -1, &a->requestDevice, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetAllDeviceSetting * SOAP_FMAC4 soap_in_ns__SetAllDeviceSetting(struct soap *soap, const char *tag, struct ns__SetAllDeviceSetting *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetAllDeviceSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetAllDeviceSetting, sizeof(struct ns__SetAllDeviceSetting), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SetAllDeviceSetting(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__Device(soap, "requestDevice", &a->requestDevice, "ns:Device"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SetAllDeviceSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetAllDeviceSetting, SOAP_TYPE_ns__SetAllDeviceSetting, sizeof(struct ns__SetAllDeviceSetting), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SetAllDeviceSetting * SOAP_FMAC2 soap_instantiate_ns__SetAllDeviceSetting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetAllDeviceSetting(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SetAllDeviceSetting *p;
	size_t k = sizeof(struct ns__SetAllDeviceSetting);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SetAllDeviceSetting);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SetAllDeviceSetting, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SetAllDeviceSetting location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SetAllDeviceSetting, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetAllDeviceSetting(struct soap *soap, const struct ns__SetAllDeviceSetting *a, const char *tag, const char *type)
{
	if (soap_out_ns__SetAllDeviceSetting(soap, tag ? tag : "ns:SetAllDeviceSetting", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SetAllDeviceSetting * SOAP_FMAC4 soap_get_ns__SetAllDeviceSetting(struct soap *soap, struct ns__SetAllDeviceSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetAllDeviceSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetAllDeviceSettingResponse(struct soap *soap, struct ns__SetAllDeviceSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__ErrorCode(soap, &a->responseError);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetAllDeviceSettingResponse(struct soap *soap, const struct ns__SetAllDeviceSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__ErrorCode(soap, &a->responseError);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetAllDeviceSettingResponse(struct soap *soap, const char *tag, int id, const struct ns__SetAllDeviceSettingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetAllDeviceSettingResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__ErrorCode(soap, "responseError", -1, &a->responseError, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetAllDeviceSettingResponse * SOAP_FMAC4 soap_in_ns__SetAllDeviceSettingResponse(struct soap *soap, const char *tag, struct ns__SetAllDeviceSettingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetAllDeviceSettingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetAllDeviceSettingResponse, sizeof(struct ns__SetAllDeviceSettingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SetAllDeviceSettingResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__ErrorCode(soap, "responseError", &a->responseError, "ns:ErrorCode"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->responseError.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SetAllDeviceSettingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetAllDeviceSettingResponse, SOAP_TYPE_ns__SetAllDeviceSettingResponse, sizeof(struct ns__SetAllDeviceSettingResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SetAllDeviceSettingResponse * SOAP_FMAC2 soap_instantiate_ns__SetAllDeviceSettingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetAllDeviceSettingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SetAllDeviceSettingResponse *p;
	size_t k = sizeof(struct ns__SetAllDeviceSettingResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SetAllDeviceSettingResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SetAllDeviceSettingResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SetAllDeviceSettingResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SetAllDeviceSettingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetAllDeviceSettingResponse(struct soap *soap, const struct ns__SetAllDeviceSettingResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__SetAllDeviceSettingResponse(soap, tag ? tag : "ns:SetAllDeviceSettingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SetAllDeviceSettingResponse * SOAP_FMAC4 soap_get_ns__SetAllDeviceSettingResponse(struct soap *soap, struct ns__SetAllDeviceSettingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetAllDeviceSettingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetDeviceSettingSMS(struct soap *soap, struct ns__SetDeviceSettingSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestDevice.ns__Device::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetDeviceSettingSMS(struct soap *soap, const struct ns__SetDeviceSettingSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestDevice.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetDeviceSettingSMS(struct soap *soap, const char *tag, int id, const struct ns__SetDeviceSettingSMS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetDeviceSettingSMS), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestDevice.soap_out(soap, "requestDevice", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetDeviceSettingSMS * SOAP_FMAC4 soap_in_ns__SetDeviceSettingSMS(struct soap *soap, const char *tag, struct ns__SetDeviceSettingSMS *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestDevice = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetDeviceSettingSMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetDeviceSettingSMS, sizeof(struct ns__SetDeviceSettingSMS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SetDeviceSettingSMS(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestDevice.soap_in(soap, "requestDevice", "ns:Device"))
				{	soap_flag_requestDevice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestDevice > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SetDeviceSettingSMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetDeviceSettingSMS, SOAP_TYPE_ns__SetDeviceSettingSMS, sizeof(struct ns__SetDeviceSettingSMS), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SetDeviceSettingSMS * SOAP_FMAC2 soap_instantiate_ns__SetDeviceSettingSMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetDeviceSettingSMS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SetDeviceSettingSMS *p;
	size_t k = sizeof(struct ns__SetDeviceSettingSMS);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SetDeviceSettingSMS);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SetDeviceSettingSMS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SetDeviceSettingSMS location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SetDeviceSettingSMS, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetDeviceSettingSMS(struct soap *soap, const struct ns__SetDeviceSettingSMS *a, const char *tag, const char *type)
{
	if (soap_out_ns__SetDeviceSettingSMS(soap, tag ? tag : "ns:SetDeviceSettingSMS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SetDeviceSettingSMS * SOAP_FMAC4 soap_get_ns__SetDeviceSettingSMS(struct soap *soap, struct ns__SetDeviceSettingSMS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetDeviceSettingSMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetDeviceSetting(struct soap *soap, struct ns__SetDeviceSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestDevice.ns__Device::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetDeviceSetting(struct soap *soap, const struct ns__SetDeviceSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestDevice.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetDeviceSetting(struct soap *soap, const char *tag, int id, const struct ns__SetDeviceSetting *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetDeviceSetting), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestDevice.soap_out(soap, "requestDevice", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetDeviceSetting * SOAP_FMAC4 soap_in_ns__SetDeviceSetting(struct soap *soap, const char *tag, struct ns__SetDeviceSetting *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestDevice = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetDeviceSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetDeviceSetting, sizeof(struct ns__SetDeviceSetting), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SetDeviceSetting(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestDevice.soap_in(soap, "requestDevice", "ns:Device"))
				{	soap_flag_requestDevice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestDevice > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SetDeviceSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetDeviceSetting, SOAP_TYPE_ns__SetDeviceSetting, sizeof(struct ns__SetDeviceSetting), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SetDeviceSetting * SOAP_FMAC2 soap_instantiate_ns__SetDeviceSetting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetDeviceSetting(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SetDeviceSetting *p;
	size_t k = sizeof(struct ns__SetDeviceSetting);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SetDeviceSetting);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SetDeviceSetting, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SetDeviceSetting location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SetDeviceSetting, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetDeviceSetting(struct soap *soap, const struct ns__SetDeviceSetting *a, const char *tag, const char *type)
{
	if (soap_out_ns__SetDeviceSetting(soap, tag ? tag : "ns:SetDeviceSetting", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SetDeviceSetting * SOAP_FMAC4 soap_get_ns__SetDeviceSetting(struct soap *soap, struct ns__SetDeviceSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetDeviceSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SetDeviceSettingResponse(struct soap *soap, struct ns__SetDeviceSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfns__ErrorCode(soap, &a->responseError);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SetDeviceSettingResponse(struct soap *soap, const struct ns__SetDeviceSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfns__ErrorCode(soap, &a->responseError);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SetDeviceSettingResponse(struct soap *soap, const char *tag, int id, const struct ns__SetDeviceSettingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SetDeviceSettingResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns__ErrorCode(soap, "responseError", -1, &a->responseError, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SetDeviceSettingResponse * SOAP_FMAC4 soap_in_ns__SetDeviceSettingResponse(struct soap *soap, const char *tag, struct ns__SetDeviceSettingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SetDeviceSettingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SetDeviceSettingResponse, sizeof(struct ns__SetDeviceSettingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__SetDeviceSettingResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfns__ErrorCode(soap, "responseError", &a->responseError, "ns:ErrorCode"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->responseError.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__SetDeviceSettingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SetDeviceSettingResponse, SOAP_TYPE_ns__SetDeviceSettingResponse, sizeof(struct ns__SetDeviceSettingResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SetDeviceSettingResponse * SOAP_FMAC2 soap_instantiate_ns__SetDeviceSettingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SetDeviceSettingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SetDeviceSettingResponse *p;
	size_t k = sizeof(struct ns__SetDeviceSettingResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SetDeviceSettingResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SetDeviceSettingResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SetDeviceSettingResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SetDeviceSettingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SetDeviceSettingResponse(struct soap *soap, const struct ns__SetDeviceSettingResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__SetDeviceSettingResponse(soap, tag ? tag : "ns:SetDeviceSettingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SetDeviceSettingResponse * SOAP_FMAC4 soap_get_ns__SetDeviceSettingResponse(struct soap *soap, struct ns__SetDeviceSettingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SetDeviceSettingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDevicePicturePart(struct soap *soap, struct ns__GetDevicePicturePart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestDevice.ns__Device::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDevicePicturePart(struct soap *soap, const struct ns__GetDevicePicturePart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestDevice.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDevicePicturePart(struct soap *soap, const char *tag, int id, const struct ns__GetDevicePicturePart *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetDevicePicturePart), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestDevice.soap_out(soap, "requestDevice", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetDevicePicturePart * SOAP_FMAC4 soap_in_ns__GetDevicePicturePart(struct soap *soap, const char *tag, struct ns__GetDevicePicturePart *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestDevice = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetDevicePicturePart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetDevicePicturePart, sizeof(struct ns__GetDevicePicturePart), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetDevicePicturePart(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestDevice.soap_in(soap, "requestDevice", "ns:Device"))
				{	soap_flag_requestDevice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestDevice > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetDevicePicturePart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetDevicePicturePart, SOAP_TYPE_ns__GetDevicePicturePart, sizeof(struct ns__GetDevicePicturePart), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetDevicePicturePart * SOAP_FMAC2 soap_instantiate_ns__GetDevicePicturePart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetDevicePicturePart(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetDevicePicturePart *p;
	size_t k = sizeof(struct ns__GetDevicePicturePart);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetDevicePicturePart);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetDevicePicturePart, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetDevicePicturePart location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetDevicePicturePart, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDevicePicturePart(struct soap *soap, const struct ns__GetDevicePicturePart *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetDevicePicturePart(soap, tag ? tag : "ns:GetDevicePicturePart", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetDevicePicturePart * SOAP_FMAC4 soap_get_ns__GetDevicePicturePart(struct soap *soap, struct ns__GetDevicePicturePart *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetDevicePicturePart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDevicePicture(struct soap *soap, struct ns__GetDevicePicture *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestDevice.ns__Device::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDevicePicture(struct soap *soap, const struct ns__GetDevicePicture *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestDevice.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDevicePicture(struct soap *soap, const char *tag, int id, const struct ns__GetDevicePicture *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetDevicePicture), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestDevice.soap_out(soap, "requestDevice", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetDevicePicture * SOAP_FMAC4 soap_in_ns__GetDevicePicture(struct soap *soap, const char *tag, struct ns__GetDevicePicture *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestDevice = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetDevicePicture *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetDevicePicture, sizeof(struct ns__GetDevicePicture), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetDevicePicture(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestDevice.soap_in(soap, "requestDevice", "ns:Device"))
				{	soap_flag_requestDevice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestDevice > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetDevicePicture *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetDevicePicture, SOAP_TYPE_ns__GetDevicePicture, sizeof(struct ns__GetDevicePicture), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetDevicePicture * SOAP_FMAC2 soap_instantiate_ns__GetDevicePicture(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetDevicePicture(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetDevicePicture *p;
	size_t k = sizeof(struct ns__GetDevicePicture);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetDevicePicture);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetDevicePicture, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetDevicePicture location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetDevicePicture, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDevicePicture(struct soap *soap, const struct ns__GetDevicePicture *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetDevicePicture(soap, tag ? tag : "ns:GetDevicePicture", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetDevicePicture * SOAP_FMAC4 soap_get_ns__GetDevicePicture(struct soap *soap, struct ns__GetDevicePicture *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetDevicePicture(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetAllDeviceStatus(struct soap *soap, struct ns__GetAllDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetAllDeviceStatus(struct soap *soap, const struct ns__GetAllDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetAllDeviceStatus(struct soap *soap, const char *tag, int id, const struct ns__GetAllDeviceStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetAllDeviceStatus), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetAllDeviceStatus * SOAP_FMAC4 soap_in_ns__GetAllDeviceStatus(struct soap *soap, const char *tag, struct ns__GetAllDeviceStatus *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetAllDeviceStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetAllDeviceStatus, sizeof(struct ns__GetAllDeviceStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetAllDeviceStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetAllDeviceStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetAllDeviceStatus, SOAP_TYPE_ns__GetAllDeviceStatus, sizeof(struct ns__GetAllDeviceStatus), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetAllDeviceStatus * SOAP_FMAC2 soap_instantiate_ns__GetAllDeviceStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetAllDeviceStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetAllDeviceStatus *p;
	size_t k = sizeof(struct ns__GetAllDeviceStatus);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetAllDeviceStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetAllDeviceStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetAllDeviceStatus location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetAllDeviceStatus, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetAllDeviceStatus(struct soap *soap, const struct ns__GetAllDeviceStatus *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetAllDeviceStatus(soap, tag ? tag : "ns:GetAllDeviceStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetAllDeviceStatus * SOAP_FMAC4 soap_get_ns__GetAllDeviceStatus(struct soap *soap, struct ns__GetAllDeviceStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetAllDeviceStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDeviceStatusSMS(struct soap *soap, struct ns__GetDeviceStatusSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestDevice.ns__Device::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDeviceStatusSMS(struct soap *soap, const struct ns__GetDeviceStatusSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestDevice.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDeviceStatusSMS(struct soap *soap, const char *tag, int id, const struct ns__GetDeviceStatusSMS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetDeviceStatusSMS), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestDevice.soap_out(soap, "requestDevice", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetDeviceStatusSMS * SOAP_FMAC4 soap_in_ns__GetDeviceStatusSMS(struct soap *soap, const char *tag, struct ns__GetDeviceStatusSMS *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestDevice = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetDeviceStatusSMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetDeviceStatusSMS, sizeof(struct ns__GetDeviceStatusSMS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetDeviceStatusSMS(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestDevice.soap_in(soap, "requestDevice", "ns:Device"))
				{	soap_flag_requestDevice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestDevice > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetDeviceStatusSMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetDeviceStatusSMS, SOAP_TYPE_ns__GetDeviceStatusSMS, sizeof(struct ns__GetDeviceStatusSMS), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetDeviceStatusSMS * SOAP_FMAC2 soap_instantiate_ns__GetDeviceStatusSMS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetDeviceStatusSMS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetDeviceStatusSMS *p;
	size_t k = sizeof(struct ns__GetDeviceStatusSMS);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetDeviceStatusSMS);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetDeviceStatusSMS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetDeviceStatusSMS location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetDeviceStatusSMS, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDeviceStatusSMS(struct soap *soap, const struct ns__GetDeviceStatusSMS *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetDeviceStatusSMS(soap, tag ? tag : "ns:GetDeviceStatusSMS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetDeviceStatusSMS * SOAP_FMAC4 soap_get_ns__GetDeviceStatusSMS(struct soap *soap, struct ns__GetDeviceStatusSMS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetDeviceStatusSMS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__GetDeviceStatus(struct soap *soap, struct ns__GetDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->requestUser.ns__User::soap_default(soap);
	a->requestDevice.ns__Device::soap_default(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__GetDeviceStatus(struct soap *soap, const struct ns__GetDeviceStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	a->requestUser.soap_serialize(soap);
	a->requestDevice.soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__GetDeviceStatus(struct soap *soap, const char *tag, int id, const struct ns__GetDeviceStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__GetDeviceStatus), type))
		return soap->error;
	if (a->requestUser.soap_out(soap, "requestUser", -1, ""))
		return soap->error;
	if (a->requestDevice.soap_out(soap, "requestDevice", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__GetDeviceStatus * SOAP_FMAC4 soap_in_ns__GetDeviceStatus(struct soap *soap, const char *tag, struct ns__GetDeviceStatus *a, const char *type)
{
	size_t soap_flag_requestUser = 1;
	size_t soap_flag_requestDevice = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__GetDeviceStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__GetDeviceStatus, sizeof(struct ns__GetDeviceStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__GetDeviceStatus(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestUser.soap_in(soap, "requestUser", "ns:User"))
				{	soap_flag_requestUser--;
					continue;
				}
			}
			if (soap_flag_requestDevice && soap->error == SOAP_TAG_MISMATCH)
			{	if (a->requestDevice.soap_in(soap, "requestDevice", "ns:Device"))
				{	soap_flag_requestDevice--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestUser > 0 || soap_flag_requestDevice > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__GetDeviceStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__GetDeviceStatus, SOAP_TYPE_ns__GetDeviceStatus, sizeof(struct ns__GetDeviceStatus), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__GetDeviceStatus * SOAP_FMAC2 soap_instantiate_ns__GetDeviceStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__GetDeviceStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__GetDeviceStatus *p;
	size_t k = sizeof(struct ns__GetDeviceStatus);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__GetDeviceStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__GetDeviceStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__GetDeviceStatus location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns__GetDeviceStatus, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__GetDeviceStatus(struct soap *soap, const struct ns__GetDeviceStatus *a, const char *tag, const char *type)
{
	if (soap_out_ns__GetDeviceStatus(soap, tag ? tag : "ns:GetDeviceStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__GetDeviceStatus * SOAP_FMAC4 soap_get_ns__GetDeviceStatus(struct soap *soap, struct ns__GetDeviceStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__GetDeviceStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__UserLog(struct soap *soap, std::vector<ns__UserLog> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__UserLog(struct soap *soap, const std::vector<ns__UserLog> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__UserLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__UserLog(struct soap *soap, const char *tag, int id, const std::vector<ns__UserLog> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__UserLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__UserLog> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__UserLog(struct soap *soap, const char *tag, std::vector<ns__UserLog> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__UserLog(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns__UserLog n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns__UserLog, SOAP_TYPE_std__vectorTemplateOfns__UserLog, sizeof(ns__UserLog), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns__UserLog(soap, tag, NULL, "ns:UserLog"))
				break;
		}
		else
		{	if (!soap_in_ns__UserLog(soap, tag, &n, "ns:UserLog"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__UserLog));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__UserLog));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__UserLog));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__UserLog>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__UserLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__UserLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__UserLog> *p;
	size_t k = sizeof(std::vector<ns__UserLog> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__UserLog> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__UserLog> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__UserLog>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__UserLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__ActivityLog(struct soap *soap, std::vector<ns__ActivityLog> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__ActivityLog(struct soap *soap, const std::vector<ns__ActivityLog> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__ActivityLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__ActivityLog(struct soap *soap, const char *tag, int id, const std::vector<ns__ActivityLog> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__ActivityLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__ActivityLog> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__ActivityLog(struct soap *soap, const char *tag, std::vector<ns__ActivityLog> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__ActivityLog(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns__ActivityLog n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns__ActivityLog, SOAP_TYPE_std__vectorTemplateOfns__ActivityLog, sizeof(ns__ActivityLog), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns__ActivityLog(soap, tag, NULL, "ns:ActivityLog"))
				break;
		}
		else
		{	if (!soap_in_ns__ActivityLog(soap, tag, &n, "ns:ActivityLog"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__ActivityLog));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__ActivityLog));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__ActivityLog));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__ActivityLog>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__ActivityLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__ActivityLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__ActivityLog> *p;
	size_t k = sizeof(std::vector<ns__ActivityLog> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__ActivityLog> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__ActivityLog> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__ActivityLog>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__ActivityLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__ErrorCode(struct soap *soap, std::vector<ns__ErrorCode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__ErrorCode(struct soap *soap, const std::vector<ns__ErrorCode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__ErrorCode> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__ErrorCode(struct soap *soap, const char *tag, int id, const std::vector<ns__ErrorCode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__ErrorCode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__ErrorCode> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__ErrorCode(struct soap *soap, const char *tag, std::vector<ns__ErrorCode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__ErrorCode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns__ErrorCode n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns__ErrorCode, SOAP_TYPE_std__vectorTemplateOfns__ErrorCode, sizeof(ns__ErrorCode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns__ErrorCode(soap, tag, NULL, "ns:ErrorCode"))
				break;
		}
		else
		{	if (!soap_in_ns__ErrorCode(soap, tag, &n, "ns:ErrorCode"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__ErrorCode));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__ErrorCode));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__ErrorCode));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__ErrorCode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__ErrorCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__ErrorCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__ErrorCode> *p;
	size_t k = sizeof(std::vector<ns__ErrorCode> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__ErrorCode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__ErrorCode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__ErrorCode>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__ErrorCode, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__CityLocation(struct soap *soap, std::vector<ns__CityLocation> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__CityLocation(struct soap *soap, const std::vector<ns__CityLocation> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__CityLocation> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__CityLocation(struct soap *soap, const char *tag, int id, const std::vector<ns__CityLocation> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__CityLocation> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__CityLocation> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__CityLocation(struct soap *soap, const char *tag, std::vector<ns__CityLocation> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__CityLocation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns__CityLocation n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns__CityLocation, SOAP_TYPE_std__vectorTemplateOfns__CityLocation, sizeof(ns__CityLocation), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns__CityLocation(soap, tag, NULL, "ns:CityLocation"))
				break;
		}
		else
		{	if (!soap_in_ns__CityLocation(soap, tag, &n, "ns:CityLocation"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__CityLocation));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__CityLocation));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__CityLocation));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__CityLocation>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__CityLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__CityLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__CityLocation> *p;
	size_t k = sizeof(std::vector<ns__CityLocation> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__CityLocation> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__CityLocation> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__CityLocation>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__CityLocation, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_xsd__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__string, SOAP_TYPE_std__vectorTemplateOfxsd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_xsd__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxsd__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__Device(struct soap *soap, std::vector<ns__Device> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__Device(struct soap *soap, const std::vector<ns__Device> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__Device> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__Device(struct soap *soap, const char *tag, int id, const std::vector<ns__Device> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__Device> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__Device> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__Device(struct soap *soap, const char *tag, std::vector<ns__Device> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__Device(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns__Device n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns__Device, SOAP_TYPE_std__vectorTemplateOfns__Device, sizeof(ns__Device), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns__Device(soap, tag, NULL, "ns:Device"))
				break;
		}
		else
		{	if (!soap_in_ns__Device(soap, tag, &n, "ns:Device"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__Device));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__Device));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__Device));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__Device>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__Device(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__Device(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__Device> *p;
	size_t k = sizeof(std::vector<ns__Device> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__Device> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__Device> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__Device>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__Device, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__DeviceStatusLog(struct soap *soap, std::vector<ns__DeviceStatusLog> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__DeviceStatusLog(struct soap *soap, const std::vector<ns__DeviceStatusLog> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__DeviceStatusLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__DeviceStatusLog(struct soap *soap, const char *tag, int id, const std::vector<ns__DeviceStatusLog> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__DeviceStatusLog> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__DeviceStatusLog> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__DeviceStatusLog(struct soap *soap, const char *tag, std::vector<ns__DeviceStatusLog> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__DeviceStatusLog(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns__DeviceStatusLog n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns__DeviceStatusLog, SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog, sizeof(ns__DeviceStatusLog), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns__DeviceStatusLog(soap, tag, NULL, "ns:DeviceStatusLog"))
				break;
		}
		else
		{	if (!soap_in_ns__DeviceStatusLog(soap, tag, &n, "ns:DeviceStatusLog"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__DeviceStatusLog));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__DeviceStatusLog));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__DeviceStatusLog));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__DeviceStatusLog>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__DeviceStatusLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__DeviceStatusLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__DeviceStatusLog> *p;
	size_t k = sizeof(std::vector<ns__DeviceStatusLog> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__DeviceStatusLog> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__DeviceStatusLog> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__DeviceStatusLog>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__SensorExtension(struct soap *soap, std::vector<ns__SensorExtension> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__SensorExtension(struct soap *soap, const std::vector<ns__SensorExtension> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__SensorExtension> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__SensorExtension(struct soap *soap, const char *tag, int id, const std::vector<ns__SensorExtension> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__SensorExtension> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__SensorExtension> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__SensorExtension(struct soap *soap, const char *tag, std::vector<ns__SensorExtension> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__SensorExtension(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns__SensorExtension n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns__SensorExtension, SOAP_TYPE_std__vectorTemplateOfns__SensorExtension, sizeof(ns__SensorExtension), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns__SensorExtension(soap, tag, NULL, "ns:SensorExtension"))
				break;
		}
		else
		{	if (!soap_in_ns__SensorExtension(soap, tag, &n, "ns:SensorExtension"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__SensorExtension));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__SensorExtension));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__SensorExtension));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__SensorExtension>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__SensorExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__SensorExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__SensorExtension> *p;
	size_t k = sizeof(std::vector<ns__SensorExtension> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__SensorExtension> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__SensorExtension> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__SensorExtension>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__SensorExtension, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__RequestType(struct soap *soap, std::vector<enum ns__RequestType> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__RequestType(struct soap *soap, const std::vector<enum ns__RequestType> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__RequestType(struct soap *soap, const char *tag, int id, const std::vector<enum ns__RequestType> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum ns__RequestType> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns__RequestType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns__RequestType> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__RequestType(struct soap *soap, const char *tag, std::vector<enum ns__RequestType> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__RequestType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum ns__RequestType n;
		soap_default_ns__RequestType(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns__RequestType, SOAP_TYPE_std__vectorTemplateOfns__RequestType, sizeof(enum ns__RequestType), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns__RequestType(soap, tag, NULL, "ns:RequestType"))
				break;
		}
		else
		{	if (!soap_in_ns__RequestType(soap, tag, &n, "ns:RequestType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns__RequestType>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__RequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__RequestType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum ns__RequestType> *p;
	size_t k = sizeof(std::vector<enum ns__RequestType> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<enum ns__RequestType> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<enum ns__RequestType> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum ns__RequestType>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__RequestType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__boolean(struct soap *soap, std::vector<bool> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__boolean(struct soap *soap, const std::vector<bool> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__boolean(struct soap *soap, const char *tag, int id, const std::vector<bool> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<bool> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		bool b = (*i);
		if (soap_out_xsd__boolean(soap, tag, id, &b, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<bool> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__boolean(struct soap *soap, const char *tag, std::vector<bool> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__boolean(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		bool n;
		soap_default_xsd__boolean(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__boolean, SOAP_TYPE_std__vectorTemplateOfxsd__boolean, sizeof(bool), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__boolean(soap, tag, NULL, "xsd:boolean"))
				break;
		}
		else
		{	if (!soap_in_xsd__boolean(soap, tag, &n, "xsd:boolean"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<bool>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__boolean(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<bool> *p;
	size_t k = sizeof(std::vector<bool> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<bool> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<bool> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<bool>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxsd__boolean, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__PicturePart(struct soap *soap, std::vector<ns__PicturePart> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__PicturePart(struct soap *soap, const std::vector<ns__PicturePart> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__PicturePart> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__PicturePart(struct soap *soap, const char *tag, int id, const std::vector<ns__PicturePart> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__PicturePart> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__PicturePart> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__PicturePart(struct soap *soap, const char *tag, std::vector<ns__PicturePart> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__PicturePart(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns__PicturePart n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns__PicturePart, SOAP_TYPE_std__vectorTemplateOfns__PicturePart, sizeof(ns__PicturePart), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns__PicturePart(soap, tag, NULL, "ns:PicturePart"))
				break;
		}
		else
		{	if (!soap_in_ns__PicturePart(soap, tag, &n, "ns:PicturePart"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__PicturePart));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__PicturePart));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__PicturePart));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__PicturePart>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__PicturePart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__PicturePart(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__PicturePart> *p;
	size_t k = sizeof(std::vector<ns__PicturePart> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__PicturePart> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__PicturePart> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__PicturePart>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__PicturePart, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__double(struct soap *soap, std::vector<double> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__double(struct soap *soap, const std::vector<double> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__double(struct soap *soap, const char *tag, int id, const std::vector<double> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<double> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__double(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<double> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__double(struct soap *soap, const char *tag, std::vector<double> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__double(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		double n;
		soap_default_xsd__double(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__double, SOAP_TYPE_std__vectorTemplateOfxsd__double, sizeof(double), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__double(soap, tag, NULL, "xsd:double"))
				break;
		}
		else
		{	if (!soap_in_xsd__double(soap, tag, &n, "xsd:double"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<double>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__double(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__double(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<double> *p;
	size_t k = sizeof(std::vector<double> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<double> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<double> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<double>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfxsd__double, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__Calibration(struct soap *soap, std::vector<ns__Calibration> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__Calibration(struct soap *soap, const std::vector<ns__Calibration> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__Calibration> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__Calibration(struct soap *soap, const char *tag, int id, const std::vector<ns__Calibration> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__Calibration> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__Calibration> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__Calibration(struct soap *soap, const char *tag, std::vector<ns__Calibration> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__Calibration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns__Calibration n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns__Calibration, SOAP_TYPE_std__vectorTemplateOfns__Calibration, sizeof(ns__Calibration), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns__Calibration(soap, tag, NULL, "ns:Calibration"))
				break;
		}
		else
		{	if (!soap_in_ns__Calibration(soap, tag, &n, "ns:Calibration"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__Calibration));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__Calibration));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__Calibration));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__Calibration>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__Calibration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__Calibration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__Calibration> *p;
	size_t k = sizeof(std::vector<ns__Calibration> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__Calibration> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__Calibration> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__Calibration>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__Calibration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns__User(struct soap *soap, std::vector<ns__User> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns__User(struct soap *soap, const std::vector<ns__User> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns__User> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns__User(struct soap *soap, const char *tag, int id, const std::vector<ns__User> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns__User> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns__User> * SOAP_FMAC4 soap_in_std__vectorTemplateOfns__User(struct soap *soap, const char *tag, std::vector<ns__User> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfns__User(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns__User n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns__User, SOAP_TYPE_std__vectorTemplateOfns__User, sizeof(ns__User), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_ns__User(soap, tag, NULL, "ns:User"))
				break;
		}
		else
		{	if (!soap_in_ns__User(soap, tag, &n, "ns:User"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__User));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(ns__User));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(ns__User));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns__User>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns__User(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns__User> *p;
	size_t k = sizeof(std::vector<ns__User> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns__User> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns__User> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns__User>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfns__User, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
