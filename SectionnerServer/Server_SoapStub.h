/* Server_SoapStub.h
   Generated by gSOAP 2.8.45 for source.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>

#ifndef Server_SoapStub_H
#define Server_SoapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20845
# error "GSOAP VERSION 20845 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* source.h:17 */
#ifndef SOAP_TYPE_ns__SettingLevel
#define SOAP_TYPE_ns__SettingLevel (20)
/* ns:SettingLevel */
enum ns__SettingLevel {
	Normal = 0,
	Disable = 1,
	Warning = 2,
	Minor = 3,
	Major = 4,
	Critical = 5
};
#endif

/* source.h:27 */
#ifndef SOAP_TYPE_ns__UserType
#define SOAP_TYPE_ns__UserType (21)
/* ns:UserType */
enum ns__UserType {
	Admin = 0,
	Control = 1,
	Monitor = 2
};
#endif

/* source.h:34 */
#ifndef SOAP_TYPE_ns__SensorType
#define SOAP_TYPE_ns__SensorType (22)
/* ns:SensorType */
enum ns__SensorType {
	Multi = 0,
	Mono = 1
};
#endif

/* source.h:40 */
#ifndef SOAP_TYPE_ns__SensorName
#define SOAP_TYPE_ns__SensorName (23)
/* ns:SensorName */
enum ns__SensorName {
	TEMPERATURE = 0,
	HUMIDITY = 1,
	ACVOLTAGE = 2,
	ACAMPERE = 3,
	DCVOLTAGE = 4,
	DCAMPERE = 5,
	COSQ = 6,
	DIGITALINPUT = 7,
	DIGITALOUTPUT = 8,
	DIGITALEXIST = 9,
	RELAY = 10,
	UNKNOWN = 11
};
#endif

/* source.h:56 */
#ifndef SOAP_TYPE_ns__DeviceModel
#define SOAP_TYPE_ns__DeviceModel (24)
/* ns:DeviceModel */
enum ns__DeviceModel {
	PROTECTOR = 0,
	SECTIONNER = 1,
	TRANSISTOR = 2,
	SERVER = 3,
	MANAGER = 4,
	ROBER = 5,
	ALARM = 6
};
#endif

/* source.h:67 */
#ifndef SOAP_TYPE_ns__RequestType
#define SOAP_TYPE_ns__RequestType (25)
/* ns:RequestType */
enum ns__RequestType {
	CALIBRATION = 0,
	SAMPLING = 1,
	OUTRELAY = 2,
	DATETIME = 3,
	PICTURE = 4,
	PARTS = 5,
	RESET = 6,
	LIVE = 7,
	OK = 8,
	DATA = 9,
	CUSTOM = 10,
	STT = 11,
	ALM = 12
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns__ErrorCode;	/* source.h:84 */
class ns__User;	/* source.h:91 */
class ns__UsersList;	/* source.h:104 */
class ns__IP;	/* source.h:110 */
class ns__GPS;	/* source.h:118 */
class ns__Calibration;	/* source.h:124 */
class ns__CalibrationList;	/* source.h:133 */
class ns__Sensor;	/* source.h:141 */
class ns__SensorExtension;	/* source.h:151 */
class ns__Camera;	/* source.h:158 */
class ns__PicturePart;	/* source.h:166 */
class ns__Picture;	/* source.h:173 */
class ns__Device;	/* source.h:183 */
class ns__ReportRange;	/* source.h:223 */
class ns__ActivityLog;	/* source.h:229 */
class ns__UserLog;	/* source.h:238 */
class ns__DeviceStatusLog;	/* source.h:245 */
class ns__DeviceStatusLogList;	/* source.h:252 */
class ns__DeviceStatus;	/* source.h:259 */
class ns__ErrorLog;	/* source.h:266 */
class ns__UserDevice;	/* source.h:273 */
class ns__DataBase;	/* source.h:280 */
class ns__ServerOptions;	/* source.h:289 */
class ns__CityLocation;	/* source.h:296 */
class ns__AllCityLocatoins;	/* source.h:303 */
struct ns__GetDeviceStatus;	/* source.h:311 */
struct ns__GetDeviceStatusSMS;	/* source.h:314 */
struct ns__GetAllDeviceStatus;	/* source.h:317 */
struct ns__GetDevicePicture;	/* source.h:320 */
struct ns__GetDevicePicturePart;	/* source.h:323 */
struct ns__SetDeviceSettingResponse;	/* source.h:326 */
struct ns__SetDeviceSetting;	/* source.h:326 */
struct ns__SetDeviceSettingSMS;	/* source.h:329 */
struct ns__SetAllDeviceSettingResponse;	/* source.h:332 */
struct ns__SetAllDeviceSetting;	/* source.h:332 */
struct ns__DeleteDevicesResponse;	/* source.h:335 */
struct ns__DeleteDevices;	/* source.h:335 */
struct ns__SetDeviceCalibration;	/* source.h:339 */
struct ns__GetDeviceCalibration;	/* source.h:342 */
struct ns__Login;	/* source.h:346 */
struct ns__GetUserDeviceList;	/* source.h:349 */
struct ns__GetUsersList;	/* source.h:353 */
struct ns__AddUser;	/* source.h:356 */
struct ns__UpdateUser;	/* source.h:359 */
struct ns__DeleteUser;	/* source.h:362 */
struct ns__AssignDeviceToUser;	/* source.h:365 */
struct ns__DeleteDeviceFromUser;	/* source.h:368 */
struct ns__GetUserDevices;	/* source.h:371 */
struct ns__SaveActivityLog;	/* source.h:375 */
struct ns__GetActivityLogResponse;	/* source.h:378 */
struct ns__GetActivityLog;	/* source.h:378 */
struct ns__SaveUserLog;	/* source.h:381 */
struct ns__GetUserLogResponse;	/* source.h:384 */
struct ns__GetUserLog;	/* source.h:384 */
struct ns__SaveDeviceStatusLog;	/* source.h:387 */
struct ns__GetDeviceStatusLog;	/* source.h:390 */
struct ns__GetServerOptions;	/* source.h:394 */
struct ns__SetServerOptions;	/* source.h:397 */
struct ns__GetCityAndLocations;	/* source.h:401 */
struct ns__ChangeCityName;	/* source.h:404 */
struct ns__ChangeLocationName;	/* source.h:407 */
struct ns__ChangeDeviceName;	/* source.h:410 */

/* source.h:84 */
#ifndef SOAP_TYPE_ns__ErrorCode
#define SOAP_TYPE_ns__ErrorCode (26)
/* complex XSD type 'ns:ErrorCode': */
class SOAP_CMAC ns__ErrorCode {
      public:
        /// Optional element 'eNo' of XSD type 'xsd:int'
        int eNo;	///< default = 0
        /// Optional element 'eMsg' of XSD type 'xsd:string'
        std::string eMsg;	///< default = ""
        /// Optional element 'eType' of XSD type 'ns:SettingLevel'
        enum ns__SettingLevel eType;	///< default = (enum ns__SettingLevel)0
      public:
        /// Return unique type id SOAP_TYPE_ns__ErrorCode
        virtual int soap_type(void) const { return SOAP_TYPE_ns__ErrorCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ErrorCode, default initialized and not managed by a soap context
        virtual ns__ErrorCode *soap_alloc(void) const { return SOAP_NEW(ns__ErrorCode); }
      public:
        /// Constructor with initializations
        ns__ErrorCode()
        {
          eNo = 0;
          eMsg = "";
          eType = (enum ns__SettingLevel)0;
        }
        virtual ~ns__ErrorCode() { }
        /// Friend allocator used by soap_new_ns__ErrorCode(struct soap*, int)
        friend SOAP_FMAC1 ns__ErrorCode * SOAP_FMAC2 Server_Soap_instantiate_ns__ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:91 */
#ifndef SOAP_TYPE_ns__User
#define SOAP_TYPE_ns__User (27)
/* complex XSD type 'ns:User': */
class SOAP_CMAC ns__User {
      public:
        /// Optional element 'uId' of XSD type 'xsd:int'
        int uId;	///< default = 0
        /// Optional element 'uName' of XSD type 'xsd:string'
        std::string uName;	///< default = ""
        /// Optional element 'uPassword' of XSD type 'xsd:string'
        std::string uPassword;	///< default = ""
        /// Optional element 'uRePassword' of XSD type 'xsd:string'
        std::string uRePassword;	///< default = ""
        /// Optional element 'uFirstName' of XSD type 'xsd:string'
        std::string uFirstName;	///< default = ""
        /// Optional element 'uLastName' of XSD type 'xsd:string'
        std::string uLastName;	///< default = ""
        /// Optional element 'uType' of XSD type 'ns:UserType'
        enum ns__UserType uType;	///< default = (enum ns__UserType)2
        /// Optional element 'uKey' of XSD type 'xsd:string'
        std::string uKey;	///< default = ""
        /// Required element 'uErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode uErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__User
        virtual int soap_type(void) const { return SOAP_TYPE_ns__User; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__User, default initialized and not managed by a soap context
        virtual ns__User *soap_alloc(void) const { return SOAP_NEW(ns__User); }
      public:
        /// Constructor with initializations
        ns__User()
        {
          uId = 0;
          uName = "";
          uPassword = "";
          uRePassword = "";
          uFirstName = "";
          uLastName = "";
          uType = (enum ns__UserType)2;
          uKey = "";
        }
        virtual ~ns__User() { }
        /// Friend allocator used by soap_new_ns__User(struct soap*, int)
        friend SOAP_FMAC1 ns__User * SOAP_FMAC2 Server_Soap_instantiate_ns__User(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:104 */
#ifndef SOAP_TYPE_ns__UsersList
#define SOAP_TYPE_ns__UsersList (28)
/* complex XSD type 'ns:UsersList': */
class SOAP_CMAC ns__UsersList {
      public:
        /// Optional element 'ulUsers' of XSD type 'ns:User'
        std::vector<ns__User> ulUsers;
        /// Required element 'ulErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode ulErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__UsersList
        virtual int soap_type(void) const { return SOAP_TYPE_ns__UsersList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__UsersList, default initialized and not managed by a soap context
        virtual ns__UsersList *soap_alloc(void) const { return SOAP_NEW(ns__UsersList); }
      public:
        /// Constructor with initializations
        ns__UsersList()
        {
        }
        virtual ~ns__UsersList() { }
        /// Friend allocator used by soap_new_ns__UsersList(struct soap*, int)
        friend SOAP_FMAC1 ns__UsersList * SOAP_FMAC2 Server_Soap_instantiate_ns__UsersList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:110 */
#ifndef SOAP_TYPE_ns__IP
#define SOAP_TYPE_ns__IP (30)
/* complex XSD type 'ns:IP': */
class SOAP_CMAC ns__IP {
      public:
        /// Optional element 'ip1' of XSD type 'xsd:int'
        int ip1;	///< default = 0
        /// Optional element 'ip2' of XSD type 'xsd:int'
        int ip2;	///< default = 0
        /// Optional element 'ip3' of XSD type 'xsd:int'
        int ip3;	///< default = 0
        /// Optional element 'ip4' of XSD type 'xsd:int'
        int ip4;	///< default = 0
      public:
        /// Return unique type id SOAP_TYPE_ns__IP
        virtual int soap_type(void) const { return SOAP_TYPE_ns__IP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__IP, default initialized and not managed by a soap context
        virtual ns__IP *soap_alloc(void) const { return SOAP_NEW(ns__IP); }
      public:
        /// Constructor with initializations
        ns__IP()
        {
          ip1 = 0;
          ip2 = 0;
          ip3 = 0;
          ip4 = 0;
        }
        virtual ~ns__IP() { }
        /// Friend allocator used by soap_new_ns__IP(struct soap*, int)
        friend SOAP_FMAC1 ns__IP * SOAP_FMAC2 Server_Soap_instantiate_ns__IP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:118 */
#ifndef SOAP_TYPE_ns__GPS
#define SOAP_TYPE_ns__GPS (31)
/* complex XSD type 'ns:GPS': */
class SOAP_CMAC ns__GPS {
      public:
        /// Optional element 'gX' of XSD type 'xsd:double'
        double gX;	///< default = 0
        /// Optional element 'gY' of XSD type 'xsd:double'
        double gY;	///< default = 0
      public:
        /// Return unique type id SOAP_TYPE_ns__GPS
        virtual int soap_type(void) const { return SOAP_TYPE_ns__GPS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__GPS, default initialized and not managed by a soap context
        virtual ns__GPS *soap_alloc(void) const { return SOAP_NEW(ns__GPS); }
      public:
        /// Constructor with initializations
        ns__GPS()
        {
          gX = 0;
          gY = 0;
        }
        virtual ~ns__GPS() { }
        /// Friend allocator used by soap_new_ns__GPS(struct soap*, int)
        friend SOAP_FMAC1 ns__GPS * SOAP_FMAC2 Server_Soap_instantiate_ns__GPS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:124 */
#ifndef SOAP_TYPE_ns__Calibration
#define SOAP_TYPE_ns__Calibration (32)
/* complex XSD type 'ns:Calibration': */
class SOAP_CMAC ns__Calibration {
      public:
        /// Optional element 'cOffset' of XSD type 'xsd:double'
        double cOffset;	///< default = 0
        /// Optional element 'cZero' of XSD type 'xsd:double'
        double cZero;	///< default = 0
        /// Optional element 'cSpan' of XSD type 'xsd:double'
        double cSpan;	///< default = 0
        /// Optional element 'cMin' of XSD type 'xsd:double'
        double cMin;	///< default = 0
        /// Optional element 'cMax' of XSD type 'xsd:double'
        double cMax;	///< default = 0
      public:
        /// Return unique type id SOAP_TYPE_ns__Calibration
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Calibration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Calibration, default initialized and not managed by a soap context
        virtual ns__Calibration *soap_alloc(void) const { return SOAP_NEW(ns__Calibration); }
      public:
        /// Constructor with initializations
        ns__Calibration()
        {
          cOffset = 0;
          cZero = 0;
          cSpan = 0;
          cMin = 0;
          cMax = 0;
        }
        virtual ~ns__Calibration() { }
        /// Friend allocator used by soap_new_ns__Calibration(struct soap*, int)
        friend SOAP_FMAC1 ns__Calibration * SOAP_FMAC2 Server_Soap_instantiate_ns__Calibration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:133 */
#ifndef SOAP_TYPE_ns__CalibrationList
#define SOAP_TYPE_ns__CalibrationList (33)
/* complex XSD type 'ns:CalibrationList': */
class SOAP_CMAC ns__CalibrationList {
      public:
        /// Optional element 'clVoltage' of XSD type 'ns:Calibration'
        std::vector<ns__Calibration> clVoltage;
        /// Optional element 'clAmpere' of XSD type 'ns:Calibration'
        std::vector<ns__Calibration> clAmpere;
        /// Optional element 'clCosq' of XSD type 'ns:Calibration'
        std::vector<ns__Calibration> clCosq;
        /// Required element 'clErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode clErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__CalibrationList
        virtual int soap_type(void) const { return SOAP_TYPE_ns__CalibrationList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__CalibrationList, default initialized and not managed by a soap context
        virtual ns__CalibrationList *soap_alloc(void) const { return SOAP_NEW(ns__CalibrationList); }
      public:
        /// Constructor with initializations
        ns__CalibrationList()
        {
        }
        virtual ~ns__CalibrationList() { }
        /// Friend allocator used by soap_new_ns__CalibrationList(struct soap*, int)
        friend SOAP_FMAC1 ns__CalibrationList * SOAP_FMAC2 Server_Soap_instantiate_ns__CalibrationList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:141 */
#ifndef SOAP_TYPE_ns__Sensor
#define SOAP_TYPE_ns__Sensor (35)
/* complex XSD type 'ns:Sensor': */
class SOAP_CMAC ns__Sensor {
      public:
        /// Optional element 'sNkName' of XSD type 'xsd:string'
        std::string sNkName;	///< default = ""
        /// Optional element 'sVal' of XSD type 'xsd:double'
        double sVal;	///< default = 0
        /// Optional element 'sMin' of XSD type 'xsd:int'
        int sMin;	///< default = 0
        /// Optional element 'sMax' of XSD type 'xsd:int'
        int sMax;	///< default = 0
        /// Optional element 'sType' of XSD type 'ns:SensorType'
        enum ns__SensorType sType;	///< default = (enum ns__SensorType)0
        /// Required element 'sErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode sErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__Sensor
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Sensor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Sensor, default initialized and not managed by a soap context
        virtual ns__Sensor *soap_alloc(void) const { return SOAP_NEW(ns__Sensor); }
      public:
        /// Constructor with initializations
        ns__Sensor()
        {
          sNkName = "";
          sVal = 0;
          sMin = 0;
          sMax = 0;
          sType = (enum ns__SensorType)0;
        }
        virtual ~ns__Sensor() { }
        /// Friend allocator used by soap_new_ns__Sensor(struct soap*, int)
        friend SOAP_FMAC1 ns__Sensor * SOAP_FMAC2 Server_Soap_instantiate_ns__Sensor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:151 */
#ifndef SOAP_TYPE_ns__SensorExtension
#define SOAP_TYPE_ns__SensorExtension (36)
/* complex XSD type 'ns:SensorExtension': */
class SOAP_CMAC ns__SensorExtension {
      public:
        /// Optional element 'seName' of XSD type 'ns:SensorName'
        enum ns__SensorName seName;	///< default = (enum ns__SensorName)2
        /// Optional element 'seVal' of XSD type 'xsd:double'
        std::vector<double> seVal;
      public:
        /// Return unique type id SOAP_TYPE_ns__SensorExtension
        virtual int soap_type(void) const { return SOAP_TYPE_ns__SensorExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__SensorExtension, default initialized and not managed by a soap context
        virtual ns__SensorExtension *soap_alloc(void) const { return SOAP_NEW(ns__SensorExtension); }
      public:
        /// Constructor with initializations
        ns__SensorExtension()
        {
          seName = (enum ns__SensorName)2;
        }
        virtual ~ns__SensorExtension() { }
        /// Friend allocator used by soap_new_ns__SensorExtension(struct soap*, int)
        friend SOAP_FMAC1 ns__SensorExtension * SOAP_FMAC2 Server_Soap_instantiate_ns__SensorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:158 */
#ifndef SOAP_TYPE_ns__Camera
#define SOAP_TYPE_ns__Camera (38)
/* complex XSD type 'ns:Camera': */
class SOAP_CMAC ns__Camera {
      public:
        /// Optional element 'cSocket' of XSD type 'xsd:int'
        int cSocket;	///< default = 0
        /// Required element 'cIP' of XSD type 'ns:IP'
        ns__IP cIP;
        /// Optional element 'cPort' of XSD type 'xsd:int'
        int cPort;	///< default = 0
        /// Required element 'cErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode cErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__Camera
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Camera; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Camera, default initialized and not managed by a soap context
        virtual ns__Camera *soap_alloc(void) const { return SOAP_NEW(ns__Camera); }
      public:
        /// Constructor with initializations
        ns__Camera()
        {
          cSocket = 0;
          cPort = 0;
        }
        virtual ~ns__Camera() { }
        /// Friend allocator used by soap_new_ns__Camera(struct soap*, int)
        friend SOAP_FMAC1 ns__Camera * SOAP_FMAC2 Server_Soap_instantiate_ns__Camera(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:166 */
#ifndef SOAP_TYPE_ns__PicturePart
#define SOAP_TYPE_ns__PicturePart (39)
/* complex XSD type 'ns:PicturePart': */
class SOAP_CMAC ns__PicturePart {
      public:
        /// Optional element 'ppIndex' of XSD type 'xsd:int'
        int ppIndex;	///< default = 0
        /// Optional element 'ppData' of XSD type 'xsd:string'
        std::string ppData;	///< default = ""
        /// Optional element 'ppCRC' of XSD type 'xsd:int'
        int ppCRC;	///< default = 0
      public:
        /// Return unique type id SOAP_TYPE_ns__PicturePart
        virtual int soap_type(void) const { return SOAP_TYPE_ns__PicturePart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__PicturePart, default initialized and not managed by a soap context
        virtual ns__PicturePart *soap_alloc(void) const { return SOAP_NEW(ns__PicturePart); }
      public:
        /// Constructor with initializations
        ns__PicturePart()
        {
          ppIndex = 0;
          ppData = "";
          ppCRC = 0;
        }
        virtual ~ns__PicturePart() { }
        /// Friend allocator used by soap_new_ns__PicturePart(struct soap*, int)
        friend SOAP_FMAC1 ns__PicturePart * SOAP_FMAC2 Server_Soap_instantiate_ns__PicturePart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:173 */
#ifndef SOAP_TYPE_ns__Picture
#define SOAP_TYPE_ns__Picture (40)
/* complex XSD type 'ns:Picture': */
class SOAP_CMAC ns__Picture {
      public:
        /// Optional element 'pName' of XSD type 'xsd:string'
        std::string pName;	///< default = ""
        /// Optional element 'pSize' of XSD type 'xsd:int'
        int pSize;	///< default = 0
        /// Optional element 'pPartSize' of XSD type 'xsd:int'
        int pPartSize;	///< default = 0
        /// Optional element 'pPartNo' of XSD type 'xsd:int'
        int pPartNo;	///< default = 0
        /// Optional element 'pCRC' of XSD type 'xsd:int'
        int pCRC;	///< default = 0
        /// Optional element 'pParts' of XSD type 'ns:PicturePart'
        std::vector<ns__PicturePart> pParts;
      public:
        /// Return unique type id SOAP_TYPE_ns__Picture
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Picture; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Picture, default initialized and not managed by a soap context
        virtual ns__Picture *soap_alloc(void) const { return SOAP_NEW(ns__Picture); }
      public:
        /// Constructor with initializations
        ns__Picture()
        {
          pName = "";
          pSize = 0;
          pPartSize = 0;
          pPartNo = 0;
          pCRC = 0;
        }
        virtual ~ns__Picture() { }
        /// Friend allocator used by soap_new_ns__Picture(struct soap*, int)
        friend SOAP_FMAC1 ns__Picture * SOAP_FMAC2 Server_Soap_instantiate_ns__Picture(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:183 */
#ifndef SOAP_TYPE_ns__Device
#define SOAP_TYPE_ns__Device (42)
/* complex XSD type 'ns:Device': */
class SOAP_CMAC ns__Device {
      public:
        /// Optional element 'dSerialNumber' of XSD type 'xsd:int'
        int dSerialNumber;	///< default = 0
        /// Optional element 'dModel' of XSD type 'ns:DeviceModel'
        enum ns__DeviceModel dModel;	///< default = (enum ns__DeviceModel)1
        /// Optional element 'dName' of XSD type 'xsd:string'
        std::string dName;	///< default = ""
        /// Optional element 'dNikeName' of XSD type 'xsd:string'
        std::string dNikeName;	///< default = ""
        /// Optional element 'dLocation' of XSD type 'xsd:string'
        std::string dLocation;	///< default = ""
        /// Optional element 'dCity' of XSD type 'xsd:string'
        std::string dCity;	///< default = ""
        /// Optional element 'dSocket' of XSD type 'xsd:int'
        int dSocket;	///< default = 0
        /// Optional element 'dDNSAddress' of XSD type 'xsd:string'
        std::string dDNSAddress;	///< default = ""
        /// Required element 'dIP' of XSD type 'ns:IP'
        ns__IP dIP;
        /// Optional element 'dPort' of XSD type 'xsd:int'
        int dPort;	///< default = 0
        /// Optional element 'dDateTime' of XSD type 'xsd:dateTime'
        time_t dDateTime;	///< default = 0
        /// Optional element 'dDDateTime' of XSD type 'xsd:dateTime'
        time_t dDDateTime;	///< default = 0
        /// Required element 'dCamera' of XSD type 'ns:Camera'
        ns__Camera dCamera;
        /// Required element 'dGPS' of XSD type 'ns:GPS'
        ns__GPS dGPS;
        /// Optional element 'dReset' of XSD type 'xsd:boolean'
        bool dReset;	///< default = (bool)0
        /// Optional element 'dSamplingTime' of XSD type 'xsd:int'
        int dSamplingTime;	///< default = 0
        /// Optional element 'dTransPower' of XSD type 'xsd:double'
        double dTransPower;	///< default = 0
        /// Optional element 'dTableCapacity' of XSD type 'xsd:double'
        double dTableCapacity;	///< default = 0
        /// Optional element 'dPOK' of XSD type 'xsd:double'
        double dPOK;	///< default = 0
        /// Optional element 'dPTotal' of XSD type 'xsd:double'
        double dPTotal;	///< default = 0
        /// Optional element 'dPR' of XSD type 'xsd:double'
        double dPR;	///< default = 0
        /// Optional element 'dPS' of XSD type 'xsd:double'
        double dPS;	///< default = 0
        /// Optional element 'dPT' of XSD type 'xsd:double'
        double dPT;	///< default = 0
        /// Optional element 'dQR' of XSD type 'xsd:double'
        double dQR;	///< default = 0
        /// Optional element 'dQS' of XSD type 'xsd:double'
        double dQS;	///< default = 0
        /// Optional element 'dQT' of XSD type 'xsd:double'
        double dQT;	///< default = 0
        /// Optional element 'dKeyName' of XSD type 'xsd:string'
        std::string dKeyName;	///< default = ""
        /// Required element 'dPicture' of XSD type 'ns:Picture'
        ns__Picture dPicture;
        /// Optional element 'dCustomCommand' of XSD type 'xsd:string'
        std::string dCustomCommand;	///< default = ""
        /// Optional element 'dRelays' of XSD type 'xsd:boolean'
        std::vector<bool> dRelays;
        /// Optional element 'dRequests' of XSD type 'ns:RequestType'
        std::vector<enum ns__RequestType> dRequests;
        /// Optional element 'dSensors' of XSD type 'ns:SensorExtension'
        std::vector<ns__SensorExtension> dSensors;
        /// Optional element 'dSmsTerm' of XSD type 'xsd:int'
        int dSmsTerm;	///< default = 60
        /// Optional element 'dSms' of XSD type 'xsd:boolean'
        bool dSms;	///< default = (bool)0
        /// Optional element 'dSmsTime' of XSD type 'xsd:dateTime'
        time_t dSmsTime;	///< default = 0
        /// Required element 'dErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode dErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__Device
        virtual int soap_type(void) const { return SOAP_TYPE_ns__Device; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__Device, default initialized and not managed by a soap context
        virtual ns__Device *soap_alloc(void) const { return SOAP_NEW(ns__Device); }
      public:
        /// Constructor with initializations
        ns__Device()
        {
          dSerialNumber = 0;
          dModel = (enum ns__DeviceModel)1;
          dName = "";
          dNikeName = "";
          dLocation = "";
          dCity = "";
          dSocket = 0;
          dDNSAddress = "";
          dPort = 0;
          dDateTime = 0;
          dDDateTime = 0;
          dReset = (bool)0;
          dSamplingTime = 0;
          dTransPower = 0;
          dTableCapacity = 0;
          dPOK = 0;
          dPTotal = 0;
          dPR = 0;
          dPS = 0;
          dPT = 0;
          dQR = 0;
          dQS = 0;
          dQT = 0;
          dKeyName = "";
          dCustomCommand = "";
          dSmsTerm = 60;
          dSms = (bool)0;
          dSmsTime = 0;
        }
        virtual ~ns__Device() { }
        /// Friend allocator used by soap_new_ns__Device(struct soap*, int)
        friend SOAP_FMAC1 ns__Device * SOAP_FMAC2 Server_Soap_instantiate_ns__Device(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:223 */
#ifndef SOAP_TYPE_ns__ReportRange
#define SOAP_TYPE_ns__ReportRange (46)
/* complex XSD type 'ns:ReportRange': */
class SOAP_CMAC ns__ReportRange {
      public:
        /// Optional element 'rrStart' of XSD type 'xsd:dateTime'
        time_t rrStart;	///< default = 0
        /// Optional element 'rrEnd' of XSD type 'xsd:dateTime'
        time_t rrEnd;	///< default = 0
      public:
        /// Return unique type id SOAP_TYPE_ns__ReportRange
        virtual int soap_type(void) const { return SOAP_TYPE_ns__ReportRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ReportRange, default initialized and not managed by a soap context
        virtual ns__ReportRange *soap_alloc(void) const { return SOAP_NEW(ns__ReportRange); }
      public:
        /// Constructor with initializations
        ns__ReportRange()
        {
          rrStart = 0;
          rrEnd = 0;
        }
        virtual ~ns__ReportRange() { }
        /// Friend allocator used by soap_new_ns__ReportRange(struct soap*, int)
        friend SOAP_FMAC1 ns__ReportRange * SOAP_FMAC2 Server_Soap_instantiate_ns__ReportRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:229 */
#ifndef SOAP_TYPE_ns__ActivityLog
#define SOAP_TYPE_ns__ActivityLog (47)
/* complex XSD type 'ns:ActivityLog': */
class SOAP_CMAC ns__ActivityLog {
      public:
        /// Required element 'alRange' of XSD type 'ns:ReportRange'
        ns__ReportRange alRange;
        /// Optional element 'alData' of XSD type 'xsd:string'
        std::string alData;	///< default = ""
        /// Required element 'alDevice' of XSD type 'ns:Device'
        ns__Device alDevice;
        /// Required element 'alUser' of XSD type 'ns:User'
        ns__User alUser;
        /// Required element 'alErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode alErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__ActivityLog
        virtual int soap_type(void) const { return SOAP_TYPE_ns__ActivityLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ActivityLog, default initialized and not managed by a soap context
        virtual ns__ActivityLog *soap_alloc(void) const { return SOAP_NEW(ns__ActivityLog); }
      public:
        /// Constructor with initializations
        ns__ActivityLog()
        {
          alData = "";
        }
        virtual ~ns__ActivityLog() { }
        /// Friend allocator used by soap_new_ns__ActivityLog(struct soap*, int)
        friend SOAP_FMAC1 ns__ActivityLog * SOAP_FMAC2 Server_Soap_instantiate_ns__ActivityLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:238 */
#ifndef SOAP_TYPE_ns__UserLog
#define SOAP_TYPE_ns__UserLog (48)
/* complex XSD type 'ns:UserLog': */
class SOAP_CMAC ns__UserLog {
      public:
        /// Required element 'ulRange' of XSD type 'ns:ReportRange'
        ns__ReportRange ulRange;
        /// Optional element 'ulData' of XSD type 'xsd:string'
        std::string ulData;	///< default = ""
        /// Required element 'ulUser' of XSD type 'ns:User'
        ns__User ulUser;
      public:
        /// Return unique type id SOAP_TYPE_ns__UserLog
        virtual int soap_type(void) const { return SOAP_TYPE_ns__UserLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__UserLog, default initialized and not managed by a soap context
        virtual ns__UserLog *soap_alloc(void) const { return SOAP_NEW(ns__UserLog); }
      public:
        /// Constructor with initializations
        ns__UserLog()
        {
          ulData = "";
        }
        virtual ~ns__UserLog() { }
        /// Friend allocator used by soap_new_ns__UserLog(struct soap*, int)
        friend SOAP_FMAC1 ns__UserLog * SOAP_FMAC2 Server_Soap_instantiate_ns__UserLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:245 */
#ifndef SOAP_TYPE_ns__DeviceStatusLog
#define SOAP_TYPE_ns__DeviceStatusLog (49)
/* complex XSD type 'ns:DeviceStatusLog': */
class SOAP_CMAC ns__DeviceStatusLog {
      public:
        /// Optional element 'dslDateTime' of XSD type 'xsd:dateTime'
        time_t dslDateTime;	///< default = 0
        /// Required element 'dslDevice' of XSD type 'ns:Device'
        ns__Device dslDevice;
        /// Required element 'dslErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode dslErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__DeviceStatusLog
        virtual int soap_type(void) const { return SOAP_TYPE_ns__DeviceStatusLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__DeviceStatusLog, default initialized and not managed by a soap context
        virtual ns__DeviceStatusLog *soap_alloc(void) const { return SOAP_NEW(ns__DeviceStatusLog); }
      public:
        /// Constructor with initializations
        ns__DeviceStatusLog()
        {
          dslDateTime = 0;
        }
        virtual ~ns__DeviceStatusLog() { }
        /// Friend allocator used by soap_new_ns__DeviceStatusLog(struct soap*, int)
        friend SOAP_FMAC1 ns__DeviceStatusLog * SOAP_FMAC2 Server_Soap_instantiate_ns__DeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:252 */
#ifndef SOAP_TYPE_ns__DeviceStatusLogList
#define SOAP_TYPE_ns__DeviceStatusLogList (50)
/* complex XSD type 'ns:DeviceStatusLogList': */
class SOAP_CMAC ns__DeviceStatusLogList {
      public:
        /// Optional element 'dsllStatus' of XSD type 'ns:DeviceStatusLog'
        std::vector<ns__DeviceStatusLog> dsllStatus;
        /// Required element 'dsllErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode dsllErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__DeviceStatusLogList
        virtual int soap_type(void) const { return SOAP_TYPE_ns__DeviceStatusLogList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__DeviceStatusLogList, default initialized and not managed by a soap context
        virtual ns__DeviceStatusLogList *soap_alloc(void) const { return SOAP_NEW(ns__DeviceStatusLogList); }
      public:
        /// Constructor with initializations
        ns__DeviceStatusLogList()
        {
        }
        virtual ~ns__DeviceStatusLogList() { }
        /// Friend allocator used by soap_new_ns__DeviceStatusLogList(struct soap*, int)
        friend SOAP_FMAC1 ns__DeviceStatusLogList * SOAP_FMAC2 Server_Soap_instantiate_ns__DeviceStatusLogList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:259 */
#ifndef SOAP_TYPE_ns__DeviceStatus
#define SOAP_TYPE_ns__DeviceStatus (52)
/* complex XSD type 'ns:DeviceStatus': */
class SOAP_CMAC ns__DeviceStatus {
      public:
        /// Required element 'dsRange' of XSD type 'ns:ReportRange'
        ns__ReportRange dsRange;
        /// Optional element 'dsDevice' of XSD type 'ns:Device'
        std::vector<ns__Device> dsDevice;
        /// Optional element 'dsErr' of XSD type 'xsd:string'
        std::vector<std::string> dsErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__DeviceStatus
        virtual int soap_type(void) const { return SOAP_TYPE_ns__DeviceStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__DeviceStatus, default initialized and not managed by a soap context
        virtual ns__DeviceStatus *soap_alloc(void) const { return SOAP_NEW(ns__DeviceStatus); }
      public:
        /// Constructor with initializations
        ns__DeviceStatus()
        {
        }
        virtual ~ns__DeviceStatus() { }
        /// Friend allocator used by soap_new_ns__DeviceStatus(struct soap*, int)
        friend SOAP_FMAC1 ns__DeviceStatus * SOAP_FMAC2 Server_Soap_instantiate_ns__DeviceStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:266 */
#ifndef SOAP_TYPE_ns__ErrorLog
#define SOAP_TYPE_ns__ErrorLog (55)
/* complex XSD type 'ns:ErrorLog': */
class SOAP_CMAC ns__ErrorLog {
      public:
        /// Optional element 'elDateTime' of XSD type 'xsd:dateTime'
        time_t elDateTime;	///< default = 0
        /// Required element 'elDevice' of XSD type 'ns:Device'
        ns__Device elDevice;
        /// Required element 'elErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode elErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__ErrorLog
        virtual int soap_type(void) const { return SOAP_TYPE_ns__ErrorLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ErrorLog, default initialized and not managed by a soap context
        virtual ns__ErrorLog *soap_alloc(void) const { return SOAP_NEW(ns__ErrorLog); }
      public:
        /// Constructor with initializations
        ns__ErrorLog()
        {
          elDateTime = 0;
        }
        virtual ~ns__ErrorLog() { }
        /// Friend allocator used by soap_new_ns__ErrorLog(struct soap*, int)
        friend SOAP_FMAC1 ns__ErrorLog * SOAP_FMAC2 Server_Soap_instantiate_ns__ErrorLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:273 */
#ifndef SOAP_TYPE_ns__UserDevice
#define SOAP_TYPE_ns__UserDevice (56)
/* complex XSD type 'ns:UserDevice': */
class SOAP_CMAC ns__UserDevice {
      public:
        /// Required element 'udUser' of XSD type 'ns:User'
        ns__User udUser;
        /// Optional element 'udDevs' of XSD type 'ns:Device'
        std::vector<ns__Device> udDevs;
        /// Required element 'udErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode udErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__UserDevice
        virtual int soap_type(void) const { return SOAP_TYPE_ns__UserDevice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__UserDevice, default initialized and not managed by a soap context
        virtual ns__UserDevice *soap_alloc(void) const { return SOAP_NEW(ns__UserDevice); }
      public:
        /// Constructor with initializations
        ns__UserDevice()
        {
        }
        virtual ~ns__UserDevice() { }
        /// Friend allocator used by soap_new_ns__UserDevice(struct soap*, int)
        friend SOAP_FMAC1 ns__UserDevice * SOAP_FMAC2 Server_Soap_instantiate_ns__UserDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:280 */
#ifndef SOAP_TYPE_ns__DataBase
#define SOAP_TYPE_ns__DataBase (57)
/* complex XSD type 'ns:DataBase': */
class SOAP_CMAC ns__DataBase {
      public:
        /// Optional element 'dbServer' of XSD type 'xsd:string'
        std::string dbServer;	///< default = ""
        /// Optional element 'bdPort' of XSD type 'xsd:int'
        int bdPort;	///< default = 0
        /// Optional element 'dbUser' of XSD type 'xsd:string'
        std::string dbUser;	///< default = ""
        /// Optional element 'dbPassWord' of XSD type 'xsd:string'
        std::string dbPassWord;	///< default = ""
        /// Required element 'dbErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode dbErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__DataBase
        virtual int soap_type(void) const { return SOAP_TYPE_ns__DataBase; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__DataBase, default initialized and not managed by a soap context
        virtual ns__DataBase *soap_alloc(void) const { return SOAP_NEW(ns__DataBase); }
      public:
        /// Constructor with initializations
        ns__DataBase()
        {
          dbServer = "";
          bdPort = 0;
          dbUser = "";
          dbPassWord = "";
        }
        virtual ~ns__DataBase() { }
        /// Friend allocator used by soap_new_ns__DataBase(struct soap*, int)
        friend SOAP_FMAC1 ns__DataBase * SOAP_FMAC2 Server_Soap_instantiate_ns__DataBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:289 */
#ifndef SOAP_TYPE_ns__ServerOptions
#define SOAP_TYPE_ns__ServerOptions (58)
/* complex XSD type 'ns:ServerOptions': */
class SOAP_CMAC ns__ServerOptions {
      public:
        /// Required element 'soDataBase' of XSD type 'ns:DataBase'
        ns__DataBase soDataBase;
        /// Optional element 'soRepeat' of XSD type 'xsd:int'
        int soRepeat;	///< default = 0
        /// Required element 'soErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode soErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__ServerOptions
        virtual int soap_type(void) const { return SOAP_TYPE_ns__ServerOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__ServerOptions, default initialized and not managed by a soap context
        virtual ns__ServerOptions *soap_alloc(void) const { return SOAP_NEW(ns__ServerOptions); }
      public:
        /// Constructor with initializations
        ns__ServerOptions()
        {
          soRepeat = 0;
        }
        virtual ~ns__ServerOptions() { }
        /// Friend allocator used by soap_new_ns__ServerOptions(struct soap*, int)
        friend SOAP_FMAC1 ns__ServerOptions * SOAP_FMAC2 Server_Soap_instantiate_ns__ServerOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:296 */
#ifndef SOAP_TYPE_ns__CityLocation
#define SOAP_TYPE_ns__CityLocation (59)
/* complex XSD type 'ns:CityLocation': */
class SOAP_CMAC ns__CityLocation {
      public:
        /// Optional element 'clCity' of XSD type 'xsd:string'
        std::string clCity;	///< default = ""
        /// Optional element 'clLocations' of XSD type 'xsd:string'
        std::vector<std::string> clLocations;
        /// Required element 'clErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode clErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__CityLocation
        virtual int soap_type(void) const { return SOAP_TYPE_ns__CityLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__CityLocation, default initialized and not managed by a soap context
        virtual ns__CityLocation *soap_alloc(void) const { return SOAP_NEW(ns__CityLocation); }
      public:
        /// Constructor with initializations
        ns__CityLocation()
        {
          clCity = "";
        }
        virtual ~ns__CityLocation() { }
        /// Friend allocator used by soap_new_ns__CityLocation(struct soap*, int)
        friend SOAP_FMAC1 ns__CityLocation * SOAP_FMAC2 Server_Soap_instantiate_ns__CityLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:303 */
#ifndef SOAP_TYPE_ns__AllCityLocatoins
#define SOAP_TYPE_ns__AllCityLocatoins (61)
/* complex XSD type 'ns:AllCityLocatoins': */
class SOAP_CMAC ns__AllCityLocatoins {
      public:
        /// Optional element 'aclCityLocatoins' of XSD type 'ns:CityLocation'
        std::vector<ns__CityLocation> aclCityLocatoins;
        /// Required element 'aclErr' of XSD type 'ns:ErrorCode'
        ns__ErrorCode aclErr;
      public:
        /// Return unique type id SOAP_TYPE_ns__AllCityLocatoins
        virtual int soap_type(void) const { return SOAP_TYPE_ns__AllCityLocatoins; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns__AllCityLocatoins, default initialized and not managed by a soap context
        virtual ns__AllCityLocatoins *soap_alloc(void) const { return SOAP_NEW(ns__AllCityLocatoins); }
      public:
        /// Constructor with initializations
        ns__AllCityLocatoins()
        {
        }
        virtual ~ns__AllCityLocatoins() { }
        /// Friend allocator used by soap_new_ns__AllCityLocatoins(struct soap*, int)
        friend SOAP_FMAC1 ns__AllCityLocatoins * SOAP_FMAC2 Server_Soap_instantiate_ns__AllCityLocatoins(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:311 */
#ifndef SOAP_TYPE_ns__GetDeviceStatus
#define SOAP_TYPE_ns__GetDeviceStatus (65)
/* complex XSD type 'ns:GetDeviceStatus': */
struct SOAP_CMAC ns__GetDeviceStatus {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestDevice' of XSD type 'ns:Device' */
        ns__Device requestDevice;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetDeviceStatus */
        int soap_type() const { return SOAP_TYPE_ns__GetDeviceStatus; }
        /** Constructor with member initializations */
        ns__GetDeviceStatus()
        {
        }
        /** Friend allocator used by soap_new_ns__GetDeviceStatus(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetDeviceStatus * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDeviceStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:314 */
#ifndef SOAP_TYPE_ns__GetDeviceStatusSMS
#define SOAP_TYPE_ns__GetDeviceStatusSMS (68)
/* complex XSD type 'ns:GetDeviceStatusSMS': */
struct SOAP_CMAC ns__GetDeviceStatusSMS {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestDevice' of XSD type 'ns:Device' */
        ns__Device requestDevice;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetDeviceStatusSMS */
        int soap_type() const { return SOAP_TYPE_ns__GetDeviceStatusSMS; }
        /** Constructor with member initializations */
        ns__GetDeviceStatusSMS()
        {
        }
        /** Friend allocator used by soap_new_ns__GetDeviceStatusSMS(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetDeviceStatusSMS * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDeviceStatusSMS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:317 */
#ifndef SOAP_TYPE_ns__GetAllDeviceStatus
#define SOAP_TYPE_ns__GetAllDeviceStatus (71)
/* complex XSD type 'ns:GetAllDeviceStatus': */
struct SOAP_CMAC ns__GetAllDeviceStatus {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetAllDeviceStatus */
        int soap_type() const { return SOAP_TYPE_ns__GetAllDeviceStatus; }
        /** Constructor with member initializations */
        ns__GetAllDeviceStatus()
        {
        }
        /** Friend allocator used by soap_new_ns__GetAllDeviceStatus(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetAllDeviceStatus * SOAP_FMAC2 Server_Soap_instantiate_ns__GetAllDeviceStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:320 */
#ifndef SOAP_TYPE_ns__GetDevicePicture
#define SOAP_TYPE_ns__GetDevicePicture (73)
/* complex XSD type 'ns:GetDevicePicture': */
struct SOAP_CMAC ns__GetDevicePicture {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestDevice' of XSD type 'ns:Device' */
        ns__Device requestDevice;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetDevicePicture */
        int soap_type() const { return SOAP_TYPE_ns__GetDevicePicture; }
        /** Constructor with member initializations */
        ns__GetDevicePicture()
        {
        }
        /** Friend allocator used by soap_new_ns__GetDevicePicture(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetDevicePicture * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDevicePicture(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:323 */
#ifndef SOAP_TYPE_ns__GetDevicePicturePart
#define SOAP_TYPE_ns__GetDevicePicturePart (75)
/* complex XSD type 'ns:GetDevicePicturePart': */
struct SOAP_CMAC ns__GetDevicePicturePart {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestDevice' of XSD type 'ns:Device' */
        ns__Device requestDevice;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetDevicePicturePart */
        int soap_type() const { return SOAP_TYPE_ns__GetDevicePicturePart; }
        /** Constructor with member initializations */
        ns__GetDevicePicturePart()
        {
        }
        /** Friend allocator used by soap_new_ns__GetDevicePicturePart(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetDevicePicturePart * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDevicePicturePart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:326 */
#ifndef SOAP_TYPE_ns__SetDeviceSettingResponse
#define SOAP_TYPE_ns__SetDeviceSettingResponse (79)
/* complex XSD type 'ns:SetDeviceSettingResponse': */
struct SOAP_CMAC ns__SetDeviceSettingResponse {
      public:
        /** Required element 'responseError' of XSD type 'ns:ErrorCode' */
        std::vector<ns__ErrorCode> responseError;
      public:
        /** Return unique type id SOAP_TYPE_ns__SetDeviceSettingResponse */
        int soap_type() const { return SOAP_TYPE_ns__SetDeviceSettingResponse; }
        /** Constructor with member initializations */
        ns__SetDeviceSettingResponse()
        {
        }
        /** Friend allocator used by soap_new_ns__SetDeviceSettingResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__SetDeviceSettingResponse * SOAP_FMAC2 Server_Soap_instantiate_ns__SetDeviceSettingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:326 */
#ifndef SOAP_TYPE_ns__SetDeviceSetting
#define SOAP_TYPE_ns__SetDeviceSetting (80)
/* complex XSD type 'ns:SetDeviceSetting': */
struct SOAP_CMAC ns__SetDeviceSetting {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestDevice' of XSD type 'ns:Device' */
        ns__Device requestDevice;
      public:
        /** Return unique type id SOAP_TYPE_ns__SetDeviceSetting */
        int soap_type() const { return SOAP_TYPE_ns__SetDeviceSetting; }
        /** Constructor with member initializations */
        ns__SetDeviceSetting()
        {
        }
        /** Friend allocator used by soap_new_ns__SetDeviceSetting(struct soap*, int) */
        friend SOAP_FMAC1 ns__SetDeviceSetting * SOAP_FMAC2 Server_Soap_instantiate_ns__SetDeviceSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:329 */
#ifndef SOAP_TYPE_ns__SetDeviceSettingSMS
#define SOAP_TYPE_ns__SetDeviceSettingSMS (82)
/* complex XSD type 'ns:SetDeviceSettingSMS': */
struct SOAP_CMAC ns__SetDeviceSettingSMS {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestDevice' of XSD type 'ns:Device' */
        ns__Device requestDevice;
      public:
        /** Return unique type id SOAP_TYPE_ns__SetDeviceSettingSMS */
        int soap_type() const { return SOAP_TYPE_ns__SetDeviceSettingSMS; }
        /** Constructor with member initializations */
        ns__SetDeviceSettingSMS()
        {
        }
        /** Friend allocator used by soap_new_ns__SetDeviceSettingSMS(struct soap*, int) */
        friend SOAP_FMAC1 ns__SetDeviceSettingSMS * SOAP_FMAC2 Server_Soap_instantiate_ns__SetDeviceSettingSMS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:332 */
#ifndef SOAP_TYPE_ns__SetAllDeviceSettingResponse
#define SOAP_TYPE_ns__SetAllDeviceSettingResponse (84)
/* complex XSD type 'ns:SetAllDeviceSettingResponse': */
struct SOAP_CMAC ns__SetAllDeviceSettingResponse {
      public:
        /** Required element 'responseError' of XSD type 'ns:ErrorCode' */
        std::vector<ns__ErrorCode> responseError;
      public:
        /** Return unique type id SOAP_TYPE_ns__SetAllDeviceSettingResponse */
        int soap_type() const { return SOAP_TYPE_ns__SetAllDeviceSettingResponse; }
        /** Constructor with member initializations */
        ns__SetAllDeviceSettingResponse()
        {
        }
        /** Friend allocator used by soap_new_ns__SetAllDeviceSettingResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__SetAllDeviceSettingResponse * SOAP_FMAC2 Server_Soap_instantiate_ns__SetAllDeviceSettingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:332 */
#ifndef SOAP_TYPE_ns__SetAllDeviceSetting
#define SOAP_TYPE_ns__SetAllDeviceSetting (85)
/* complex XSD type 'ns:SetAllDeviceSetting': */
struct SOAP_CMAC ns__SetAllDeviceSetting {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestDevice' of XSD type 'ns:Device' */
        std::vector<ns__Device> requestDevice;
      public:
        /** Return unique type id SOAP_TYPE_ns__SetAllDeviceSetting */
        int soap_type() const { return SOAP_TYPE_ns__SetAllDeviceSetting; }
        /** Constructor with member initializations */
        ns__SetAllDeviceSetting()
        {
        }
        /** Friend allocator used by soap_new_ns__SetAllDeviceSetting(struct soap*, int) */
        friend SOAP_FMAC1 ns__SetAllDeviceSetting * SOAP_FMAC2 Server_Soap_instantiate_ns__SetAllDeviceSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:335 */
#ifndef SOAP_TYPE_ns__DeleteDevicesResponse
#define SOAP_TYPE_ns__DeleteDevicesResponse (87)
/* complex XSD type 'ns:DeleteDevicesResponse': */
struct SOAP_CMAC ns__DeleteDevicesResponse {
      public:
        /** Required element 'responseError' of XSD type 'ns:ErrorCode' */
        std::vector<ns__ErrorCode> responseError;
      public:
        /** Return unique type id SOAP_TYPE_ns__DeleteDevicesResponse */
        int soap_type() const { return SOAP_TYPE_ns__DeleteDevicesResponse; }
        /** Constructor with member initializations */
        ns__DeleteDevicesResponse()
        {
        }
        /** Friend allocator used by soap_new_ns__DeleteDevicesResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__DeleteDevicesResponse * SOAP_FMAC2 Server_Soap_instantiate_ns__DeleteDevicesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:335 */
#ifndef SOAP_TYPE_ns__DeleteDevices
#define SOAP_TYPE_ns__DeleteDevices (88)
/* complex XSD type 'ns:DeleteDevices': */
struct SOAP_CMAC ns__DeleteDevices {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestDeviceList' of XSD type 'ns:Device' */
        std::vector<ns__Device> requestDeviceList;
      public:
        /** Return unique type id SOAP_TYPE_ns__DeleteDevices */
        int soap_type() const { return SOAP_TYPE_ns__DeleteDevices; }
        /** Constructor with member initializations */
        ns__DeleteDevices()
        {
        }
        /** Friend allocator used by soap_new_ns__DeleteDevices(struct soap*, int) */
        friend SOAP_FMAC1 ns__DeleteDevices * SOAP_FMAC2 Server_Soap_instantiate_ns__DeleteDevices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:339 */
#ifndef SOAP_TYPE_ns__SetDeviceCalibration
#define SOAP_TYPE_ns__SetDeviceCalibration (90)
/* complex XSD type 'ns:SetDeviceCalibration': */
struct SOAP_CMAC ns__SetDeviceCalibration {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestDevice' of XSD type 'ns:Device' */
        ns__Device requestDevice;
        /** Required element 'requestCalibrationList' of XSD type 'ns:CalibrationList' */
        ns__CalibrationList requestCalibrationList;
      public:
        /** Return unique type id SOAP_TYPE_ns__SetDeviceCalibration */
        int soap_type() const { return SOAP_TYPE_ns__SetDeviceCalibration; }
        /** Constructor with member initializations */
        ns__SetDeviceCalibration()
        {
        }
        /** Friend allocator used by soap_new_ns__SetDeviceCalibration(struct soap*, int) */
        friend SOAP_FMAC1 ns__SetDeviceCalibration * SOAP_FMAC2 Server_Soap_instantiate_ns__SetDeviceCalibration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:342 */
#ifndef SOAP_TYPE_ns__GetDeviceCalibration
#define SOAP_TYPE_ns__GetDeviceCalibration (93)
/* complex XSD type 'ns:GetDeviceCalibration': */
struct SOAP_CMAC ns__GetDeviceCalibration {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestDevice' of XSD type 'ns:Device' */
        ns__Device requestDevice;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetDeviceCalibration */
        int soap_type() const { return SOAP_TYPE_ns__GetDeviceCalibration; }
        /** Constructor with member initializations */
        ns__GetDeviceCalibration()
        {
        }
        /** Friend allocator used by soap_new_ns__GetDeviceCalibration(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetDeviceCalibration * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDeviceCalibration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:346 */
#ifndef SOAP_TYPE_ns__Login
#define SOAP_TYPE_ns__Login (96)
/* complex XSD type 'ns:Login': */
struct SOAP_CMAC ns__Login {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
      public:
        /** Return unique type id SOAP_TYPE_ns__Login */
        int soap_type() const { return SOAP_TYPE_ns__Login; }
        /** Constructor with member initializations */
        ns__Login()
        {
        }
        /** Friend allocator used by soap_new_ns__Login(struct soap*, int) */
        friend SOAP_FMAC1 ns__Login * SOAP_FMAC2 Server_Soap_instantiate_ns__Login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:349 */
#ifndef SOAP_TYPE_ns__GetUserDeviceList
#define SOAP_TYPE_ns__GetUserDeviceList (98)
/* complex XSD type 'ns:GetUserDeviceList': */
struct SOAP_CMAC ns__GetUserDeviceList {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetUserDeviceList */
        int soap_type() const { return SOAP_TYPE_ns__GetUserDeviceList; }
        /** Constructor with member initializations */
        ns__GetUserDeviceList()
        {
        }
        /** Friend allocator used by soap_new_ns__GetUserDeviceList(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetUserDeviceList * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserDeviceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:353 */
#ifndef SOAP_TYPE_ns__GetUsersList
#define SOAP_TYPE_ns__GetUsersList (101)
/* complex XSD type 'ns:GetUsersList': */
struct SOAP_CMAC ns__GetUsersList {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetUsersList */
        int soap_type() const { return SOAP_TYPE_ns__GetUsersList; }
        /** Constructor with member initializations */
        ns__GetUsersList()
        {
        }
        /** Friend allocator used by soap_new_ns__GetUsersList(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetUsersList * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUsersList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:356 */
#ifndef SOAP_TYPE_ns__AddUser
#define SOAP_TYPE_ns__AddUser (103)
/* complex XSD type 'ns:AddUser': */
struct SOAP_CMAC ns__AddUser {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestNewUser' of XSD type 'ns:User' */
        ns__User requestNewUser;
      public:
        /** Return unique type id SOAP_TYPE_ns__AddUser */
        int soap_type() const { return SOAP_TYPE_ns__AddUser; }
        /** Constructor with member initializations */
        ns__AddUser()
        {
        }
        /** Friend allocator used by soap_new_ns__AddUser(struct soap*, int) */
        friend SOAP_FMAC1 ns__AddUser * SOAP_FMAC2 Server_Soap_instantiate_ns__AddUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:359 */
#ifndef SOAP_TYPE_ns__UpdateUser
#define SOAP_TYPE_ns__UpdateUser (105)
/* complex XSD type 'ns:UpdateUser': */
struct SOAP_CMAC ns__UpdateUser {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestNewUser' of XSD type 'ns:User' */
        ns__User requestNewUser;
      public:
        /** Return unique type id SOAP_TYPE_ns__UpdateUser */
        int soap_type() const { return SOAP_TYPE_ns__UpdateUser; }
        /** Constructor with member initializations */
        ns__UpdateUser()
        {
        }
        /** Friend allocator used by soap_new_ns__UpdateUser(struct soap*, int) */
        friend SOAP_FMAC1 ns__UpdateUser * SOAP_FMAC2 Server_Soap_instantiate_ns__UpdateUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:362 */
#ifndef SOAP_TYPE_ns__DeleteUser
#define SOAP_TYPE_ns__DeleteUser (107)
/* complex XSD type 'ns:DeleteUser': */
struct SOAP_CMAC ns__DeleteUser {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestDeleteUser' of XSD type 'ns:User' */
        ns__User requestDeleteUser;
      public:
        /** Return unique type id SOAP_TYPE_ns__DeleteUser */
        int soap_type() const { return SOAP_TYPE_ns__DeleteUser; }
        /** Constructor with member initializations */
        ns__DeleteUser()
        {
        }
        /** Friend allocator used by soap_new_ns__DeleteUser(struct soap*, int) */
        friend SOAP_FMAC1 ns__DeleteUser * SOAP_FMAC2 Server_Soap_instantiate_ns__DeleteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:365 */
#ifndef SOAP_TYPE_ns__AssignDeviceToUser
#define SOAP_TYPE_ns__AssignDeviceToUser (109)
/* complex XSD type 'ns:AssignDeviceToUser': */
struct SOAP_CMAC ns__AssignDeviceToUser {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestUserDevice' of XSD type 'ns:UserDevice' */
        ns__UserDevice requestUserDevice;
      public:
        /** Return unique type id SOAP_TYPE_ns__AssignDeviceToUser */
        int soap_type() const { return SOAP_TYPE_ns__AssignDeviceToUser; }
        /** Constructor with member initializations */
        ns__AssignDeviceToUser()
        {
        }
        /** Friend allocator used by soap_new_ns__AssignDeviceToUser(struct soap*, int) */
        friend SOAP_FMAC1 ns__AssignDeviceToUser * SOAP_FMAC2 Server_Soap_instantiate_ns__AssignDeviceToUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:368 */
#ifndef SOAP_TYPE_ns__DeleteDeviceFromUser
#define SOAP_TYPE_ns__DeleteDeviceFromUser (111)
/* complex XSD type 'ns:DeleteDeviceFromUser': */
struct SOAP_CMAC ns__DeleteDeviceFromUser {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestUserDevice' of XSD type 'ns:UserDevice' */
        ns__UserDevice requestUserDevice;
      public:
        /** Return unique type id SOAP_TYPE_ns__DeleteDeviceFromUser */
        int soap_type() const { return SOAP_TYPE_ns__DeleteDeviceFromUser; }
        /** Constructor with member initializations */
        ns__DeleteDeviceFromUser()
        {
        }
        /** Friend allocator used by soap_new_ns__DeleteDeviceFromUser(struct soap*, int) */
        friend SOAP_FMAC1 ns__DeleteDeviceFromUser * SOAP_FMAC2 Server_Soap_instantiate_ns__DeleteDeviceFromUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:371 */
#ifndef SOAP_TYPE_ns__GetUserDevices
#define SOAP_TYPE_ns__GetUserDevices (113)
/* complex XSD type 'ns:GetUserDevices': */
struct SOAP_CMAC ns__GetUserDevices {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestSelectedUser' of XSD type 'ns:User' */
        ns__User requestSelectedUser;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetUserDevices */
        int soap_type() const { return SOAP_TYPE_ns__GetUserDevices; }
        /** Constructor with member initializations */
        ns__GetUserDevices()
        {
        }
        /** Friend allocator used by soap_new_ns__GetUserDevices(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetUserDevices * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserDevices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:375 */
#ifndef SOAP_TYPE_ns__SaveActivityLog
#define SOAP_TYPE_ns__SaveActivityLog (115)
/* complex XSD type 'ns:SaveActivityLog': */
struct SOAP_CMAC ns__SaveActivityLog {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestActivityLog' of XSD type 'ns:ActivityLog' */
        ns__ActivityLog requestActivityLog;
      public:
        /** Return unique type id SOAP_TYPE_ns__SaveActivityLog */
        int soap_type() const { return SOAP_TYPE_ns__SaveActivityLog; }
        /** Constructor with member initializations */
        ns__SaveActivityLog()
        {
        }
        /** Friend allocator used by soap_new_ns__SaveActivityLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__SaveActivityLog * SOAP_FMAC2 Server_Soap_instantiate_ns__SaveActivityLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:378 */
#ifndef SOAP_TYPE_ns__GetActivityLogResponse
#define SOAP_TYPE_ns__GetActivityLogResponse (119)
/* complex XSD type 'ns:GetActivityLogResponse': */
struct SOAP_CMAC ns__GetActivityLogResponse {
      public:
        /** Required element 'responseActivityLog' of XSD type 'ns:ActivityLog' */
        std::vector<ns__ActivityLog> responseActivityLog;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetActivityLogResponse */
        int soap_type() const { return SOAP_TYPE_ns__GetActivityLogResponse; }
        /** Constructor with member initializations */
        ns__GetActivityLogResponse()
        {
        }
        /** Friend allocator used by soap_new_ns__GetActivityLogResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetActivityLogResponse * SOAP_FMAC2 Server_Soap_instantiate_ns__GetActivityLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:378 */
#ifndef SOAP_TYPE_ns__GetActivityLog
#define SOAP_TYPE_ns__GetActivityLog (120)
/* complex XSD type 'ns:GetActivityLog': */
struct SOAP_CMAC ns__GetActivityLog {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestReport' of XSD type 'ns:ReportRange' */
        ns__ReportRange requestReport;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetActivityLog */
        int soap_type() const { return SOAP_TYPE_ns__GetActivityLog; }
        /** Constructor with member initializations */
        ns__GetActivityLog()
        {
        }
        /** Friend allocator used by soap_new_ns__GetActivityLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetActivityLog * SOAP_FMAC2 Server_Soap_instantiate_ns__GetActivityLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:381 */
#ifndef SOAP_TYPE_ns__SaveUserLog
#define SOAP_TYPE_ns__SaveUserLog (122)
/* complex XSD type 'ns:SaveUserLog': */
struct SOAP_CMAC ns__SaveUserLog {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestActivityLog' of XSD type 'ns:UserLog' */
        ns__UserLog requestActivityLog;
      public:
        /** Return unique type id SOAP_TYPE_ns__SaveUserLog */
        int soap_type() const { return SOAP_TYPE_ns__SaveUserLog; }
        /** Constructor with member initializations */
        ns__SaveUserLog()
        {
        }
        /** Friend allocator used by soap_new_ns__SaveUserLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__SaveUserLog * SOAP_FMAC2 Server_Soap_instantiate_ns__SaveUserLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:384 */
#ifndef SOAP_TYPE_ns__GetUserLogResponse
#define SOAP_TYPE_ns__GetUserLogResponse (126)
/* complex XSD type 'ns:GetUserLogResponse': */
struct SOAP_CMAC ns__GetUserLogResponse {
      public:
        /** Required element 'responseActivityLog' of XSD type 'ns:UserLog' */
        std::vector<ns__UserLog> responseActivityLog;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetUserLogResponse */
        int soap_type() const { return SOAP_TYPE_ns__GetUserLogResponse; }
        /** Constructor with member initializations */
        ns__GetUserLogResponse()
        {
        }
        /** Friend allocator used by soap_new_ns__GetUserLogResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetUserLogResponse * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:384 */
#ifndef SOAP_TYPE_ns__GetUserLog
#define SOAP_TYPE_ns__GetUserLog (127)
/* complex XSD type 'ns:GetUserLog': */
struct SOAP_CMAC ns__GetUserLog {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestReport' of XSD type 'ns:ReportRange' */
        ns__ReportRange requestReport;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetUserLog */
        int soap_type() const { return SOAP_TYPE_ns__GetUserLog; }
        /** Constructor with member initializations */
        ns__GetUserLog()
        {
        }
        /** Friend allocator used by soap_new_ns__GetUserLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetUserLog * SOAP_FMAC2 Server_Soap_instantiate_ns__GetUserLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:387 */
#ifndef SOAP_TYPE_ns__SaveDeviceStatusLog
#define SOAP_TYPE_ns__SaveDeviceStatusLog (129)
/* complex XSD type 'ns:SaveDeviceStatusLog': */
struct SOAP_CMAC ns__SaveDeviceStatusLog {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestStatusLog' of XSD type 'ns:DeviceStatusLog' */
        ns__DeviceStatusLog requestStatusLog;
      public:
        /** Return unique type id SOAP_TYPE_ns__SaveDeviceStatusLog */
        int soap_type() const { return SOAP_TYPE_ns__SaveDeviceStatusLog; }
        /** Constructor with member initializations */
        ns__SaveDeviceStatusLog()
        {
        }
        /** Friend allocator used by soap_new_ns__SaveDeviceStatusLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__SaveDeviceStatusLog * SOAP_FMAC2 Server_Soap_instantiate_ns__SaveDeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:390 */
#ifndef SOAP_TYPE_ns__GetDeviceStatusLog
#define SOAP_TYPE_ns__GetDeviceStatusLog (132)
/* complex XSD type 'ns:GetDeviceStatusLog': */
struct SOAP_CMAC ns__GetDeviceStatusLog {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'requestStatusLog' of XSD type 'ns:DeviceStatus' */
        ns__DeviceStatus requestStatusLog;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetDeviceStatusLog */
        int soap_type() const { return SOAP_TYPE_ns__GetDeviceStatusLog; }
        /** Constructor with member initializations */
        ns__GetDeviceStatusLog()
        {
        }
        /** Friend allocator used by soap_new_ns__GetDeviceStatusLog(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetDeviceStatusLog * SOAP_FMAC2 Server_Soap_instantiate_ns__GetDeviceStatusLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:394 */
#ifndef SOAP_TYPE_ns__GetServerOptions
#define SOAP_TYPE_ns__GetServerOptions (135)
/* complex XSD type 'ns:GetServerOptions': */
struct SOAP_CMAC ns__GetServerOptions {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetServerOptions */
        int soap_type() const { return SOAP_TYPE_ns__GetServerOptions; }
        /** Constructor with member initializations */
        ns__GetServerOptions()
        {
        }
        /** Friend allocator used by soap_new_ns__GetServerOptions(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetServerOptions * SOAP_FMAC2 Server_Soap_instantiate_ns__GetServerOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:397 */
#ifndef SOAP_TYPE_ns__SetServerOptions
#define SOAP_TYPE_ns__SetServerOptions (137)
/* complex XSD type 'ns:SetServerOptions': */
struct SOAP_CMAC ns__SetServerOptions {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'serverOptions' of XSD type 'ns:ServerOptions' */
        ns__ServerOptions serverOptions;
      public:
        /** Return unique type id SOAP_TYPE_ns__SetServerOptions */
        int soap_type() const { return SOAP_TYPE_ns__SetServerOptions; }
        /** Constructor with member initializations */
        ns__SetServerOptions()
        {
        }
        /** Friend allocator used by soap_new_ns__SetServerOptions(struct soap*, int) */
        friend SOAP_FMAC1 ns__SetServerOptions * SOAP_FMAC2 Server_Soap_instantiate_ns__SetServerOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:401 */
#ifndef SOAP_TYPE_ns__GetCityAndLocations
#define SOAP_TYPE_ns__GetCityAndLocations (140)
/* complex XSD type 'ns:GetCityAndLocations': */
struct SOAP_CMAC ns__GetCityAndLocations {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
      public:
        /** Return unique type id SOAP_TYPE_ns__GetCityAndLocations */
        int soap_type() const { return SOAP_TYPE_ns__GetCityAndLocations; }
        /** Constructor with member initializations */
        ns__GetCityAndLocations()
        {
        }
        /** Friend allocator used by soap_new_ns__GetCityAndLocations(struct soap*, int) */
        friend SOAP_FMAC1 ns__GetCityAndLocations * SOAP_FMAC2 Server_Soap_instantiate_ns__GetCityAndLocations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:404 */
#ifndef SOAP_TYPE_ns__ChangeCityName
#define SOAP_TYPE_ns__ChangeCityName (142)
/* complex XSD type 'ns:ChangeCityName': */
struct SOAP_CMAC ns__ChangeCityName {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'oldCityName' of XSD type 'xsd:string' */
        std::string oldCityName;
        /** Required element 'newCityName' of XSD type 'xsd:string' */
        std::string newCityName;
      public:
        /** Return unique type id SOAP_TYPE_ns__ChangeCityName */
        int soap_type() const { return SOAP_TYPE_ns__ChangeCityName; }
        /** Constructor with member initializations */
        ns__ChangeCityName()
        {
        }
        /** Friend allocator used by soap_new_ns__ChangeCityName(struct soap*, int) */
        friend SOAP_FMAC1 ns__ChangeCityName * SOAP_FMAC2 Server_Soap_instantiate_ns__ChangeCityName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:407 */
#ifndef SOAP_TYPE_ns__ChangeLocationName
#define SOAP_TYPE_ns__ChangeLocationName (144)
/* complex XSD type 'ns:ChangeLocationName': */
struct SOAP_CMAC ns__ChangeLocationName {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'oldCityName' of XSD type 'xsd:string' */
        std::string oldCityName;
        /** Required element 'newCityName' of XSD type 'xsd:string' */
        std::string newCityName;
        /** Required element 'oldLocationName' of XSD type 'xsd:string' */
        std::string oldLocationName;
        /** Required element 'newLocationName' of XSD type 'xsd:string' */
        std::string newLocationName;
      public:
        /** Return unique type id SOAP_TYPE_ns__ChangeLocationName */
        int soap_type() const { return SOAP_TYPE_ns__ChangeLocationName; }
        /** Constructor with member initializations */
        ns__ChangeLocationName()
        {
        }
        /** Friend allocator used by soap_new_ns__ChangeLocationName(struct soap*, int) */
        friend SOAP_FMAC1 ns__ChangeLocationName * SOAP_FMAC2 Server_Soap_instantiate_ns__ChangeLocationName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:410 */
#ifndef SOAP_TYPE_ns__ChangeDeviceName
#define SOAP_TYPE_ns__ChangeDeviceName (146)
/* complex XSD type 'ns:ChangeDeviceName': */
struct SOAP_CMAC ns__ChangeDeviceName {
      public:
        /** Required element 'requestUser' of XSD type 'ns:User' */
        ns__User requestUser;
        /** Required element 'deviceSerialNumber' of XSD type 'xsd:int' */
        int deviceSerialNumber;
        /** Required element 'newCityName' of XSD type 'xsd:string' */
        std::string newCityName;
        /** Required element 'newLocationName' of XSD type 'xsd:string' */
        std::string newLocationName;
        /** Required element 'newDeviceName' of XSD type 'xsd:string' */
        std::string newDeviceName;
      public:
        /** Return unique type id SOAP_TYPE_ns__ChangeDeviceName */
        int soap_type() const { return SOAP_TYPE_ns__ChangeDeviceName; }
        /** Constructor with member initializations */
        ns__ChangeDeviceName()
        {
          deviceSerialNumber = (int)0;
        }
        /** Friend allocator used by soap_new_ns__ChangeDeviceName(struct soap*, int) */
        friend SOAP_FMAC1 ns__ChangeDeviceName * SOAP_FMAC2 Server_Soap_instantiate_ns__ChangeDeviceName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* source.h:410 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (147)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* source.h:410 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (148)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* source.h:410 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (150)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* source.h:410 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (153)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* source.h:410 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (154)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 Server_Soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* stlvector.h:53 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* stlvector.h:53 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* source.h:9 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (9)
typedef std::string xsd__string;
#endif

/* source.h:10 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (10)
typedef int xsd__int;
#endif

/* source.h:11 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (12)
typedef bool xsd__boolean;
#endif

/* source.h:12 */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (14)
typedef double xsd__double;
#endif

/* source.h:13 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (16)
typedef time_t xsd__dateTime;
#endif

/* source.h:14 */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (19)
typedef LONG64 xsd__long;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* xsd__int has binding name 'xsd__int' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (10)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* long has binding name 'long' for type 'xsd:long' */
#ifndef SOAP_TYPE_long
#define SOAP_TYPE_long (17)
#endif

/* xsd__long has binding name 'xsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (19)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (18)
#endif

/* xsd__double has binding name 'xsd__double' for type 'xsd:double' */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (14)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (13)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (16)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (15)
#endif

/* enum ns__RequestType has binding name 'ns__RequestType' for type 'ns:RequestType' */
#ifndef SOAP_TYPE_ns__RequestType
#define SOAP_TYPE_ns__RequestType (25)
#endif

/* enum ns__DeviceModel has binding name 'ns__DeviceModel' for type 'ns:DeviceModel' */
#ifndef SOAP_TYPE_ns__DeviceModel
#define SOAP_TYPE_ns__DeviceModel (24)
#endif

/* enum ns__SensorName has binding name 'ns__SensorName' for type 'ns:SensorName' */
#ifndef SOAP_TYPE_ns__SensorName
#define SOAP_TYPE_ns__SensorName (23)
#endif

/* enum ns__SensorType has binding name 'ns__SensorType' for type 'ns:SensorType' */
#ifndef SOAP_TYPE_ns__SensorType
#define SOAP_TYPE_ns__SensorType (22)
#endif

/* enum ns__UserType has binding name 'ns__UserType' for type 'ns:UserType' */
#ifndef SOAP_TYPE_ns__UserType
#define SOAP_TYPE_ns__UserType (21)
#endif

/* enum ns__SettingLevel has binding name 'ns__SettingLevel' for type 'ns:SettingLevel' */
#ifndef SOAP_TYPE_ns__SettingLevel
#define SOAP_TYPE_ns__SettingLevel (20)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (12)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (11)
#endif

/* ns__AllCityLocatoins has binding name 'ns__AllCityLocatoins' for type 'ns:AllCityLocatoins' */
#ifndef SOAP_TYPE_ns__AllCityLocatoins
#define SOAP_TYPE_ns__AllCityLocatoins (61)
#endif

/* ns__CityLocation has binding name 'ns__CityLocation' for type 'ns:CityLocation' */
#ifndef SOAP_TYPE_ns__CityLocation
#define SOAP_TYPE_ns__CityLocation (59)
#endif

/* ns__ServerOptions has binding name 'ns__ServerOptions' for type 'ns:ServerOptions' */
#ifndef SOAP_TYPE_ns__ServerOptions
#define SOAP_TYPE_ns__ServerOptions (58)
#endif

/* ns__DataBase has binding name 'ns__DataBase' for type 'ns:DataBase' */
#ifndef SOAP_TYPE_ns__DataBase
#define SOAP_TYPE_ns__DataBase (57)
#endif

/* ns__UserDevice has binding name 'ns__UserDevice' for type 'ns:UserDevice' */
#ifndef SOAP_TYPE_ns__UserDevice
#define SOAP_TYPE_ns__UserDevice (56)
#endif

/* ns__ErrorLog has binding name 'ns__ErrorLog' for type 'ns:ErrorLog' */
#ifndef SOAP_TYPE_ns__ErrorLog
#define SOAP_TYPE_ns__ErrorLog (55)
#endif

/* ns__DeviceStatus has binding name 'ns__DeviceStatus' for type 'ns:DeviceStatus' */
#ifndef SOAP_TYPE_ns__DeviceStatus
#define SOAP_TYPE_ns__DeviceStatus (52)
#endif

/* ns__DeviceStatusLogList has binding name 'ns__DeviceStatusLogList' for type 'ns:DeviceStatusLogList' */
#ifndef SOAP_TYPE_ns__DeviceStatusLogList
#define SOAP_TYPE_ns__DeviceStatusLogList (50)
#endif

/* ns__DeviceStatusLog has binding name 'ns__DeviceStatusLog' for type 'ns:DeviceStatusLog' */
#ifndef SOAP_TYPE_ns__DeviceStatusLog
#define SOAP_TYPE_ns__DeviceStatusLog (49)
#endif

/* ns__UserLog has binding name 'ns__UserLog' for type 'ns:UserLog' */
#ifndef SOAP_TYPE_ns__UserLog
#define SOAP_TYPE_ns__UserLog (48)
#endif

/* ns__ActivityLog has binding name 'ns__ActivityLog' for type 'ns:ActivityLog' */
#ifndef SOAP_TYPE_ns__ActivityLog
#define SOAP_TYPE_ns__ActivityLog (47)
#endif

/* ns__ReportRange has binding name 'ns__ReportRange' for type 'ns:ReportRange' */
#ifndef SOAP_TYPE_ns__ReportRange
#define SOAP_TYPE_ns__ReportRange (46)
#endif

/* ns__Device has binding name 'ns__Device' for type 'ns:Device' */
#ifndef SOAP_TYPE_ns__Device
#define SOAP_TYPE_ns__Device (42)
#endif

/* ns__Picture has binding name 'ns__Picture' for type 'ns:Picture' */
#ifndef SOAP_TYPE_ns__Picture
#define SOAP_TYPE_ns__Picture (40)
#endif

/* ns__PicturePart has binding name 'ns__PicturePart' for type 'ns:PicturePart' */
#ifndef SOAP_TYPE_ns__PicturePart
#define SOAP_TYPE_ns__PicturePart (39)
#endif

/* ns__Camera has binding name 'ns__Camera' for type 'ns:Camera' */
#ifndef SOAP_TYPE_ns__Camera
#define SOAP_TYPE_ns__Camera (38)
#endif

/* ns__SensorExtension has binding name 'ns__SensorExtension' for type 'ns:SensorExtension' */
#ifndef SOAP_TYPE_ns__SensorExtension
#define SOAP_TYPE_ns__SensorExtension (36)
#endif

/* ns__Sensor has binding name 'ns__Sensor' for type 'ns:Sensor' */
#ifndef SOAP_TYPE_ns__Sensor
#define SOAP_TYPE_ns__Sensor (35)
#endif

/* ns__CalibrationList has binding name 'ns__CalibrationList' for type 'ns:CalibrationList' */
#ifndef SOAP_TYPE_ns__CalibrationList
#define SOAP_TYPE_ns__CalibrationList (33)
#endif

/* ns__Calibration has binding name 'ns__Calibration' for type 'ns:Calibration' */
#ifndef SOAP_TYPE_ns__Calibration
#define SOAP_TYPE_ns__Calibration (32)
#endif

/* ns__GPS has binding name 'ns__GPS' for type 'ns:GPS' */
#ifndef SOAP_TYPE_ns__GPS
#define SOAP_TYPE_ns__GPS (31)
#endif

/* ns__IP has binding name 'ns__IP' for type 'ns:IP' */
#ifndef SOAP_TYPE_ns__IP
#define SOAP_TYPE_ns__IP (30)
#endif

/* ns__UsersList has binding name 'ns__UsersList' for type 'ns:UsersList' */
#ifndef SOAP_TYPE_ns__UsersList
#define SOAP_TYPE_ns__UsersList (28)
#endif

/* ns__User has binding name 'ns__User' for type 'ns:User' */
#ifndef SOAP_TYPE_ns__User
#define SOAP_TYPE_ns__User (27)
#endif

/* ns__ErrorCode has binding name 'ns__ErrorCode' for type 'ns:ErrorCode' */
#ifndef SOAP_TYPE_ns__ErrorCode
#define SOAP_TYPE_ns__ErrorCode (26)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (9)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (154)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (153)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (150)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (148)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (147)
#endif

/* struct ns__ChangeDeviceName has binding name 'ns__ChangeDeviceName' for type 'ns:ChangeDeviceName' */
#ifndef SOAP_TYPE_ns__ChangeDeviceName
#define SOAP_TYPE_ns__ChangeDeviceName (146)
#endif

/* struct ns__ChangeLocationName has binding name 'ns__ChangeLocationName' for type 'ns:ChangeLocationName' */
#ifndef SOAP_TYPE_ns__ChangeLocationName
#define SOAP_TYPE_ns__ChangeLocationName (144)
#endif

/* struct ns__ChangeCityName has binding name 'ns__ChangeCityName' for type 'ns:ChangeCityName' */
#ifndef SOAP_TYPE_ns__ChangeCityName
#define SOAP_TYPE_ns__ChangeCityName (142)
#endif

/* struct ns__GetCityAndLocations has binding name 'ns__GetCityAndLocations' for type 'ns:GetCityAndLocations' */
#ifndef SOAP_TYPE_ns__GetCityAndLocations
#define SOAP_TYPE_ns__GetCityAndLocations (140)
#endif

/* struct ns__SetServerOptions has binding name 'ns__SetServerOptions' for type 'ns:SetServerOptions' */
#ifndef SOAP_TYPE_ns__SetServerOptions
#define SOAP_TYPE_ns__SetServerOptions (137)
#endif

/* struct ns__GetServerOptions has binding name 'ns__GetServerOptions' for type 'ns:GetServerOptions' */
#ifndef SOAP_TYPE_ns__GetServerOptions
#define SOAP_TYPE_ns__GetServerOptions (135)
#endif

/* struct ns__GetDeviceStatusLog has binding name 'ns__GetDeviceStatusLog' for type 'ns:GetDeviceStatusLog' */
#ifndef SOAP_TYPE_ns__GetDeviceStatusLog
#define SOAP_TYPE_ns__GetDeviceStatusLog (132)
#endif

/* struct ns__SaveDeviceStatusLog has binding name 'ns__SaveDeviceStatusLog' for type 'ns:SaveDeviceStatusLog' */
#ifndef SOAP_TYPE_ns__SaveDeviceStatusLog
#define SOAP_TYPE_ns__SaveDeviceStatusLog (129)
#endif

/* struct ns__GetUserLog has binding name 'ns__GetUserLog' for type 'ns:GetUserLog' */
#ifndef SOAP_TYPE_ns__GetUserLog
#define SOAP_TYPE_ns__GetUserLog (127)
#endif

/* struct ns__GetUserLogResponse has binding name 'ns__GetUserLogResponse' for type 'ns:GetUserLogResponse' */
#ifndef SOAP_TYPE_ns__GetUserLogResponse
#define SOAP_TYPE_ns__GetUserLogResponse (126)
#endif

/* struct ns__SaveUserLog has binding name 'ns__SaveUserLog' for type 'ns:SaveUserLog' */
#ifndef SOAP_TYPE_ns__SaveUserLog
#define SOAP_TYPE_ns__SaveUserLog (122)
#endif

/* struct ns__GetActivityLog has binding name 'ns__GetActivityLog' for type 'ns:GetActivityLog' */
#ifndef SOAP_TYPE_ns__GetActivityLog
#define SOAP_TYPE_ns__GetActivityLog (120)
#endif

/* struct ns__GetActivityLogResponse has binding name 'ns__GetActivityLogResponse' for type 'ns:GetActivityLogResponse' */
#ifndef SOAP_TYPE_ns__GetActivityLogResponse
#define SOAP_TYPE_ns__GetActivityLogResponse (119)
#endif

/* struct ns__SaveActivityLog has binding name 'ns__SaveActivityLog' for type 'ns:SaveActivityLog' */
#ifndef SOAP_TYPE_ns__SaveActivityLog
#define SOAP_TYPE_ns__SaveActivityLog (115)
#endif

/* struct ns__GetUserDevices has binding name 'ns__GetUserDevices' for type 'ns:GetUserDevices' */
#ifndef SOAP_TYPE_ns__GetUserDevices
#define SOAP_TYPE_ns__GetUserDevices (113)
#endif

/* struct ns__DeleteDeviceFromUser has binding name 'ns__DeleteDeviceFromUser' for type 'ns:DeleteDeviceFromUser' */
#ifndef SOAP_TYPE_ns__DeleteDeviceFromUser
#define SOAP_TYPE_ns__DeleteDeviceFromUser (111)
#endif

/* struct ns__AssignDeviceToUser has binding name 'ns__AssignDeviceToUser' for type 'ns:AssignDeviceToUser' */
#ifndef SOAP_TYPE_ns__AssignDeviceToUser
#define SOAP_TYPE_ns__AssignDeviceToUser (109)
#endif

/* struct ns__DeleteUser has binding name 'ns__DeleteUser' for type 'ns:DeleteUser' */
#ifndef SOAP_TYPE_ns__DeleteUser
#define SOAP_TYPE_ns__DeleteUser (107)
#endif

/* struct ns__UpdateUser has binding name 'ns__UpdateUser' for type 'ns:UpdateUser' */
#ifndef SOAP_TYPE_ns__UpdateUser
#define SOAP_TYPE_ns__UpdateUser (105)
#endif

/* struct ns__AddUser has binding name 'ns__AddUser' for type 'ns:AddUser' */
#ifndef SOAP_TYPE_ns__AddUser
#define SOAP_TYPE_ns__AddUser (103)
#endif

/* struct ns__GetUsersList has binding name 'ns__GetUsersList' for type 'ns:GetUsersList' */
#ifndef SOAP_TYPE_ns__GetUsersList
#define SOAP_TYPE_ns__GetUsersList (101)
#endif

/* struct ns__GetUserDeviceList has binding name 'ns__GetUserDeviceList' for type 'ns:GetUserDeviceList' */
#ifndef SOAP_TYPE_ns__GetUserDeviceList
#define SOAP_TYPE_ns__GetUserDeviceList (98)
#endif

/* struct ns__Login has binding name 'ns__Login' for type 'ns:Login' */
#ifndef SOAP_TYPE_ns__Login
#define SOAP_TYPE_ns__Login (96)
#endif

/* struct ns__GetDeviceCalibration has binding name 'ns__GetDeviceCalibration' for type 'ns:GetDeviceCalibration' */
#ifndef SOAP_TYPE_ns__GetDeviceCalibration
#define SOAP_TYPE_ns__GetDeviceCalibration (93)
#endif

/* struct ns__SetDeviceCalibration has binding name 'ns__SetDeviceCalibration' for type 'ns:SetDeviceCalibration' */
#ifndef SOAP_TYPE_ns__SetDeviceCalibration
#define SOAP_TYPE_ns__SetDeviceCalibration (90)
#endif

/* struct ns__DeleteDevices has binding name 'ns__DeleteDevices' for type 'ns:DeleteDevices' */
#ifndef SOAP_TYPE_ns__DeleteDevices
#define SOAP_TYPE_ns__DeleteDevices (88)
#endif

/* struct ns__DeleteDevicesResponse has binding name 'ns__DeleteDevicesResponse' for type 'ns:DeleteDevicesResponse' */
#ifndef SOAP_TYPE_ns__DeleteDevicesResponse
#define SOAP_TYPE_ns__DeleteDevicesResponse (87)
#endif

/* struct ns__SetAllDeviceSetting has binding name 'ns__SetAllDeviceSetting' for type 'ns:SetAllDeviceSetting' */
#ifndef SOAP_TYPE_ns__SetAllDeviceSetting
#define SOAP_TYPE_ns__SetAllDeviceSetting (85)
#endif

/* struct ns__SetAllDeviceSettingResponse has binding name 'ns__SetAllDeviceSettingResponse' for type 'ns:SetAllDeviceSettingResponse' */
#ifndef SOAP_TYPE_ns__SetAllDeviceSettingResponse
#define SOAP_TYPE_ns__SetAllDeviceSettingResponse (84)
#endif

/* struct ns__SetDeviceSettingSMS has binding name 'ns__SetDeviceSettingSMS' for type 'ns:SetDeviceSettingSMS' */
#ifndef SOAP_TYPE_ns__SetDeviceSettingSMS
#define SOAP_TYPE_ns__SetDeviceSettingSMS (82)
#endif

/* struct ns__SetDeviceSetting has binding name 'ns__SetDeviceSetting' for type 'ns:SetDeviceSetting' */
#ifndef SOAP_TYPE_ns__SetDeviceSetting
#define SOAP_TYPE_ns__SetDeviceSetting (80)
#endif

/* struct ns__SetDeviceSettingResponse has binding name 'ns__SetDeviceSettingResponse' for type 'ns:SetDeviceSettingResponse' */
#ifndef SOAP_TYPE_ns__SetDeviceSettingResponse
#define SOAP_TYPE_ns__SetDeviceSettingResponse (79)
#endif

/* struct ns__GetDevicePicturePart has binding name 'ns__GetDevicePicturePart' for type 'ns:GetDevicePicturePart' */
#ifndef SOAP_TYPE_ns__GetDevicePicturePart
#define SOAP_TYPE_ns__GetDevicePicturePart (75)
#endif

/* struct ns__GetDevicePicture has binding name 'ns__GetDevicePicture' for type 'ns:GetDevicePicture' */
#ifndef SOAP_TYPE_ns__GetDevicePicture
#define SOAP_TYPE_ns__GetDevicePicture (73)
#endif

/* struct ns__GetAllDeviceStatus has binding name 'ns__GetAllDeviceStatus' for type 'ns:GetAllDeviceStatus' */
#ifndef SOAP_TYPE_ns__GetAllDeviceStatus
#define SOAP_TYPE_ns__GetAllDeviceStatus (71)
#endif

/* struct ns__GetDeviceStatusSMS has binding name 'ns__GetDeviceStatusSMS' for type 'ns:GetDeviceStatusSMS' */
#ifndef SOAP_TYPE_ns__GetDeviceStatusSMS
#define SOAP_TYPE_ns__GetDeviceStatusSMS (68)
#endif

/* struct ns__GetDeviceStatus has binding name 'ns__GetDeviceStatus' for type 'ns:GetDeviceStatus' */
#ifndef SOAP_TYPE_ns__GetDeviceStatus
#define SOAP_TYPE_ns__GetDeviceStatus (65)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (156)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (155)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (149)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns__UserLog>  has binding name 'std__vectorTemplateOfns__UserLog' for type 'ns:UserLog' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__UserLog
#define SOAP_TYPE_std__vectorTemplateOfns__UserLog (123)
#endif

/* std::vector<ns__ActivityLog>  has binding name 'std__vectorTemplateOfns__ActivityLog' for type 'ns:ActivityLog' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__ActivityLog
#define SOAP_TYPE_std__vectorTemplateOfns__ActivityLog (116)
#endif

/* std::vector<ns__ErrorCode>  has binding name 'std__vectorTemplateOfns__ErrorCode' for type 'ns:ErrorCode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__ErrorCode
#define SOAP_TYPE_std__vectorTemplateOfns__ErrorCode (76)
#endif

/* std::vector<ns__CityLocation>  has binding name 'std__vectorTemplateOfns__CityLocation' for type 'ns:CityLocation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__CityLocation
#define SOAP_TYPE_std__vectorTemplateOfns__CityLocation (62)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__string
#define SOAP_TYPE_std__vectorTemplateOfxsd__string (60)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (54)
#endif

/* std::vector<ns__Device>  has binding name 'std__vectorTemplateOfns__Device' for type 'ns:Device' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__Device
#define SOAP_TYPE_std__vectorTemplateOfns__Device (53)
#endif

/* std::vector<ns__DeviceStatusLog>  has binding name 'std__vectorTemplateOfns__DeviceStatusLog' for type 'ns:DeviceStatusLog' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog
#define SOAP_TYPE_std__vectorTemplateOfns__DeviceStatusLog (51)
#endif

/* std::vector<ns__SensorExtension>  has binding name 'std__vectorTemplateOfns__SensorExtension' for type 'ns:SensorExtension' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__SensorExtension
#define SOAP_TYPE_std__vectorTemplateOfns__SensorExtension (45)
#endif

/* std::vector<enum ns__RequestType>  has binding name 'std__vectorTemplateOfns__RequestType' for type 'ns:RequestType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__RequestType
#define SOAP_TYPE_std__vectorTemplateOfns__RequestType (44)
#endif

/* std::vector<bool>  has binding name 'std__vectorTemplateOfxsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__boolean
#define SOAP_TYPE_std__vectorTemplateOfxsd__boolean (43)
#endif

/* std::vector<ns__PicturePart>  has binding name 'std__vectorTemplateOfns__PicturePart' for type 'ns:PicturePart' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__PicturePart
#define SOAP_TYPE_std__vectorTemplateOfns__PicturePart (41)
#endif

/* std::vector<double>  has binding name 'std__vectorTemplateOfxsd__double' for type 'xsd:double' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__double
#define SOAP_TYPE_std__vectorTemplateOfxsd__double (37)
#endif

/* std::vector<ns__Calibration>  has binding name 'std__vectorTemplateOfns__Calibration' for type 'ns:Calibration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__Calibration
#define SOAP_TYPE_std__vectorTemplateOfns__Calibration (34)
#endif

/* std::vector<ns__User>  has binding name 'std__vectorTemplateOfns__User' for type 'ns:User' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns__User
#define SOAP_TYPE_std__vectorTemplateOfns__User (29)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/

    /** Web service operation 'ns__GetDeviceStatus' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetDeviceStatus(struct soap*, ns__User requestUser, ns__Device requestDevice, ns__Device &responseDevice);
    /** Web service operation 'ns__GetDeviceStatusSMS' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetDeviceStatusSMS(struct soap*, ns__User requestUser, ns__Device requestDevice, ns__ErrorCode &responseError);
    /** Web service operation 'ns__GetAllDeviceStatus' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetAllDeviceStatus(struct soap*, ns__User requestUser, ns__UserDevice &responseUserDevices);
    /** Web service operation 'ns__GetDevicePicture' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetDevicePicture(struct soap*, ns__User requestUser, ns__Device requestDevice, ns__Device &responseDevice);
    /** Web service operation 'ns__GetDevicePicturePart' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetDevicePicturePart(struct soap*, ns__User requestUser, ns__Device requestDevice, ns__Device &responseDevice);
    /** Web service operation 'ns__SetDeviceSetting' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SetDeviceSetting(struct soap*, ns__User requestUser, ns__Device requestDevice, std::vector<ns__ErrorCode> &responseError);
    /** Web service operation 'ns__SetDeviceSettingSMS' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SetDeviceSettingSMS(struct soap*, ns__User requestUser, ns__Device requestDevice, ns__ErrorCode &responseError);
    /** Web service operation 'ns__SetAllDeviceSetting' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SetAllDeviceSetting(struct soap*, ns__User requestUser, std::vector<ns__Device> requestDevice, std::vector<ns__ErrorCode> &responseError);
    /** Web service operation 'ns__DeleteDevices' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__DeleteDevices(struct soap*, ns__User requestUser, std::vector<ns__Device> requestDeviceList, std::vector<ns__ErrorCode> &responseError);
    /** Web service operation 'ns__SetDeviceCalibration' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SetDeviceCalibration(struct soap*, ns__User requestUser, ns__Device requestDevice, ns__CalibrationList requestCalibrationList, ns__ErrorCode &responseError);
    /** Web service operation 'ns__GetDeviceCalibration' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetDeviceCalibration(struct soap*, ns__User requestUser, ns__Device requestDevice, ns__CalibrationList &responsCalibrationList);
    /** Web service operation 'ns__Login' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__Login(struct soap*, ns__User requestUser, ns__User &responseUser);
    /** Web service operation 'ns__GetUserDeviceList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetUserDeviceList(struct soap*, ns__User requestUser, ns__UserDevice &responseUserDevices);
    /** Web service operation 'ns__GetUsersList' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetUsersList(struct soap*, ns__User requestUser, ns__UsersList &responseUsersList);
    /** Web service operation 'ns__AddUser' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__AddUser(struct soap*, ns__User requestUser, ns__User requestNewUser, ns__ErrorCode &responseError);
    /** Web service operation 'ns__UpdateUser' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__UpdateUser(struct soap*, ns__User requestUser, ns__User requestNewUser, ns__ErrorCode &responseError);
    /** Web service operation 'ns__DeleteUser' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__DeleteUser(struct soap*, ns__User requestUser, ns__User requestDeleteUser, ns__ErrorCode &responseError);
    /** Web service operation 'ns__AssignDeviceToUser' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__AssignDeviceToUser(struct soap*, ns__User requestUser, ns__UserDevice requestUserDevice, ns__ErrorCode &responseError);
    /** Web service operation 'ns__DeleteDeviceFromUser' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__DeleteDeviceFromUser(struct soap*, ns__User requestUser, ns__UserDevice requestUserDevice, ns__ErrorCode &responseError);
    /** Web service operation 'ns__GetUserDevices' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetUserDevices(struct soap*, ns__User requestUser, ns__User requestSelectedUser, ns__UserDevice &responseUserDevices);
    /** Web service operation 'ns__SaveActivityLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SaveActivityLog(struct soap*, ns__User requestUser, ns__ActivityLog requestActivityLog, ns__ErrorCode &responseError);
    /** Web service operation 'ns__GetActivityLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetActivityLog(struct soap*, ns__User requestUser, ns__ReportRange requestReport, std::vector<ns__ActivityLog> &responseActivityLog);
    /** Web service operation 'ns__SaveUserLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SaveUserLog(struct soap*, ns__User requestUser, ns__UserLog requestActivityLog, ns__ErrorCode &responseError);
    /** Web service operation 'ns__GetUserLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetUserLog(struct soap*, ns__User requestUser, ns__ReportRange requestReport, std::vector<ns__UserLog> &responseActivityLog);
    /** Web service operation 'ns__SaveDeviceStatusLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SaveDeviceStatusLog(struct soap*, ns__User requestUser, ns__DeviceStatusLog requestStatusLog, ns__ErrorCode &responseError);
    /** Web service operation 'ns__GetDeviceStatusLog' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetDeviceStatusLog(struct soap*, ns__User requestUser, ns__DeviceStatus requestStatusLog, ns__DeviceStatusLogList &responseStatusLogList);
    /** Web service operation 'ns__GetServerOptions' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetServerOptions(struct soap*, ns__User requestUser, ns__ServerOptions &serverOptions);
    /** Web service operation 'ns__SetServerOptions' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__SetServerOptions(struct soap*, ns__User requestUser, ns__ServerOptions serverOptions, ns__ErrorCode &responseError);
    /** Web service operation 'ns__GetCityAndLocations' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__GetCityAndLocations(struct soap*, ns__User requestUser, ns__AllCityLocatoins &responseCityLocation);
    /** Web service operation 'ns__ChangeCityName' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__ChangeCityName(struct soap*, ns__User requestUser, std::string oldCityName, std::string newCityName, ns__ErrorCode &responseError);
    /** Web service operation 'ns__ChangeLocationName' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__ChangeLocationName(struct soap*, ns__User requestUser, std::string oldCityName, std::string newCityName, std::string oldLocationName, std::string newLocationName, ns__ErrorCode &responseError);
    /** Web service operation 'ns__ChangeDeviceName' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 ns__ChangeDeviceName(struct soap*, ns__User requestUser, int deviceSerialNumber, std::string newCityName, std::string newLocationName, std::string newDeviceName, ns__ErrorCode &responseError);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDeviceStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDeviceStatusSMS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetAllDeviceStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDevicePicture(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDevicePicturePart(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetDeviceSetting(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetDeviceSettingSMS(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetAllDeviceSetting(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__DeleteDevices(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetDeviceCalibration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDeviceCalibration(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__Login(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUserDeviceList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUsersList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__AddUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__UpdateUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__DeleteUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__AssignDeviceToUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__DeleteDeviceFromUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUserDevices(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SaveActivityLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetActivityLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SaveUserLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetUserLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SaveDeviceStatusLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetDeviceStatusLog(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetServerOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SetServerOptions(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__GetCityAndLocations(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ChangeCityName(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ChangeLocationName(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__ChangeDeviceName(struct soap*);

#endif

/* End of Server_SoapStub.h */
